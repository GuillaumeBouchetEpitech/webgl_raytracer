"use strict";function e(e,t,n,i){return new(n||(n=Promise))((function(r,s){function o(e){try{f(i.next(e))}catch(e){s(e)}}function a(e){try{f(i.throw(e))}catch(e){s(e)}}function f(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}f((i=i.apply(e,t||[])).next())}))}const t={Num0:48,Num1:49,Num2:50,Num3:51,Num4:52,Num5:53,Num6:54,Num7:55,Num8:56,Num9:57,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,Semicolon:186,Equal:187,Comma:188,Minus:189,Period:190,BackQuote:192,BracketLeft:219,Backslash:220,BracketRight:221,Quote:222,Shift:16,Ctrl:17,Alt:18,CapsLock:20,Tab:9,Enter:13,Pause:19,Escape:27,Space:32,PageUp:33,PageDown:34,End:35,Home:36,ArrowLeft:37,ArrowUp:38,ArrowRight:39,ArrowDown:40,PrintScreen:44,Insert:45,Delete:46,ContextMenu:93,ScrollLock:145,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,F13:124,F14:125,F15:126,F16:127,F17:128,F18:129,F19:130,F20:131,F21:132,F22:133,F23:134,F24:135,NumPad0:96,NumPad1:97,NumPad2:98,NumPad3:99,NumPad4:100,NumPad5:101,NumPad6:102,NumPad7:103,NumPad8:104,NumPad9:105,NumPadMultiply:106,NumPadAdd:107,NumPadSubtract:109,NumPadDecimal:110,NumPadDivide:111,NumLock:144,NumPadComma:194,NumPadEqual:12};const n=new class{constructor(){this._pressedKeysSet=new Set,this._preventDefaultKeysSet=new Set,this._activated=!1;this._activated=!1,this._handleKeyDown=(e=>{const{keyCode:t}=e;this._preventDefaultKeysSet.has(t)&&e.preventDefault(),this._pressedKeysSet.add(t)}).bind(this),this._handleKeyUp=(e=>{const{keyCode:t}=e;this._preventDefaultKeysSet.has(t)&&e.preventDefault(),this._pressedKeysSet.delete(t)}).bind(this)}isPressed(...e){for(const n of e)if(this._pressedKeysSet.has(t[n]))return!0;return!1}preventDefault(e){this._preventDefaultKeysSet.add(t[e])}enableDefault(e){this._preventDefaultKeysSet.delete(t[e])}activate(){this._activated||(this._pressedKeysSet.clear(),document.addEventListener("keydown",this._handleKeyDown),document.addEventListener("keyup",this._handleKeyUp),this._activated=!0)}deactivate(){this._activated&&(this._pressedKeysSet.clear(),document.removeEventListener("keydown",this._handleKeyDown),document.removeEventListener("keyup",this._handleKeyUp),this._activated=!1)}},i={Left:0,Middle:1,Right:2};const r=new class{constructor(){this._pressedButtonsSet=new Set,this._activated=!1,this._deltaX=0,this._deltaY=0;this._activated=!1,this._handleMouseDown=(e=>{this._pressedButtonsSet.add(e.button)}).bind(this),this._handleMouseUp=(e=>{this._pressedButtonsSet.delete(e.button)}).bind(this),this._handleMouseMove=(e=>{this._deltaX+=e.movementX||e.mozMovementX||e.webkitMovementX||0,this._deltaY+=e.movementY||e.mozMovementY||e.webkitMovementY||0}).bind(this)}activate(){this._activated||(this._pressedButtonsSet.clear(),document.addEventListener("mousedown",this._handleMouseDown),document.addEventListener("mouseup",this._handleMouseUp),document.addEventListener("mousemove",this._handleMouseMove),this._activated=!0)}deactivate(){this._activated&&(this._pressedButtonsSet.clear(),document.removeEventListener("mousedown",this._handleMouseDown),document.removeEventListener("mouseup",this._handleMouseUp),document.removeEventListener("mousemove",this._handleMouseMove),this._activated=!1)}isButtonPressed(e){return this._pressedButtonsSet.has(i[e])}deltaX(){return this._deltaX}deltaY(){return this._deltaY}resetDelta(){this._deltaX=0,this._deltaY=0}},s=["requestPointerLock","mozRequestPointerLock","webkitRequestPointerLock"],o=["exitPointerLock","mozExitPointerLock","webkitExitPointerLock"],a=["pointerLockElement","mozPointerLockElement","webkitPointerLockElement"],f=[{methodName:"onpointerlockchange",propertyName:"pointerlockchange"},{methodName:"onmozpointerlockchange",propertyName:"mozpointerlockchange"},{methodName:"onwebkitpointerlockchange",propertyName:"webkitpointerlockchange"}],d=[{methodName:"onpointerlockerror",propertyName:"pointerlockerror"},{methodName:"onmozpointerlockerror",propertyName:"mozpointerlockerror"},{methodName:"onwebkitpointerlockerror",propertyName:"webkitpointerlockerror"}];const c=new class{constructor(){this._onLockChangeCallbacks=[],this._onLockErrorCallbacks=[],this._timeSinceLastLockChange=0,this._isInitialized=!1}_initialize(){if(this._isInitialized)return;this._isInitialized=!0;const e=()=>{this._timeSinceLastLockChange=Date.now(),this._onLockChangeCallbacks.forEach((e=>e()))},t=e=>{this._timeSinceLastLockChange=Date.now(),this._onLockErrorCallbacks.forEach((t=>t(e)))};for(const t of f)if(t.methodName in document){document.addEventListener(t.propertyName,e,!1);break}for(const e of d)if(e.methodName in document){document.addEventListener(e.propertyName,t,!1);break}}canBePointerLocked(e){for(const t of s)if(t in e)return!0;return!1}isPointerLocked(e){for(const t of a)if(t in document)return document[t]===e;return!1}requestPointerLock(t){return e(this,void 0,void 0,(function*(){if(this.isPointerLocked(t))return{success:!1,message:"element already locked"};if(this._initialize(),this._timeSinceLastLockChange>0){const e=(Date.now()-this._timeSinceLastLockChange)/1e3;if(e<1.1)return{success:!1,message:`request for lock was too early, time to wait: ${e.toFixed(2)}sec`}}this._timeSinceLastLockChange=Date.now();for(const e of s)if(e in t){const n={unadjustedMovement:!1};try{yield t[e](n)}catch(e){return{success:!1,message:`request for lock was too early, time to wait: ${((Date.now()-this._timeSinceLastLockChange)/1e3).toFixed(2)}sec`}}return this._timeSinceLastLockChange=Date.now(),{success:!0,message:"request for lock done"}}return{success:!1,message:"unsupported request for lock"}}))}allowPointerLockedOnClickEvent(t){if(t===this._latestRequestHtmlElement)return;this._latestRequestHtmlElement=t;const n=()=>e(this,void 0,void 0,(function*(){t.removeEventListener("click",n);const e=yield this.requestPointerLock(t);this._latestRequestHtmlElement=void 0,e.success||this.allowPointerLockedOnClickEvent(t)}));t.addEventListener("click",n)}exitPointerLock(){for(const e of o)if(e in document){document[e]();break}}addOnLockChange(e){this._onLockChangeCallbacks.push(e)}removeOnLockChange(e){const t=this._onLockChangeCallbacks.indexOf(e);t<0||this._onLockChangeCallbacks.splice(t,1)}addOnLockError(e){this._onLockErrorCallbacks.push(e)}removeOnLockError(e){const t=this._onLockErrorCallbacks.indexOf(e);t<0||this._onLockErrorCallbacks.splice(t,1)}};class h{constructor(e,t,n){this.createdAt=Date.now(),this.deltaX=0,this.deltaY=0,this.id=e,this.positionX=t,this.positionY=n}resetDelta(){this.deltaX=0,this.deltaY=0}}const l=new class{constructor(){this._activated=!1,this._allTouchDataMap=new Map,this._allCachedTouchDataArray=[];this._activated=!1,this._handleTouchStart=(e=>{e.preventDefault();for(let t=0;t<e.changedTouches.length;++t){const{identifier:n,pageX:i,pageY:r}=e.changedTouches[t],s=new h(n,i,r);this._allTouchDataMap.set(`${n}`,s),this._allCachedTouchDataArray.length=0}}).bind(this),this._handleTouchEnd=(e=>{e.preventDefault();for(let t=0;t<e.changedTouches.length;++t){const{identifier:n}=e.changedTouches[t];this._allTouchDataMap.delete(`${n}`),this._allCachedTouchDataArray.length=0}}).bind(this),this._handleTouchMove=(e=>{e.preventDefault();for(let t=0;t<e.changedTouches.length;++t){const{identifier:n,pageX:i,pageY:r}=e.changedTouches[t],s=this._allTouchDataMap.get(`${n}`);if(!s)continue;const o=i-s.positionX,a=r-s.positionY;s.deltaX+=o,s.deltaY+=a,s.positionX=i,s.positionY=r}}).bind(this)}isSupported(e){return"ontouchstart"in e}activate(e){this.isSupported(e)&&(this._activated||(this._allTouchDataMap.clear(),this._allCachedTouchDataArray.length=0,e.addEventListener("touchstart",this._handleTouchStart),e.addEventListener("touchend",this._handleTouchEnd),e.addEventListener("touchcancel",this._handleTouchEnd),e.addEventListener("touchmove",this._handleTouchMove,{passive:!1}),this._activated=!0))}deactivate(e){this._activated&&(this._allTouchDataMap.clear(),this._allCachedTouchDataArray.length=0,e.removeEventListener("touchstart",this._handleTouchStart),e.removeEventListener("touchend",this._handleTouchEnd),e.removeEventListener("touchcancel",this._handleTouchEnd),e.removeEventListener("touchmove",this._handleTouchMove),this._activated=!1)}_refreshCache(){0===this._allCachedTouchDataArray.length&&(this._allCachedTouchDataArray=[...this._allTouchDataMap.values()])}getTouchData(){return this._refreshCache(),this._allCachedTouchDataArray}resetDeltas(){this._refreshCache(),this._allCachedTouchDataArray.forEach((e=>e.resetDelta()))}};class u{static initialize(e){if(u._gl=e.getContext("webgl2",{alpha:!1,antialias:!1,depth:!0,failIfMajorPerformanceCaveat:!1,powerPreference:"high-performance",premultipliedAlpha:!0,preserveDrawingBuffer:!0,stencil:!1}),!u._gl)throw new Error("could not create webgl context");u._extensionLoseContext=u._gl.getExtension("WEBGL_lose_context"),u._gl.getExtension("EXT_color_buffer_float"),u._gl.getExtension("EXT_float_blend")}static getContext(){if(!u._gl)throw new Error("webgl context not initialized");return u._gl}static getExtensionLoseContext(){return u._extensionLoseContext}static getExtensionLoseContextStrict(){if(!u._extensionLoseContext)throw new Error("lose context extension not available");return u._extensionLoseContext}}u._gl=null,u._extensionLoseContext=null;class _{constructor(){this._texture=null}initialize(e=[]){if(this._texture)throw new Error("data texture already initialized");const t=u.getContext();this._texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this._texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),this.update(e)}update(e){if(!this._texture)throw new Error("data texture not initialized");const t=u.getContext();t.bindTexture(t.TEXTURE_2D,this._texture);const n=new Float32Array(e),i=t.R32F,r=e.length,s=t.RED,o=t.FLOAT;t.texImage2D(t.TEXTURE_2D,0,i,r,1,0,s,o,n)}bind(){if(!this._texture)throw new Error("data texture not initialized");const e=u.getContext();e.bindTexture(e.TEXTURE_2D,this._texture)}}class p{constructor(){const e=u.getContext();this._frameBuffer=e.createFramebuffer()}attachTexture(e){const t=u.getContext();t.bindFramebuffer(t.FRAMEBUFFER,this._frameBuffer);t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e.getRawObject(),0)}bind(){const e=u.getContext();e.bindFramebuffer(e.FRAMEBUFFER,this._frameBuffer)}static unbind(){const e=u.getContext();e.bindFramebuffer(e.FRAMEBUFFER,null)}}var g;!function(e){let t;e.BytesPerPixel=4,function(e){e[e.float=0]="float",e[e.vec2f=1]="vec2f",e[e.vec3f=2]="vec3f",e[e.vec4f=3]="vec4f",e[e.mat3f=4]="mat3f",e[e.mat4f=5]="mat4f"}(t=e.AttributeType||(e.AttributeType={}));const n=e=>{switch(e){case t.float:return 1;case t.vec2f:return 2;case t.vec3f:return 3;case t.vec4f:return 4;case t.mat3f:return 9;case t.mat4f:return 16}};let i;!function(e){e[e.lines=0]="lines",e[e.triangles=1]="triangles",e[e.triangleStrip=2]="triangleStrip"}(i=e.PrimitiveType||(e.PrimitiveType={}));e.Geometry=class{constructor(n,r){this._primitiveStart=0,this._primitiveCount=0,this._instanceCount=0,this._isInstanced=!1;const s=u.getContext();if(0===r.vbos.length)throw new Error("empty vbo definition");for(const e of r.vbos){if(0===e.attrs.length)throw new Error("empty vbo attribute definition");for(const t of e.attrs)if(!n.hasAttribute(t.name))throw new Error(`attribute not found, name="${t.name}"`)}switch(this._def=r,r.primitiveType){case i.lines:this._primitiveType=s.LINES;break;case i.triangles:this._primitiveType=s.TRIANGLES;break;case i.triangleStrip:this._primitiveType=s.TRIANGLE_STRIP;break;default:throw new Error("primitive type not found")}const o=s.createVertexArray();if(!o)throw new Error("fail o create a vao unit");this._vao=o,s.bindVertexArray(this._vao),this._vbos=[];for(const i of this._def.vbos){const r=s.createBuffer();if(!r)throw new Error("fail o create a vbo unit");this._vbos.push({object:r,maxSize:0,dynamic:i.dynamic||!1}),s.bindBuffer(s.ARRAY_BUFFER,r);let o=i.stride||0;if(!o){for(const e of i.attrs)switch(e.type){case t.float:o+=1;break;case t.vec2f:o+=2;break;case t.vec3f:o+=3;break;case t.vec4f:o+=4;break;case t.mat3f:o+=9;break;case t.mat4f:o+=16}o*=e.BytesPerPixel}for(const r of i.attrs){let a=1,f=1;switch(r.type){case t.float:a=1,f=1;break;case t.vec2f:a=2,f=1;break;case t.vec3f:a=3,f=1;break;case t.vec4f:a=4,f=1;break;case t.mat3f:a=3,f=3;break;case t.mat4f:a=4,f=4}const d=n.getAttribute(r.name);for(let t=0;t<f;++t){const n=d+t,f=(r.index+t*a)*e.BytesPerPixel;s.enableVertexAttribArray(n),s.vertexAttribPointer(n,a,s.FLOAT,!1,o,f),!0===i.instanced&&(s.vertexAttribDivisor(n,1),this._isInstanced=!0)}}}s.bindVertexArray(null)}dispose(){const e=u.getContext();for(const t of this._vbos)e.deleteBuffer(t.object);this._vbos.length=0,e.deleteVertexArray(this._vao)}setBufferSize(e,t){if(e<0||e>=this._vbos.length)throw new Error("no buffer available to that index");if(t<=0)return;const n=this._vbos[e];if(t<n.maxSize)return;n.maxSize=t;const i=u.getContext(),r=n.dynamic?i.DYNAMIC_DRAW:i.STATIC_DRAW;i.bindBuffer(i.ARRAY_BUFFER,n.object),i.bufferData(i.ARRAY_BUFFER,t,r),i.bindBuffer(i.ARRAY_BUFFER,null)}setFloatBufferSize(e,t){this.setBufferSize(e,4*t)}updateBuffer(e,t,n){if(e<0||e>=this._vbos.length)throw new Error("no buffer available to that index");if(n<=0)return;const i=u.getContext(),r=t instanceof Float32Array?t:new Float32Array(t),s=this._vbos[e];if(i.bindBuffer(i.ARRAY_BUFFER,s.object),n>s.maxSize){s.maxSize=n;const e=s.dynamic?i.DYNAMIC_DRAW:i.STATIC_DRAW;i.bufferData(i.ARRAY_BUFFER,r,e,0,n)}else i.bufferSubData(i.ARRAY_BUFFER,0,r,0,n);i.bindBuffer(i.ARRAY_BUFFER,null)}render(){if(0==this._primitiveCount)return;if(this._isInstanced&&0==this._instanceCount)return;const e=u.getContext();e.bindVertexArray(this._vao),!0===this._isInstanced?e.drawArraysInstanced(this._primitiveType,this._primitiveStart,this._primitiveCount,this._instanceCount):e.drawArrays(this._primitiveType,this._primitiveStart,this._primitiveCount),e.bindVertexArray(null)}setPrimitiveStart(e){this._primitiveStart=e}setPrimitiveCount(e){this._primitiveCount=e}setInstancedCount(e){this._instanceCount=e}};e.GeometryBuilder=class{constructor(){this._def={vbos:[],primitiveType:i.lines}}reset(){return this._def={vbos:[],primitiveType:i.lines},this}getDef(){return this._def}setPrimitiveType(e){return this._def.primitiveType=i[e],this}addVbo(){return this._def.vbos.push({attrs:[],instanced:!1}),this}setVboAsInstanced(){return this._getLastVbo().instanced=!0,this}setVboAsDynamic(){return this._getLastVbo().dynamic=!0,this}setStride(e){return this._getLastVbo().stride=e,this}addVboAttribute(e,i){const r=this._getLastVbo(),s=r.attrs.length>0?r.attrs[r.attrs.length-1]:null;return r.attrs.push({name:e,type:t[i],index:s?s.index+n(s.type):0}),this}_getLastVbo(){if(0===this._def.vbos.length)throw new Error("no VBO setup");return this._def.vbos[this._def.vbos.length-1]}}}(g||(g={}));class m{constructor(e,t){this._attributes=new Map,this._uniforms=new Map,this._name=e;const n=u.getContext(),i=this._getShader(t.vertexSrc,n.VERTEX_SHADER),r=this._getShader(t.fragmentSrc,n.FRAGMENT_SHADER),s=n.createProgram();if(!s)throw new Error("could not create a shader program");if(n.attachShader(s,i),n.attachShader(s,r),n.linkProgram(s),n.deleteShader(i),n.deleteShader(r),!n.getProgramParameter(s,n.LINK_STATUS)){const e=n.getProgramInfoLog(s);throw new Error("Failed to initialized shaders, Error linking:"+e)}this._program=s,this.bind((()=>{this._getAttributes(t.attributes),this._getUniforms(t.uniforms)}))}bind(t){return e(this,void 0,void 0,(function*(){if(null!==m._isBound)throw new Error(`Double shader binding (bound: ${m._isBound._name}, binding: ${this._name})`);m._isBound=this;u.getContext().useProgram(this._program),t(),m.unbind()}))}static unbind(){u.getContext().useProgram(null),m._isBound=null}isBound(){return m._isBound===this}hasAttribute(e){return this._attributes.has(e)}getAttribute(e){const t=this._attributes.get(e);if(void 0===t)throw new Error(`attribute not found: ${e}`);return t}getUniform(e){const t=this._uniforms.get(e);if(void 0===t)throw new Error(`uniform not found: ${e}`);return t}setTextureUniform(e,t,n){const i=u.getContext();i.activeTexture(i.TEXTURE0+n),i.uniform1i(this.getUniform(e),n),t.bind()}setInteger1Uniform(e,t){u.getContext().uniform1i(this.getUniform(e),t)}setInteger2Uniform(e,t,n){u.getContext().uniform2i(this.getUniform(e),t,n)}setInteger3Uniform(e,t,n,i){u.getContext().uniform3i(this.getUniform(e),t,n,i)}setFloat1Uniform(e,t){u.getContext().uniform1f(this.getUniform(e),t)}setFloat2Uniform(e,t,n){u.getContext().uniform2f(this.getUniform(e),t,n)}setFloat3Uniform(e,t,n,i){u.getContext().uniform3f(this.getUniform(e),t,n,i)}setMatrix4Uniform(e,t){u.getContext().uniformMatrix4fv(this.getUniform(e),!1,t)}_getAttributes(e){const t=u.getContext();for(let n=0;n<e.length;++n){const i=t.getAttribLocation(this._program,e[n]);if(i<0)throw new Error(`attribute not found => ${e[n]}`);this._attributes.set(e[n],i)}}_getUniforms(e){const t=u.getContext();for(let n=0;n<e.length;++n){const i=t.getUniformLocation(this._program,e[n]);if(null===i)throw new Error(`uniform not found => ${e[n]}`);this._uniforms.set(e[n],i)}}_getShader(e,t){const n=u.getContext(),i=n.createShader(t);if(!i)throw new Error("could not create a shader");if(n.shaderSource(i,e),n.compileShader(i),!n.getShaderParameter(i,n.COMPILE_STATUS)){let e=n.getShaderInfoLog(i);throw e||(e="failed to compile a shader"),new Error(e)}return i}}m._isBound=null;class x{constructor(){this._width=0,this._height=0,this._texture=null}loadFromMemory(e,t,n){this._allocate(e,t,n)}allocate(e,t){this._allocate(e,t)}resize(e,t){this._allocate(e,t)}_allocate(e,t,n=null){const i=u.getContext();this._texture||(this._texture=i.createTexture()),i.bindTexture(i.TEXTURE_2D,this._texture),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST);const r=i.RGBA,s=i.RGBA,o=i.UNSIGNED_BYTE;i.texImage2D(i.TEXTURE_2D,0,r,e,t,0,s,o,n),i.bindTexture(i.TEXTURE_2D,null)}getWidth(){if(!this._texture)throw new Error("texture not initialized");return this._width}getHeight(){if(!this._texture)throw new Error("texture not initialized");return this._height}bind(){if(!this._texture)throw new Error("texture not initialized");const e=u.getContext();e.bindTexture(e.TEXTURE_2D,this._texture)}static unbind(){const e=u.getContext();e.bindTexture(e.TEXTURE_2D,null)}getRawObject(){if(!this._texture)throw new Error("texture not initialized");return this._texture}}class v{constructor(e){if(this._lines=[],this._maxLines=30,this._textAreaElement=document.getElementById(e),!this._textAreaElement)throw new Error(`DOM elements not found, id=${e}`);this._textAreaElement.value=""}log(...e){if(0===e.length)return;const t=Array.prototype.slice.call(e).join(" ");console.log(t),this._pushText(t)}error(...e){if(0===e.length)return;const t=Array.prototype.slice.call(e).join(" ");console.error(t),this._pushText(`[ERR] - ${t}`)}_pushText(e){this._lines.push(e),this._lines.length>this._maxLines&&this._lines.splice(0,this._lines.length-this._maxLines),this._textAreaElement.value=`${this._lines.join("\n")}\n`,this._textAreaElement.scrollTop=this._textAreaElement.scrollHeight}peekLast(){if(this._lines.length>0)return this._lines[this._lines.length-1]}popLast(){this._lines.length>0&&this._lines.splice(this._lines.length-1,1)}}class b{constructor(){this._framesDelta=[],this._averageDelta=0,this._minDelta=0,this._maxDelta=0}pushDelta(e){this._framesDelta.length>=100&&this._framesDelta.shift(),this._framesDelta.push(e),this._minDelta=999999999,this._maxDelta=-999999999,this._averageDelta=0;for(const e of this._framesDelta)this._minDelta=Math.min(this._minDelta,e),this._maxDelta=Math.max(this._maxDelta,e),this._averageDelta+=e;this._averageDelta/=this._framesDelta.length}get framesDelta(){return this._framesDelta}get averageDelta(){return this._averageDelta}get minDelta(){return this._minDelta}get maxDelta(){return this._maxDelta}}var y=1e-6,S="undefined"!=typeof Float32Array?Float32Array:Array;function T(){var e=new S(16);return S!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function E(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function w(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var D=function(e,t,n,i,r){var s,o=1/Math.tan(t/2);return e[0]=o/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=r&&r!==1/0?(s=1/(i-r),e[10]=(r+i)*s,e[14]=2*r*i*s):(e[10]=-1,e[14]=-2*i),e};var R=function(e,t,n,i,r,s,o){var a=1/(t-n),f=1/(i-r),d=1/(s-o);return e[0]=-2*a,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*f,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*d,e[11]=0,e[12]=(t+n)*a,e[13]=(r+i)*f,e[14]=(o+s)*d,e[15]=1,e};function C(){var e=new S(3);return S!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function z(e){var t=new S(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function A(e){var t=e[0],n=e[1],i=e[2];return Math.hypot(t,n,i)}function L(e,t,n){var i=new S(3);return i[0]=e,i[1]=t,i[2]=n,i}function k(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function M(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function P(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function F(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function I(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function B(e,t,n,i){return e[0]=t[0]+n[0]*i,e[1]=t[1]+n[1]*i,e[2]=t[2]+n[2]*i,e}function U(e,t){var n=t[0],i=t[1],r=t[2],s=n*n+i*i+r*r;return s>0&&(s=1/Math.sqrt(s)),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e}function V(e,t,n){var i=t[0],r=t[1],s=t[2],o=n[0],a=n[1],f=n[2];return e[0]=r*f-s*a,e[1]=s*o-i*f,e[2]=i*a-r*o,e}function N(e,t,n,i){var r=t[0],s=t[1],o=t[2];return e[0]=r+i*(n[0]-r),e[1]=s+i*(n[1]-s),e[2]=o+i*(n[2]-o),e}var O=P;function H(){var e=new S(4);return S!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}C(),function(){var e,t=(e=new S(4),S!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e)}();var X;function W(e,t){var n=new S(2);return n[0]=e,n[1]=t,n}C(),L(1,0,0),L(0,1,0),H(),H(),X=new S(9),S!=Float32Array&&(X[1]=0,X[2]=0,X[3]=0,X[5]=0,X[6]=0,X[7]=0),X[0]=1,X[4]=1,X[8]=1,function(){var e=function(){var e=new S(2);return S!=Float32Array&&(e[0]=0,e[1]=0),e}()}();const G=[.2,.2,.2],j=[.2,.6,.2],Y=(e,t,i)=>{const r=[];var s,o;o=[27,165],(s=r).push({center:[o[0],o[1]],size:[40,40],text:"A\nQ",color:n.isPressed("A","Q")?j:G}),s.push({center:[o[0]+45,o[1]],size:[40,40],text:"S",color:n.isPressed("S")?j:G}),s.push({center:[o[0]+45,o[1]+45],size:[40,40],text:"W\nZ",color:n.isPressed("W","Z")?j:G}),s.push({center:[o[0]+90,o[1]],size:[40,40],text:"D",color:n.isPressed("D")?j:G}),((e,t)=>{e.push({center:[t[0],t[1]],size:[40,40],lines:[{a:[15,0],b:[-8,0],thickness:6,color:[1,1,1]},{a:[0,10],b:[-12,-2],thickness:6,color:[1,1,1]},{a:[0,-10],b:[-12,2],thickness:6,color:[1,1,1]}],color:n.isPressed("ArrowLeft")?j:G}),e.push({center:[t[0]+45,t[1]],size:[40,40],lines:[{a:[0,15],b:[0,-8],thickness:6,color:[1,1,1]},{a:[10,0],b:[-2,-12],thickness:6,color:[1,1,1]},{a:[-10,0],b:[2,-12],thickness:6,color:[1,1,1]}],color:n.isPressed("ArrowDown")?j:G}),e.push({center:[t[0]+45,t[1]+45],size:[40,40],lines:[{a:[0,-15],b:[0,8],thickness:6,color:[1,1,1]},{a:[10,0],b:[-2,12],thickness:6,color:[1,1,1]},{a:[-10,0],b:[2,12],thickness:6,color:[1,1,1]}],color:n.isPressed("ArrowUp")?j:G}),e.push({center:[t[0]+90,t[1]],size:[40,40],lines:[{a:[-15,0],b:[8,0],thickness:6,color:[1,1,1]},{a:[0,10],b:[12,-2],thickness:6,color:[1,1,1]},{a:[0,-10],b:[12,2],thickness:6,color:[1,1,1]}],color:n.isPressed("ArrowRight")?j:G})})(r,[27,260]),((e,t,n)=>{l.isSupported(t)?e.push({center:[n[0]+115,n[1]],size:[230,60],text:"Touch Events\nSupported\n(double tap)",color:[0,.5,0]}):e.push({center:[n[0]+115,n[1]],size:[230,60],text:"Touch Events\nNot Supported",color:[.5,0,0]}),c.canBePointerLocked(t)?e.push({center:[n[0]+105,n[1]+70],size:[210,60],text:"Mouse\nSupported",color:[0,.5,0]}):e.push({center:[n[0]+105,n[1]+70],size:[210,60],text:"Mouse Events\nNot Supported",color:[.5,0,0]})})(r,e,[7,35]),r.forEach((e=>{const{center:n}=e;t.pushCenteredRectangle(L(n[0],n[1],-.3),e.size,[0,0,0]),t.pushCenteredRectangle(L(n[0],n[1],-.2),[e.size[0]-2,e.size[1]-2],e.color),e.text&&i.setTextScale(16).setTextAlign("centered","centered").pushText(e.text,n).setTextAlign("left","top"),e.lines&&e.lines.forEach((e=>{t.pushThickLine([n[0]+e.a[0],n[1]+e.a[1],0],[n[0]+e.b[0],n[1]+e.b[1],0],e.thickness,e.color)}))}))},$={X:0,Y:1,Z:2};class q{constructor(e){this._isActivated=!1,this._theta=0,this._phi=0,this._touchWasActive=!1,this._touchStartTime=0,this._touchMoveForward=!1,this._position=L(0,0,0),this._target=L(0,0,0),this._forwardAxis=L(1,0,0),this._leftAxis=L(0,0,1),this._upAxis=L(0,1,0),this._mouseSensibility=e.mouseSensibility,this._keyboardSensibility=e.keyboardSensibility,this._touchSensibility=e.touchSensibility,this._movingSpeed=e.movingSpeed,k(this._position,e.position),this._axisIndices=[e.coordinates?$[e.coordinates[0]]:$.X,e.coordinates?$[e.coordinates[1]]:$.Y,e.coordinates?$[e.coordinates[2]]:$.Z],this._theta=e.theta,this._phi=e.phi}isActivated(){return this._isActivated}update(e){let t=!1,i=!1,s=!1,o=!1,a=0,f=0;const d=Math.PI/180;a-=r.deltaX()*this._mouseSensibility*d,f-=r.deltaY()*this._mouseSensibility*d;const c=l.getTouchData().length>0;if(c){if(!this._touchWasActive){const e=Date.now();(e-this._touchStartTime)/1e3<.25?this._touchMoveForward=!0:this._touchStartTime=e}const e=l.getTouchData()[0];a-=e.deltaX*this._touchSensibility*d,f-=e.deltaY*this._touchSensibility*d}else this._touchMoveForward=!1;this._touchWasActive=c,this._touchMoveForward&&(t=!0);const h=this._movingSpeed*e,u=L(0,0,0);I(u,this._forwardAxis,h);const _=L(0,0,0);I(_,this._leftAxis,h),n.isPressed("Z","W")&&(t=!0),n.isPressed("S")&&(i=!0),n.isPressed("A","Q")&&(s=!0),n.isPressed("D")&&(o=!0);const p=this._keyboardSensibility*e;n.isPressed("ArrowUp")?f+=p:n.isPressed("ArrowDown")&&(f-=p),n.isPressed("ArrowLeft")?a+=p:n.isPressed("ArrowRight")&&(a-=p),this._theta+=a,this._phi+=f;const g=.5*Math.PI,m=.95*g;this._phi=Math.min(Math.max(this._phi,-m),+m);const x=Math.cos(this._theta),v=Math.sin(this._theta),[b,y,S]=this._axisIndices,T=Math.cos(this._phi+g);this._upAxis[b]=T*x,this._upAxis[y]=T*v,this._upAxis[S]=Math.sin(this._phi+g);const E=Math.cos(this._phi);this._forwardAxis[b]=E*x,this._forwardAxis[y]=E*v,this._forwardAxis[S]=Math.sin(this._phi),V(this._leftAxis,this._upAxis,this._forwardAxis),t?M(this._position,this._position,u):i&&O(this._position,this._position,u),s?M(this._position,this._position,_):o&&O(this._position,this._position,_),M(this._target,this._position,this._forwardAxis)}getPosition(){return this._position}setPosition(e){k(this._position,e)}getTarget(){return this._target}getForwardAxis(){return this._forwardAxis}getLeftAxis(){return this._leftAxis}getUpAxis(){return this._upAxis}getTheta(){return this._theta}getPhi(){return this._phi}getTouchMoveForward(){return this._touchMoveForward}}var K;!function(e){e[e.perspective=0]="perspective",e[e.orthogonal=1]="orthogonal"}(K||(K={}));class Z{constructor(){this._projectionType=K.perspective,this._viewportPos=W(0,0),this._viewportSize=W(0,0),this._projectionMatrix=T(),this._viewMatrix=T(),this._composedMatrix=T(),this._eye=L(0,0,0),this._target=L(0,0,0),this._upAxis=L(0,0,0)}setAsPerspective(e){this._projectionType=K.perspective;let t=e.aspectRatio;void 0===t&&(t=this._viewportSize[0]/this._viewportSize[1]),this._perspectiveData={fovy:e.fovy,aspectRatio:t,near:e.near,far:e.far}}setAsOrthogonal(e){this._projectionType=K.orthogonal,this._orthogonalData=Object.assign({},e)}setViewportPos(e,t){this._viewportPos[0]=e,this._viewportPos[1]=t}getViewportPos(){return this._viewportPos}setViewportSize(e,t){this._viewportSize[0]=e,this._viewportSize[1]=t,this._projectionType!==K.perspective&&this._perspectiveData&&(this._perspectiveData.aspectRatio=this._viewportSize[0]/this._viewportSize[1])}getViewportSize(){return this._viewportSize}lookAt(e,t,n){k(this._eye,e),k(this._target,t),k(this._upAxis,n)}setEye(e){k(this._eye,e)}setTarget(e){k(this._target,e)}setUpAxis(e){k(this._upAxis,e)}getEye(){return this._eye}getTarget(){return this._target}getUpAxis(){return this._upAxis}addOffset(e){M(this._eye,this._eye,e),M(this._target,this._target,e)}subOffset(e){P(this._eye,this._eye,e),P(this._target,this._target,e)}computeMatrices(){if(this._projectionType===K.perspective){const{fovy:e,aspectRatio:t,near:n,far:i}=this._perspectiveData;D(this._projectionMatrix,e,t,n,i)}else if(this._projectionType===K.orthogonal){const{left:e,right:t,top:n,bottom:i,near:r,far:s}=this._orthogonalData;R(this._projectionMatrix,e,t,n,i,r,s)}!function(e,t,n,i){var r,s,o,a,f,d,c,h,l,u,_=t[0],p=t[1],g=t[2],m=i[0],x=i[1],v=i[2],b=n[0],S=n[1],T=n[2];Math.abs(_-b)<y&&Math.abs(p-S)<y&&Math.abs(g-T)<y?w(e):(c=_-b,h=p-S,l=g-T,r=x*(l*=u=1/Math.hypot(c,h,l))-v*(h*=u),s=v*(c*=u)-m*l,o=m*h-x*c,(u=Math.hypot(r,s,o))?(r*=u=1/u,s*=u,o*=u):(r=0,s=0,o=0),a=h*o-l*s,f=l*r-c*o,d=c*s-h*r,(u=Math.hypot(a,f,d))?(a*=u=1/u,f*=u,d*=u):(a=0,f=0,d=0),e[0]=r,e[1]=a,e[2]=c,e[3]=0,e[4]=s,e[5]=f,e[6]=h,e[7]=0,e[8]=o,e[9]=d,e[10]=l,e[11]=0,e[12]=-(r*_+s*p+o*g),e[13]=-(a*_+f*p+d*g),e[14]=-(c*_+h*p+l*g),e[15]=1)}(this._viewMatrix,this._eye,this._target,this._upAxis),this.computeComposedMatrix()}computeComposedMatrix(){!function(e,t,n){var i=t[0],r=t[1],s=t[2],o=t[3],a=t[4],f=t[5],d=t[6],c=t[7],h=t[8],l=t[9],u=t[10],_=t[11],p=t[12],g=t[13],m=t[14],x=t[15],v=n[0],b=n[1],y=n[2],S=n[3];e[0]=v*i+b*a+y*h+S*p,e[1]=v*r+b*f+y*l+S*g,e[2]=v*s+b*d+y*u+S*m,e[3]=v*o+b*c+y*_+S*x,v=n[4],b=n[5],y=n[6],S=n[7],e[4]=v*i+b*a+y*h+S*p,e[5]=v*r+b*f+y*l+S*g,e[6]=v*s+b*d+y*u+S*m,e[7]=v*o+b*c+y*_+S*x,v=n[8],b=n[9],y=n[10],S=n[11],e[8]=v*i+b*a+y*h+S*p,e[9]=v*r+b*f+y*l+S*g,e[10]=v*s+b*d+y*u+S*m,e[11]=v*o+b*c+y*_+S*x,v=n[12],b=n[13],y=n[14],S=n[15],e[12]=v*i+b*a+y*h+S*p,e[13]=v*r+b*f+y*l+S*g,e[14]=v*s+b*d+y*u+S*m,e[15]=v*o+b*c+y*_+S*x}(this._composedMatrix,this._projectionMatrix,this._viewMatrix)}setProjectionMatrix(e){E(this._projectionMatrix,e)}setViewMatrix(e){E(this._viewMatrix,e)}setComposedMatrix(e){E(this._composedMatrix,e)}getProjectionMatrix(){return this._projectionMatrix}getViewMatrix(){return this._viewMatrix}getComposedMatrix(){return this._composedMatrix}getPerspectiveData(){if(this._projectionType!==K.perspective)throw new Error("not a perspective projection");return this._perspectiveData}getOrthogonalData(){if(this._projectionType!==K.orthogonal)throw new Error("not an orthogonal projection");return this._orthogonalData}}const Q="\n#version 300 es\n\nprecision highp float;\n\nuniform mat4 u_composedMatrix;\n\nin vec3 a_vertex_position;\nin vec4 a_vertex_color;\n\nflat out vec4 v_color;\n\nvoid main(void)\n{\n  gl_Position = u_composedMatrix * vec4(a_vertex_position, 1.0);\n\n  v_color = a_vertex_color;\n}\n".trim(),J="\n#version 300 es\n\nprecision lowp float;\n\nflat in vec4 v_color;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  o_color = v_color;\n}\n\n".trim();class ee{constructor(e,t){this._buffer=new Float32Array(14336),this._currentSize=0,this._shader=e;const n=Object.assign(Object.assign({},t),{primitiveType:g.PrimitiveType.lines});this._geometry=new g.Geometry(e,n),this._geometry.setFloatBufferSize(0,14336)}pushLine(e,t,n){var i;if(this._currentSize+14>=this._buffer.length){if(!this._shader.isBound())return;this.flush()}const r=null!==(i=n[3])&&void 0!==i?i:1;this._buffer[this._currentSize+0]=e[0],this._buffer[this._currentSize+1]=e[1],this._buffer[this._currentSize+2]=e[2],this._buffer[this._currentSize+3]=n[0],this._buffer[this._currentSize+4]=n[1],this._buffer[this._currentSize+5]=n[2],this._buffer[this._currentSize+6]=r,this._currentSize+=7,this._buffer[this._currentSize+0]=t[0],this._buffer[this._currentSize+1]=t[1],this._buffer[this._currentSize+2]=t[2],this._buffer[this._currentSize+3]=n[0],this._buffer[this._currentSize+4]=n[1],this._buffer[this._currentSize+5]=n[2],this._buffer[this._currentSize+6]=r,this._currentSize+=7}canRender(){return this._currentSize>0}flush(){this.canRender()&&(this._geometry.updateBuffer(0,this._buffer,this._currentSize),this._geometry.setPrimitiveCount(this._currentSize/7),this._geometry.render(),this.clear())}clear(){this._currentSize=0}}class te{constructor(e,t){this._buffer=new Float32Array(7168),this._currentSize=0,this._shader=e;const n=Object.assign(Object.assign({},t),{primitiveType:g.PrimitiveType.triangles});this._geometry=new g.Geometry(e,n),this._geometry.setFloatBufferSize(0,7168)}pushTriangle(e,t,n,i){var r;if(this._currentSize+42>=this._buffer.length){if(!this._shader.isBound())return;this.flush()}const s=null!==(r=i[3])&&void 0!==r?r:1;this._buffer[this._currentSize+0]=e[0],this._buffer[this._currentSize+1]=e[1],this._buffer[this._currentSize+2]=e[2],this._buffer[this._currentSize+3]=i[0],this._buffer[this._currentSize+4]=i[1],this._buffer[this._currentSize+5]=i[2],this._buffer[this._currentSize+6]=s,this._currentSize+=7,this._buffer[this._currentSize+0]=t[0],this._buffer[this._currentSize+1]=t[1],this._buffer[this._currentSize+2]=t[2],this._buffer[this._currentSize+3]=i[0],this._buffer[this._currentSize+4]=i[1],this._buffer[this._currentSize+5]=i[2],this._buffer[this._currentSize+6]=s,this._currentSize+=7,this._buffer[this._currentSize+0]=n[0],this._buffer[this._currentSize+1]=n[1],this._buffer[this._currentSize+2]=n[2],this._buffer[this._currentSize+3]=i[0],this._buffer[this._currentSize+4]=i[1],this._buffer[this._currentSize+5]=i[2],this._buffer[this._currentSize+6]=s,this._currentSize+=7}pushLine(e,t,n,i){if(this._currentSize+42>=this._buffer.length)return;const r=t[0]-e[0],s=t[1]-e[1],o=Math.atan2(s,r)+.5*Math.PI,a=Math.cos(o)*n*.5,f=Math.sin(o)*n*.5;this.pushTriangle([e[0]-a,e[1]-f,e[2]],[t[0]-a,t[1]-f,t[2]],[t[0]+a,t[1]+f,t[2]],i),this.pushTriangle([e[0]-a,e[1]-f,e[2]],[t[0]+a,t[1]+f,t[2]],[e[0]+a,e[1]+f,e[2]],i)}pushRotatedLine(e,t,n,i,r){this.pushLine([e[0]-n*Math.cos(t),e[1]-n*Math.sin(t),e[2]],[e[0]+n*Math.cos(t),e[1]+n*Math.sin(t),e[2]],i,r)}pushOriginBoundRectangle(e,t,n){if(this._currentSize+42>=this._buffer.length)return;const i=[e[0]+t[0],e[1]+t[1]];this.pushTriangle([e[0],e[1],e[2]],[i[0],i[1],e[2]],[e[0],i[1],e[2]],n),this.pushTriangle([e[0],e[1],e[2]],[i[0],e[1],e[2]],[i[0],i[1],e[2]],n)}pushCenteredRectangle(e,t,n){const i=[e[0]-.5*t[0],e[1]-.5*t[1],e[2]];this.pushOriginBoundRectangle(i,t,n)}canRender(){return this._currentSize>0}flush(){this.canRender()&&(this._geometry.updateBuffer(0,this._buffer,this._currentSize),this._geometry.setPrimitiveCount(this._currentSize/7),this._geometry.render(),this.clear())}clear(){this._currentSize=0}}class ne{constructor(){this._shader=new m("StackRenderers",{vertexSrc:Q,fragmentSrc:J,attributes:["a_vertex_position","a_vertex_color"],uniforms:["u_composedMatrix"]});const e=new g.GeometryBuilder;e.reset().setPrimitiveType("lines").addVbo().setVboAsDynamic().addVboAttribute("a_vertex_position","vec3f").addVboAttribute("a_vertex_color","vec4f"),this._wireFramesStackRenderer=new ee(this._shader,e.getDef()),this._trianglesStackRenderer=new te(this._shader,e.getDef())}pushLine(e,t,n){this._wireFramesStackRenderer.pushLine(e,t,n)}pushCross(e,t,n){const i=[[e[0]-t,e[1],e[2]],[e[0]+t,e[1],e[2]],[e[0],e[1]-t,e[2]],[e[0],e[1]+t,e[2]],[e[0],e[1],e[2]-t],[e[0],e[1],e[2]+t]],r=[0,1,2,3,4,5];for(let e=0;e<r.length;e+=2){const t=i[e+0],r=i[e+1];this._wireFramesStackRenderer.pushLine(t,r,n)}}pushThickLine(e,t,n,i){this._trianglesStackRenderer.pushLine(e,t,n,i)}pushRotatedLine(e,t,n,i,r){this._trianglesStackRenderer.pushRotatedLine(e,t,n,i,r)}pushOriginBoundRectangle(e,t,n){this._trianglesStackRenderer.pushOriginBoundRectangle(e,t,n)}pushCenteredRectangle(e,t,n){this._trianglesStackRenderer.pushCenteredRectangle(e,t,n)}pushTriangle(e,t,n,i){this._trianglesStackRenderer.pushTriangle(e,t,n,i)}flush(e){(this._wireFramesStackRenderer.canRender()||this._trianglesStackRenderer.canRender())&&this._shader.bind((()=>{this._shader.setMatrix4Uniform("u_composedMatrix",e),this._wireFramesStackRenderer.flush(),this._trianglesStackRenderer.flush()}))}safeRender(e,t){this._shader.bind((()=>{this._shader.setMatrix4Uniform("u_composedMatrix",e),t(),this._wireFramesStackRenderer.flush(),this._trianglesStackRenderer.flush()}))}clear(){this._wireFramesStackRenderer.clear(),this._trianglesStackRenderer.clear()}}const ie="\n\n#version 300 es\n\nprecision highp float;\n\nin vec2 a_vertexPosition;\nin vec3 a_plotPosition;\n\nout vec3 v_position;\n\nvoid main(void)\n{\n  gl_Position = vec4(a_vertexPosition, 1.0, 1.0);\n\n  v_position = a_plotPosition;\n}\n\n".trim(),re='\n\n#version 300 es\n\nprecision highp float;\n\n//\n//\n//\n\nuniform vec3        u_cameraEye;\n\n//\n\nuniform sampler2D   u_sceneTextureData;\nuniform int         u_sceneTextureSize;\n\nuniform int       u_spheresStart;\nuniform int       u_spheresStop;\n\nuniform int       u_boxesStart;\nuniform int       u_boxesStop;\n\nuniform int       u_trianglesStart;\nuniform int       u_trianglesStop;\n\n//\n\nuniform sampler2D   u_lightsTextureData;\n\nuniform int       u_sunLightsStart;\nuniform int       u_sunLightsStop;\n\nuniform int       u_spotLightsStart;\nuniform int       u_spotLightsStop;\n\n//\n//\n//\n\nin vec3  v_position;\n\nout vec4 o_color;\n\n//\n\nconst float     g_ambiantLight = 0.2;\n\nconst int       g_reflectionMax = 2;\nconst bool      g_shadowsEnabled = true;\n\nconst vec3      g_backgroundColor = vec3(0.4);\n\n//\n\nstruct RayValues\n{\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct RayResult\n{\n  bool hasHit;\n  float depth;\n  vec3 position;\n  vec3 normal;\n  vec4 color;\n  float reflection;\n  bool lightEnabled;\n};\n\n//\n//\n//\n//\n//\n\nfloat getSceneDataByIndex(int index)\n{\n  return texelFetch(u_sceneTextureData, ivec2(index, 0), 0).x;\n}\n\nvec3 getSceneVec3ByIndex(int index)\n{\n  return vec3(\n    texelFetch(u_sceneTextureData, ivec2(index + 0, 0), 0).x,\n    texelFetch(u_sceneTextureData, ivec2(index + 1, 0), 0).x,\n    texelFetch(u_sceneTextureData, ivec2(index + 2, 0), 0).x\n  );\n}\n\nfloat getLightsDataByIndex(int index)\n{\n  return texelFetch(u_lightsTextureData, ivec2(index, 0), 0).x;\n}\n\nvec3 getLightsVec3ByIndex(int index)\n{\n  return vec3(\n    texelFetch(u_lightsTextureData, ivec2(index + 0, 0), 0).x,\n    texelFetch(u_lightsTextureData, ivec2(index + 1, 0), 0).x,\n    texelFetch(u_lightsTextureData, ivec2(index + 2, 0), 0).x\n  );\n}\n\n//\n//\n//\n//\n//\n\nbool intersectSphere(RayValues ray, float radius, out float distance, out vec3 normal)\n{\n  float nearValue = 0.001; // TODO: hardcoded\n  float farValue = 100.0; // TODO: hardcoded\n\n  float b = dot(ray.origin, ray.direction);\n  float c = dot(ray.origin, ray.origin) - radius * radius;\n  float h = b * b - c;\n  if (h < 0.0)\n    return false;\n\n  h = sqrt(h);\n\n  float d1 = -b - h;\n  if (d1 >= nearValue && d1 <= farValue)\n  {\n    normal = normalize(ray.origin + ray.direction * d1);\n    distance = d1;\n    return true;\n  }\n\n  float d2 = -b + h;\n  if (d2 >= nearValue && d2 <= farValue)\n  {\n    normal = normalize(ray.origin + ray.direction * d2);\n    distance = d2;\n    return true;\n  }\n\n  return false;\n}\n\nbool intersectBox(RayValues ray, vec3 boxSize, out float distance, out vec3 normal)\n{\n  float nearValue = 0.001; // TODO: hardcoded\n  float farValue = 100.0; // TODO: hardcoded\n\n  //\n  //\n  // sad hack: fix a shadow related bug\n\n  if (ray.direction.x == 0.0) ray.direction.x = -1e-8;\n  if (ray.direction.y == 0.0) ray.direction.y = -1e-8;\n  if (ray.direction.z == 0.0) ray.direction.z = -1e-8;\n\n  // sad hack: fix a shadow related bug\n  //\n  //\n\n  vec3 m = sign(ray.direction) / max(abs(ray.direction), 1e-8);\n  vec3 n = m * ray.origin;\n  vec3 k = abs(m) * boxSize;\n\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n\n  float tN = max(max(t1.x, t1.y), t1.z);\n  float tF = min(min(t2.x, t2.y), t2.z);\n\n  if (tN > tF || tF <= 0.0)\n    return false;\n\n  if (tN >= nearValue && tN <= farValue)\n  {\n    normal = normalize(-sign(ray.direction) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz));\n    distance = tN;\n    return true;\n  }\n\n  if (tF >= nearValue && tF <= farValue)\n  {\n    normal = normalize(-sign(ray.direction) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz));\n    distance = tF;\n    return true;\n  }\n\n  return false;\n}\n\nbool intersectTriangle(RayValues ray, vec3 v0, vec3 v1, vec3 v2, out float distance, out vec3 normal)\n{\n  float nearValue = 0.001; // TODO: hardcoded\n  float farValue = 100.0; // TODO: hardcoded\n\n  vec3 v1v0 = v1 - v0;\n  vec3 v2v0 = v2 - v0;\n  vec3 rov0 = ray.origin - v0;\n\n  vec3 n = cross(v1v0, v2v0);\n  vec3 q = cross(rov0, ray.direction);\n  float d = 1.0 / dot(ray.direction, n);\n  float u = d * dot(-q, v2v0);\n  float v = d * dot(q, v1v0);\n  float t = d * dot(-n, rov0);\n\n  if (u < 0.0 || v < 0.0 || (u + v) > 1.0 || t < nearValue || t > farValue)\n    return false;\n\n  normal = normalize(-n);\n  distance = t;\n  return true;\n}\n\n// float intersectPlane(RayValues ray, vec3 normal, float offset)\n// {\n//     return -(dot(ray.origin, normal) + offset) / dot(ray.direction, normal);\n// }\n\n// float intersectPlane2(RayValues ray, vec3 normal, float offset)\n// {\n//     float nearValue = 0.001; // TODO: hardcoded\n//     float farValue = 1000.0; // TODO: hardcoded\n\n//     float a = dot(ray.direction, normal);\n//     float d = -(dot(ray.origin, normal) + offset) / a;\n\n//     if (a > 0.0 || d < nearValue || d > farValue)\n//         return -1.0;\n\n//     return d;\n// }\n\n// float diskIntersect(RayValues ray, vec3 center, vec3 normal, float radius)\n// {\n//     vec3  o = ray.origin - center;\n//     float t = -dot(normal, o) / dot(ray.direction, normal);\n//     vec3  q = o + ray.direction * t;\n//     return (dot(q, q) < radius * radius) ? t : -1.0;\n// }\n\n//\n//\n//\n//\n//\n\nbool intersectScene(RayValues ray, out RayResult result, bool shadowMode)\n{\n  float bestDistance = -1.0;\n\n  result.hasHit = false;\n\n  if (u_sceneTextureSize <= 0)\n    return false;\n\n  RayValues tmpRay;\n  vec3 normal;\n\n  for (int index = u_spheresStart; index < u_spheresStop; index += 11)\n  {\n    bool shadowEnabled = (getSceneDataByIndex(index + 8) != 0.0);\n\n    if (shadowMode && !shadowEnabled)\n      continue;\n\n    tmpRay.origin = ray.origin;\n    tmpRay.direction = ray.direction;\n\n    vec3 center = getSceneVec3ByIndex(index + 0);\n\n    tmpRay.origin -= center;\n\n    float radius = getSceneDataByIndex(index + 3);\n\n    float currDistance = 0.0;\n    if (!intersectSphere(tmpRay, radius, currDistance, normal) || (bestDistance > 0.0 && currDistance > bestDistance))\n      continue;\n\n    bestDistance = currDistance;\n\n    result.hasHit = true;\n    result.depth = bestDistance;\n    result.position = ray.origin + bestDistance * ray.direction;\n    result.normal = normal;\n\n    bool chessboardMaterial = (getSceneDataByIndex(index + 10) != 0.0);\n\n    if (chessboardMaterial)\n    {\n      // vec3 txPos = (txx * vec4(result.position - center, 1.0)).xyz;\n      vec3 txPos = (vec4(result.position - center, 1.0)).xyz;\n      // chessboard color effect\n      if (fract(txPos.x * 0.2) > 0.5 == fract(txPos.z * 0.2) > 0.5 == fract(txPos.y * 0.2) > 0.5)\n      {\n        result.color = vec4(1.0);\n        result.reflection = 0.3;\n      }\n      else\n      {\n        result.color = vec4(0.0, 0.4, 0.45, 1.0);\n        result.reflection = 0.0;\n      }\n    }\n    else\n    {\n      vec3 color = getSceneVec3ByIndex(index + 4);\n\n      float reflection = getSceneDataByIndex(index + 7);\n\n      result.color = vec4(color, 0.5);\n      result.reflection = reflection;\n    }\n\n    bool lightEnabled = (getSceneDataByIndex(index + 9) != 0.0);\n    result.lightEnabled = lightEnabled;\n\n    // if (shadowMode)\n    //     return true;\n  }\n\n  for (int index = u_boxesStart; index < u_boxesStop; index += 26)\n  {\n    bool shadowEnabled = (getSceneDataByIndex(index + 23) != 0.0);\n\n    if (shadowMode && !shadowEnabled)\n      continue;\n\n    tmpRay.origin = ray.origin;\n    tmpRay.direction = ray.direction;\n\n    mat4 normalTransformationMatrix = mat4(\n      getSceneDataByIndex(index + 0),\n      getSceneDataByIndex(index + 1),\n      getSceneDataByIndex(index + 2),\n      getSceneDataByIndex(index + 3),\n\n      getSceneDataByIndex(index + 4),\n      getSceneDataByIndex(index + 5),\n      getSceneDataByIndex(index + 6),\n      getSceneDataByIndex(index + 7),\n\n      getSceneDataByIndex(index + 8),\n      getSceneDataByIndex(index + 9),\n      getSceneDataByIndex(index + 10),\n      getSceneDataByIndex(index + 11),\n\n      getSceneDataByIndex(index + 12),\n      getSceneDataByIndex(index + 13),\n      getSceneDataByIndex(index + 14),\n      getSceneDataByIndex(index + 15)\n    );\n\n    vec3 boxSize = getSceneVec3ByIndex(index + 16);\n\n    mat4 inversedTransformationMatrix = inverse(normalTransformationMatrix);\n\n    // convert ray from world space to box space\n    tmpRay.origin = (inversedTransformationMatrix * vec4(tmpRay.origin, 1.0)).xyz;\n    tmpRay.direction = (inversedTransformationMatrix * vec4(tmpRay.direction, 0.0)).xyz;\n\n    float currDistance = 0.0;\n    if (!intersectBox(tmpRay, boxSize, currDistance, normal) || (bestDistance > 0.0 && currDistance > bestDistance))\n      continue;\n\n    bestDistance = currDistance;\n\n    // convert normal from box space to world space\n    normal = (normalTransformationMatrix * vec4(normal, 0.0)).xyz;\n\n    result.hasHit = true;\n    result.depth = bestDistance;\n    result.position = ray.origin + bestDistance * ray.direction;\n    result.normal = normal;\n\n    bool chessboardMaterial = (getSceneDataByIndex(index + 25) != 0.0);\n\n    if (chessboardMaterial)\n    {\n      vec3 txPos = (inversedTransformationMatrix * vec4(result.position, 1.0)).xyz;\n\n      // chessboard color effect\n      if (fract(txPos.x * 0.2) > 0.5 == fract(txPos.z * 0.2) > 0.5 == fract(txPos.y * 0.2) > 0.5)\n      {\n        result.color = vec4(1.0);\n        result.reflection = 0.3;\n      }\n      else\n      {\n        result.color = vec4(0.0, 0.4, 0.45, 1.0);\n        result.reflection = 0.0;\n      }\n    }\n    else\n    {\n      vec3 color = getSceneVec3ByIndex(index + 19);\n\n      float reflection = getSceneDataByIndex(index + 22);\n\n      result.color = vec4(color, 1.0);\n      result.reflection = reflection;\n    }\n\n    bool lightEnabled = (getSceneDataByIndex(index + 24) != 0.0);\n    result.lightEnabled = lightEnabled;\n\n    // if (shadowMode)\n    //     return true;\n  }\n\n  for (int index = u_trianglesStart; index < u_trianglesStop; index += 15)\n  {\n    bool shadowEnabled = (getSceneDataByIndex(index + 13) != 0.0);\n\n    if (shadowMode && !shadowEnabled)\n      continue;\n\n    tmpRay.origin = ray.origin;\n    tmpRay.direction = ray.direction;\n\n    vec3 v0 = getSceneVec3ByIndex(index + 0);\n    vec3 v1 = getSceneVec3ByIndex(index + 3);\n    vec3 v2 = getSceneVec3ByIndex(index + 6);\n\n    float currDistance = 0.0;\n    if (!intersectTriangle(tmpRay, v0, v1, v2, currDistance, normal) || (bestDistance > 0.0 && currDistance > bestDistance))\n      continue;\n\n    bestDistance = currDistance;\n\n    result.hasHit = true;\n    result.depth = bestDistance;\n    result.position = ray.origin + bestDistance * ray.direction;\n    result.normal = normal;\n\n    vec3 color = getSceneVec3ByIndex(index + 9);\n\n    float reflection = getSceneDataByIndex(index + 12);\n\n    result.color = vec4(color, 1.0);\n    result.reflection = reflection;\n\n    bool lightEnabled = (getSceneDataByIndex(index + 14) != 0.0);\n    result.lightEnabled = lightEnabled;\n\n    // if (shadowMode)\n    //     return true;\n  }\n\n  { // plane test\n\n    // vec3 planeNormal = normalize(vec3(0.0, 0.0, 1.0));\n    // float val = intersectPlane(tmpRay, planeNormal, 35.0/4.0*3.0);\n\n    // vec3 planeNormal = normalize(vec3(0.0, 0.0, 1.0));\n    // float val = intersectPlane(tmpRay, planeNormal, 0.0);\n\n    // vec3 planeNormal = normalize(vec3(0.0, 0.0, 1.0));\n    // float val = intersectPlane(tmpRay, planeNormal, 10.0);\n\n    // if (val > 0.0 && (bestDistance <= 0.0 || val < bestDistance))\n    // {\n    //     result.hasHit = true;\n    //     result.depth = val;\n    //     result.position = ray.origin + val * ray.direction;\n    //     result.normal = vec3(planeNormal);\n    //     result.color = vec4(1.0, 1.0, 1.0, 1.0);\n    //     result.reflection = 0.0;\n    //     result.lightEnabled = true;\n    // }\n\n  } // plane test\n\n  return result.hasHit;\n}\n\nfloat lightAt(vec3 impactPosition, vec3 impactNormal, vec3 viewer)\n{\n  float bestIntensity = 0.0;\n\n  for (int index = u_sunLightsStart; index < u_sunLightsStop; index += 4)\n  {\n    if (!g_shadowsEnabled)\n      continue;\n\n    vec3 lightDir = getLightsVec3ByIndex(index + 0);\n    float localIntensity = getLightsDataByIndex(index + 3);\n\n    float coef = localIntensity;\n    lightDir = normalize(lightDir);\n\n    // is the light blocked by an object?\n    RayResult result;\n    if (intersectScene(RayValues(impactPosition, lightDir), result, true))\n      continue; // an object is shadowing this light: ignore this light\n\n    //\n    //\n    //\n\n    float intensity = 0.0;\n    vec3 reflection = reflect(-lightDir, impactNormal);\n    intensity += 0.6 * pow(max(dot(reflection, viewer), 0.0), 30.0);\n    intensity += 1.0 * dot(lightDir, impactNormal);\n\n    intensity *= coef;\n\n    if (bestIntensity < intensity)\n      bestIntensity = intensity;\n  }\n\n  for (int index = u_spotLightsStart; index < u_spotLightsStop; index += 5)\n  {\n    vec3 lightDir = vec3(1.0);\n    float coef = 1.0;\n\n    // spot light\n\n    vec3 lightPos = getLightsVec3ByIndex(index + 0);\n    float lightRadius = getLightsDataByIndex(index + 3);\n\n    vec3 lightToImpactVec3 = lightPos - impactPosition;\n\n    // is too far?\n    float lightToImpactDistance = length(lightToImpactVec3);\n    if (lightToImpactDistance > lightRadius)\n      continue; // too far\n\n    lightDir.x = lightToImpactVec3.x / lightToImpactDistance; // normalize\n    lightDir.y = lightToImpactVec3.y / lightToImpactDistance; // normalize\n    lightDir.z = lightToImpactVec3.z / lightToImpactDistance; // normalize\n\n    float localIntensity = getLightsDataByIndex(index + 4);\n\n    coef = localIntensity * (1.0 - lightToImpactDistance / lightRadius);\n\n    if (!g_shadowsEnabled)\n      continue;\n\n    // is the light blocked by an object?\n    RayResult result;\n    if (intersectScene(RayValues(impactPosition, lightDir), result, true))\n    {\n      // avoid "opposite shadows"\n      if (result.depth < lightToImpactDistance)\n        continue; // shadow\n    }\n\n    //\n    //\n    //\n\n    float intensity = 0.0;\n    vec3 reflection = reflect(-lightDir, impactNormal);\n    intensity += 0.6 * pow(max(dot(reflection, viewer), 0.0), 30.0);\n    intensity += 1.0 * dot(lightDir, impactNormal);\n\n    intensity *= coef;\n\n    if (bestIntensity < intensity)\n      bestIntensity = intensity;\n  }\n\n  return max(g_ambiantLight, bestIntensity);\n}\n\nvoid main()\n{\n  //\n  //\n  // initial ray\n\n  vec3 rayDir = normalize(v_position - u_cameraEye); // camera direction\n  vec3 finalPixelColor = g_backgroundColor;\n\n  RayValues currRay = RayValues(u_cameraEye, rayDir);\n  RayResult result;\n\n  result.position = u_cameraEye;\n  result.reflection = 1.0;\n  result.lightEnabled = true;\n\n  float lastReflection = 1.0;\n\n  const int maxIteration = g_reflectionMax;\n  for (int iterationLeft = maxIteration; iterationLeft >= 0; --iterationLeft)\n  {\n    if (result.reflection <= 0.05)\n      break;\n\n    bool mustStop = false;\n\n    currRay = RayValues(result.position, rayDir);\n\n    result.hasHit = intersectScene(currRay, result, false);\n\n    vec3 tmpColor = g_backgroundColor;\n\n    if (result.hasHit)\n    {\n      float lightIntensity = 1.0;\n\n      if (result.lightEnabled)\n      {\n        lightIntensity = lightAt(result.position, result.normal, -currRay.direction);\n\n        if (lightIntensity <= 0.0)\n        {\n          // not lighted\n          mustStop = true;\n        }\n      }\n\n      tmpColor = result.color.xyz * lightIntensity;\n    }\n\n    finalPixelColor = finalPixelColor * (1.0 - lastReflection) + tmpColor * lastReflection;\n\n    if (mustStop || !result.hasHit)\n    {\n      break;\n    }\n\n    lastReflection *= result.reflection;\n\n    rayDir = reflect(rayDir, result.normal);\n  }\n\n  o_color = vec4(finalPixelColor, 1.0);\n}\n\n'.trim(),se="\n\n#version 300 es\n\nprecision highp float;\n\nin vec2 a_vertexPosition;\nin vec2 a_vertexTextureCoord;\n\nout vec2 v_textureCoord;\n\nvoid main(void)\n{\n  v_textureCoord = a_vertexTextureCoord;\n\n  gl_Position = vec4(a_vertexPosition, 1.0, 1.0);\n}\n\n".trim(),oe="\n\n#version 300 es\n\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec2 u_step;\n\nin vec2 v_textureCoord;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  // gl_FragColor = texture(u_texture, v_textureCoord);\n\n  float total = 0.0;\n  vec4 accumulated = vec4(0.0);\n\n  //\n\n  if (v_textureCoord.x - u_step.x > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x - u_step.x, v_textureCoord.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.x + u_step.x > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x + u_step.x, v_textureCoord.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.y - u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x, v_textureCoord.y - u_step.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.y + u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x, v_textureCoord.y + u_step.y));\n    total += 1.0;\n  }\n\n  //\n\n  if (v_textureCoord.x - u_step.x > 0.0 && v_textureCoord.y - u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x - u_step.x, v_textureCoord.y - u_step.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.x + u_step.x > 0.0 && v_textureCoord.y - u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x + u_step.x, v_textureCoord.y - u_step.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.x - u_step.x > 0.0 && v_textureCoord.y + u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x - u_step.x, v_textureCoord.y + u_step.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.x + u_step.x > 0.0 && v_textureCoord.y + u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x + u_step.x, v_textureCoord.y + u_step.y));\n    total += 1.0;\n  }\n\n  //\n\n  if (total > 0.0)\n    o_color = accumulated / total;\n  else\n    o_color = vec4(1.0, 0.0, 0.0, 1.0); // warning\n}\n\n".trim(),ae=e=>e*Math.PI/180;class fe{constructor(e){this._resolutionCoef=1,this._antiAliasing=!1,this._spheres=[],this._boxes=[],this._triangles=[],this._sunLights=[],this._spotLights=[],this._cameraFovy=e.fovy,this._renderWidth=this._canvasWidth=e.canvasWidth,this._renderHeight=this._canvasHeight=e.canvasHeight,this._rayTracerShaderProgram=new m("RayTracerRenderer-1",{vertexSrc:ie,fragmentSrc:re,attributes:["a_vertexPosition","a_plotPosition"],uniforms:["u_cameraEye","u_sceneTextureData","u_sceneTextureSize","u_spheresStart","u_spheresStop","u_boxesStart","u_boxesStop","u_trianglesStart","u_trianglesStop","u_lightsTextureData","u_sunLightsStart","u_sunLightsStop","u_spotLightsStart","u_spotLightsStop"]}),this._textureShaderProgram=new m("RayTracerRenderer-1",{vertexSrc:se,fragmentSrc:oe,attributes:["a_vertexPosition","a_vertexTextureCoord"],uniforms:["u_texture","u_step"]}),this._finalTexture=new x,this._finalTexture.allocate(this._renderWidth,this._renderHeight),this._frameBuffer=new p,this._frameBuffer.attachTexture(this._finalTexture);const t=new g.GeometryBuilder;t.reset().setPrimitiveType("triangleStrip").addVbo().addVboAttribute("a_vertexPosition","vec2f").addVbo().setVboAsDynamic().addVboAttribute("a_plotPosition","vec3f"),this._rayTracerGeometry=new g.Geometry(this._rayTracerShaderProgram,t.getDef());const n=[];n.push(1,1),n.push(-1,1),n.push(1,-1),n.push(-1,-1),this._rayTracerGeometry.updateBuffer(0,n,n.length),this._rayTracerGeometry.setPrimitiveStart(0),this._rayTracerGeometry.setPrimitiveCount(4),t.reset().setPrimitiveType("triangleStrip").addVbo().addVboAttribute("a_vertexPosition","vec2f").addVboAttribute("a_vertexTextureCoord","vec2f"),this._screenGeometry=new g.Geometry(this._textureShaderProgram,t.getDef());const i=[];i.push(1,1,1,1),i.push(-1,1,0,1),i.push(1,-1,1,0),i.push(-1,-1,0,0),this._screenGeometry.updateBuffer(0,i,i.length),this._screenGeometry.setPrimitiveStart(0),this._screenGeometry.setPrimitiveCount(4),this._sceneDataTexture=new _,this._sceneDataTexture.initialize(),this._lightsDataTexture=new _,this._lightsDataTexture.initialize(),this._camera={position:L(0,0,0),target:L(1.5,1.5,1.5),up:L(0,1,0)}}pushSphere(e,t,n,i,r,s=!0,o=!0){if(t<=0)throw new Error("invalid sphere radius");if(i<0||i>1)throw new Error("invalid sphere reflection");this._spheres.push({position:[e[0],e[1],e[2]],radius:t,color:[n[0],n[1],n[2]],reflection:i,chessboard:r,shadowEnabled:s,lightEnabled:o})}pushBox(e,t,n,i,r,s,o,a,f=!0,d=!0){if(r[0]<=0||r[1]<=0||r[2]<=0)throw new Error("invalid box size");if(o<0||o>1)throw new Error("invalid box reflection");const c=T();w(c),function(e,t,n){var i,r,s,o,a,f,d,c,h,l,u,_,p=n[0],g=n[1],m=n[2];t===e?(e[12]=t[0]*p+t[4]*g+t[8]*m+t[12],e[13]=t[1]*p+t[5]*g+t[9]*m+t[13],e[14]=t[2]*p+t[6]*g+t[10]*m+t[14],e[15]=t[3]*p+t[7]*g+t[11]*m+t[15]):(i=t[0],r=t[1],s=t[2],o=t[3],a=t[4],f=t[5],d=t[6],c=t[7],h=t[8],l=t[9],u=t[10],_=t[11],e[0]=i,e[1]=r,e[2]=s,e[3]=o,e[4]=a,e[5]=f,e[6]=d,e[7]=c,e[8]=h,e[9]=l,e[10]=u,e[11]=_,e[12]=i*p+a*g+h*m+t[12],e[13]=r*p+f*g+l*m+t[13],e[14]=s*p+d*g+u*m+t[14],e[15]=o*p+c*g+_*m+t[15])}(c,c,e),function(e,t,n){var i=Math.sin(n),r=Math.cos(n),s=t[0],o=t[1],a=t[2],f=t[3],d=t[8],c=t[9],h=t[10],l=t[11];t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*r-d*i,e[1]=o*r-c*i,e[2]=a*r-h*i,e[3]=f*r-l*i,e[8]=s*i+d*r,e[9]=o*i+c*r,e[10]=a*i+h*r,e[11]=f*i+l*r}(c,c,n),function(e,t,n){var i=Math.sin(n),r=Math.cos(n),s=t[0],o=t[1],a=t[2],f=t[3],d=t[4],c=t[5],h=t[6],l=t[7];t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*r+d*i,e[1]=o*r+c*i,e[2]=a*r+h*i,e[3]=f*r+l*i,e[4]=d*r-s*i,e[5]=c*r-o*i,e[6]=h*r-a*i,e[7]=l*r-f*i}(c,c,i),function(e,t,n){var i=Math.sin(n),r=Math.cos(n),s=t[4],o=t[5],a=t[6],f=t[7],d=t[8],c=t[9],h=t[10],l=t[11];t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*r+d*i,e[5]=o*r+c*i,e[6]=a*r+h*i,e[7]=f*r+l*i,e[8]=d*r-s*i,e[9]=c*r-o*i,e[10]=h*r-a*i,e[11]=l*r-f*i}(c,c,t),this._boxes.push({matrix:c,boxSize:z(r),color:z(s),reflection:o,chessboard:a,shadowEnabled:f,lightEnabled:d})}pushTriangle({v0:e,v1:t,v2:n,color:i,reflection:r,shadowEnabled:s,lightEnabled:o}){if(r<0||r>1)throw new Error("invalid triangle reflection");this._triangles.push({v0:z(e),v1:z(t),v2:z(n),color:z(i),reflection:r,shadowEnabled:s,lightEnabled:o})}pushSunLight(e,t){if(t<=0)throw new Error("intensity cannot be 0");if(0===A(e))throw new Error("direction cannot be 0");const n=U(z(e),e);this._sunLights.push({direction:n,intensity:t})}pushSpotLight(e,t,n){if(t<=0)throw new Error("intensity cannot be 0");if(n<=0)throw new Error("radius cannot be <= 0");this._spotLights.push({position:z(e),intensity:t,radius:n})}lookAt(e,t,n){k(this._camera.position,e);let i=O(C(),t,e);i=U(i,i),i=M(i,e,i),k(this._camera.target,i);const r=U(C(),n);k(this._camera.up,r)}render(){const e=u.getContext(),t=this._computeCameraFarCorners();this._rayTracerGeometry.updateBuffer(1,t,t.length);const n=Math.floor(this._renderWidth),i=Math.floor(this._renderHeight);this._frameBuffer.bind(),e.viewport(0,0,n,i),e.clear(e.COLOR_BUFFER_BIT);{const t=this._rayTracerShaderProgram;t.bind((()=>{t.setFloat3Uniform("u_cameraEye",this._camera.position[0],this._camera.position[1],this._camera.position[2]);{const n=[];t.setInteger1Uniform("u_spheresStart",0);for(const e of this._spheres)n.push(e.position[0],e.position[1],e.position[2]),n.push(e.radius),n.push(e.color[0],e.color[1],e.color[2]),n.push(e.reflection),n.push(e.shadowEnabled?1:0),n.push(e.lightEnabled?1:0),n.push(e.chessboard?1:0);t.setInteger1Uniform("u_spheresStop",n.length),t.setInteger1Uniform("u_boxesStart",n.length);for(const e of this._boxes){for(let t=0;t<16;++t)n.push(e.matrix[t]);n.push(e.boxSize[0],e.boxSize[1],e.boxSize[2]),n.push(e.color[0],e.color[1],e.color[2]),n.push(e.reflection),n.push(e.shadowEnabled?1:0),n.push(e.lightEnabled?1:0),n.push(e.chessboard?1:0)}t.setInteger1Uniform("u_boxesStop",n.length),t.setInteger1Uniform("u_trianglesStart",n.length);for(const e of this._triangles)n.push(e.v0[0],e.v0[1],e.v0[2]),n.push(e.v1[0],e.v1[1],e.v1[2]),n.push(e.v2[0],e.v2[1],e.v2[2]),n.push(e.color[0],e.color[1],e.color[2]),n.push(e.reflection),n.push(e.shadowEnabled?1:0),n.push(e.lightEnabled?1:0);t.setInteger1Uniform("u_trianglesStop",n.length),e.activeTexture(e.TEXTURE0+0),this._sceneDataTexture.bind(),this._sceneDataTexture.update(n),t.setInteger1Uniform("u_sceneTextureData",0),t.setInteger1Uniform("u_sceneTextureSize",n.length)}{const n=[];t.setInteger1Uniform("u_sunLightsStart",0);for(const e of this._sunLights)n.push(e.direction[0],e.direction[1],e.direction[2]),n.push(e.intensity);t.setInteger1Uniform("u_sunLightsStop",n.length),t.setInteger1Uniform("u_spotLightsStart",n.length);for(const e of this._spotLights)n.push(e.position[0],e.position[1],e.position[2]),n.push(e.radius),n.push(e.intensity);t.setInteger1Uniform("u_spotLightsStop",n.length),e.activeTexture(e.TEXTURE0+1),this._lightsDataTexture.bind(),this._lightsDataTexture.update(n),t.setInteger1Uniform("u_lightsTextureData",1)}this._rayTracerGeometry.render()}))}p.unbind(),e.viewport(0,0,this._canvasWidth,this._canvasHeight),e.clear(e.COLOR_BUFFER_BIT);{const e=this._textureShaderProgram;e.bind((()=>{if(e.setTextureUniform("u_texture",this._finalTexture,0),this._antiAliasing){const t=.005*(1-this._renderWidth/this._canvasWidth),n=.005*(1-this._renderHeight/this._canvasHeight);e.setFloat2Uniform("u_step",t,n)}else e.setFloat2Uniform("u_step",0,0);this._screenGeometry.render(),x.unbind()}))}}reset(){this._sunLights.length=0,this._spotLights.length=0,this._spheres.length=0,this._boxes.length=0,this._triangles.length=0}setResolutionCoef(e){e===this._resolutionCoef||e<=0||e>1||(this._resolutionCoef=e,this._renderWidth=Math.floor(this._canvasWidth*this._resolutionCoef),this._renderHeight=Math.floor(this._canvasHeight*this._resolutionCoef),this._finalTexture.resize(this._renderWidth,this._renderHeight))}getResolutionCoef(){return this._resolutionCoef}setAntiAliasing(e){this._antiAliasing=e}getAntiAliasing(){return this._antiAliasing}getCurrentSize(){return[this._renderWidth,this._renderHeight]}_computeCameraFarCorners(){const e=O(C(),this._camera.target,this._camera.position),t=V(C(),e,this._camera.up),n=V(C(),t,e),i=ae(.5*this._cameraFovy),r=1*Math.cos(i)/Math.sin(i),s=F(C(),e,L(r,r,r)),o=M(C(),this._camera.position,s),a=this._canvasWidth/this._canvasHeight,f=F(C(),t,L(a,a,a)),d=M(C(),o,n),c=P(C(),o,n),h=P(C(),d,f),l=P(C(),c,f),u=M(C(),d,f),_=M(C(),c,f);return[u[0],u[1],u[2],h[0],h[1],h[2],_[0],_[1],_[2],l[0],l[1],l[2]]}get canvasWidth(){return this._canvasWidth}get canvasHeight(){return this._canvasHeight}get renderWidth(){return this._renderWidth}get renderHeight(){return this._renderHeight}get camera(){return this._camera}get spheres(){return this._spheres}get boxes(){return this._boxes}get triangles(){return this._triangles}get sunLights(){return this._sunLights}get spotLights(){return this._spotLights}}const de="\n#version 300 es\n\nprecision highp float;\n\nuniform mat4 u_composedMatrix;\n\nin vec2 a_vertex_position;\nin vec2 a_vertex_texCoord;\nin vec3 a_offset_position;\nin vec2 a_offset_texCoord;\nin vec3 a_offset_color;\nin float a_offset_scale;\n\nout vec2 v_texCoord;\nflat out vec3 v_color;\n\nvoid main(void)\n{\n  vec3 position = vec3(a_vertex_position, 0.0) * a_offset_scale + a_offset_position;\n\n  gl_Position = u_composedMatrix * vec4(position, 1.0);\n\n  v_texCoord = a_vertex_texCoord + a_offset_texCoord;\n  v_color = a_offset_color;\n}\n".trim(),ce="\n#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D u_texture;\n\nin vec2 v_texCoord;\nflat in vec3 v_color;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  vec4 textureColor = texture(u_texture, v_texCoord);\n  if (textureColor.a < 0.5)\n  {\n    discard;\n  }\n  else\n  {\n    o_color = vec4(v_color, textureColor.a);\n  }\n}\n\n".trim(),he="7e7e28fd03fd07fe04fe0aff02ff7e4dfd0cfd03fd07fe04fe0aff02ff1afc0dfd10fc08fc0ffe55ff15fb0bfd03fd07fe04fe08f707fd04ff07fe02fe0cfd0ffd0cfd0aff03fe03ff0afe44fe15fb0bfd03fd04f204f607fd03fe07fe02fe0cfd0efd0efd0aff02fe02ff0bfe43fd15fb0cfe03fe05f204fe01ff02ff0afd02fd07fe02fe0bfd0efd10fd0afa0cfe42fd16fb1bfe04fe07fe01ff02ff0efd09fc1cfd12fd09fa0cfe41fd17fb1bfe04fe07f70bfd0afc04ff17fd12fd06f405f616f61cfd19fd1cfe04fe08f709fd0bfb02fe17fd12fd06f405f616f61bfd1afd1cfe04fe0aff02ff01fe08fd0bfe02fa17fd12fd09fa0cfe3efd37f207ff02ff01fe07fd02fd07fe03fc19fd10fd0afa0cfe3dfd38f204f607fe03fd07fe03fd1bfd0efd0aff02fe02ff0bfe0cfd1dfd0dfd1dfd1cfe04fe07f708ff04fd07fe02fb1bfd0cfd0aff03fe03ff0afe0cfd1dfd0cfd1efd1cfe04fe0aff02ff1afb02fe1bfc08fc0ffe1cfd1dfd0bfd1ffd1cfe04fe0aff02ff7afd7e7e7e7e7e7e0efd17fd10fc0af80bfe0bf909f90dfd08f609fb08f506f808f82cfd19fd0df807fd04fd0afe0afd03fd07fd03fd0bfc08fd0ffd0bfd05fd05fd04fd06fd04fd2afd1bfd0bfc02fc06fd03fc09fd0afd04fd06fd04fd09fb08fd0efd0cfd05fd05fd04fd06fd04fd09fd0cfd0efd1dfd0afe05fd06fd02fb06fa11fd0dfd08fe01fd08fd0dfd0dfd05fd05fd04fd06fd04fd09fd0cfd0dfd0af409fd10fd06fd02fb06fa10fd0dfd08fe02fd08fd0dfd15fd05fb02fd06fd04fd09fd0cfd0cfd0bf40afd0efd07fd01fe01fd09fd0ffd0bfb08fe03fd08f808f70efd08fa08f626fd23fd0cfd08fd01fe01fd09fd0efd0cfb08f606f707f60cfd09fa09f726fd23fd0bfd09fb02fd09fd0dfd10fd07f60cfc06fd04fd0bfd08fd02fb0dfd09fd0cfd0cfd0bf40afd0cfd09fb02fd09fd0cfd12fd0bfd0ffd06fd04fd0afd09fd04fd0dfd09fd0cfd0dfd0af409fd19fc03fd09fd0bfd03fd06fd04fd0bfd08fd04fd06fd04fd09fd0afd04fd0cfd0afd0cfd0efd1dfd1afd04fd09fd0afd04fd06fd03fd0cfd08fd03fd07fd04fd09fd0afd04fd0bfd19fd10fd1bfd0ffd0af807f707f607f90bf907f909f80afd0bf809fb2efd19fd10fd7e51fd17fd11fd7e7e7e7e13f87e78fd05fd08fc09f709f907f808f606f608f907fd03fd07f90df905fc03fd06fb0bfd05fd05fd05fd08fb08fd05fd07fa09fd03fd07fd03fd07fd02fd08fd04fe07fd04fe07fd03fd06fd03fd09fd11fd08fd03fd07fd0cfc03fc05fd05fd07fd01fd07fd05fd06fd02fd08fd03fd06fd04fd07fd03fd07fd05ff07fd05ff06fd04fd06fd03fd09fd11fd08fd02fd08fd0cfb01fb05fc04fd06fd03fd06fd05fd05fd04fd07fd03fd06fd0efd03fd07fd0dfd0cfd04fd06fd03fd09fd11fd08fd01fd09fd0cf505fb03fd05fd05fd05fd02fa05fd04fd07fd03fd06fd0efd03fd07fd03fe08fd03fe07fd0dfd03fd09fd11fd08fa0afd0cf505fa02fd05fd05fd05fd02fa05fd04fd07f807fd0efd03fd07f808f807fd0df709fd11fd08fb0bfd0cfd01fd01fd05fd01fd01fd05fd05fd05fd02fa05fd04fd07f807fd0efd03fd07f808f807fd0df709fd11fd08fb0bfd0cfd02ff02fd05fd02fa05fd05fd05fd02fa05f607fd03fd06fd0efd03fd07fd03fe08fd03fe07fd02fb06fd03fd09fd0bfd03fd08fa0afd0cfd05fd05fd03fb05fd05fd05fd0dfd04fd07fd03fd06fd0efd03fd07fd0dfd0cfd04fd06fd03fd09fd0bfd03fd08fd01fd09fd05ff06fd05fd05fd04fc05fd05fd05fd0dfd04fd07fd03fd06fd04fd07fd03fd07fd05ff07fd0cfd04fd06fd03fd09fd0bfd03fd08fd02fd08fd04fe06fd05fd05fd05fd06fd03fd06fd0dfd04fd07fd03fd07fd03fd07fd02fd08fd04fe07fd0dfd03fd06fd03fd09fd0bfd03fd08fd03fd07fd03fd06fd05fd05fd05fd07fd01fd07fd0dfd04fd06f709f907f808f606fb0df806fd03fd07f90af908fc03fd06f606fd05fd05fd05fd08fb0af87e7e7e7e7e7e7e68fe1af70afb08f708f807f505fd03fd07fd03fd07fd05fd05fd03fd07fd03fd07f608f907ff11f90afc1afd03fd07fc01fc07fd03fd06fd04fd06fe02fd02fe05fd03fd07fd03fd07fd05fd05fd03fd07fd03fd07fd04fd08fd0bfe14fd09fa19fd03fd07fd03fd07fd03fd06fd04fd06ff03fd03ff05fd03fd07fd03fd07fd05fd05fd03fd07fd03fd07fe05fd08fd0bfd13fd08fd02fd18fd03fd06fd05fd06fd03fd06fd04fd0afd09fd03fd07fd03fd07fd05fd06fd01fd08fd03fd07ff05fd09fd0cfd12fd07fd04fd17fd03fd06fd05fd06fd03fd06fd11fd09fd03fd07fd03fd07fd05fd07fb09fd03fd0cfd0afd0dfd11fd28f807fd05fd06f808f90cfd09fd03fd07fd03fd07fd02ff02fd08fd0bfd01fd0cfd0bfd0efd10fd28f807fd05fd06f809f90bfd09fd03fd07fd03fd07fd02ff02fd08fd0cfb0cfd0cfd0ffd0ffd28fd0cfd03fb06fd02fd0efd0afd09fd03fd07fd03fd07fd02ff02fd07fb0cfd0cfd0dfd10fd0efd28fd0cfd02fa06fd03fd06fd04fd0afd09fd03fd07fd03fd08f707fd01fd0bfd0bfd05ff08fd11fd0dfd28fd0df707fd03fd06fd04fd0afd09fd03fd08fd01fd09fc01fc06fd03fd0afd0afd05fe08fd12fd0cfd28fd0df707fd03fd06fd04fd0afd09fd03fd09fb0bfd01fd07fd03fd0afd0afd04fd08fd13fd0bfd27fb12fd06fc03fd07f809f908f90bfd0cfd01fd07fd03fd08f908f608f910fd06f93cfa7e54f07e72f07e7e7e7e0bfd1dfc21fb19fb18fc10fd0ffd07fc0dfa39fd1efd22fd19fd01fd18fd10fd0ffd08fd10fd3bfd1cfd22fd19fd01fd18fd10fd0ffd08fd10fd3bfd1cfd22fd19fd1cfd2dfd10fd4af909f808f909f808f90afd0cfb02fe07fd01fc08fa0cfa08fd03fd0afd09f606f809f91efd08fd03fd06fd03fd07fd03fd07fd03fd07f808fd03fd08fc02fd0afd0ffd08fd02fd0bfd09fd02ff02fd05fd03fd07fd03fd1dfd08fd03fd06fd03fd07fd03fd07fd03fd07f808fd03fd08fc02fd0afd0ffd08fd01fd0cfd09fd02ff02fd05fd03fd07fd03fd18f808fd03fd06fd0dfd03fd07f709fd0bfd03fd08fd03fd0afd0ffd08fa0dfd09fd02ff02fd05fd03fd07fd03fd17fd03fd08fd03fd06fd0dfd03fd07fd0ffd0bfd03fd08fd03fd0afd0ffd08fd01fd0cfd09fd02ff02fd05fd03fd07fd03fd17fd03fd08fd03fd06fd03fd07fd03fd07fd03fd09fd0cf808fd03fd0afd0ffd08fd02fd0bfd09fd02ff02fd05fd03fd07fd03fd17fd03fd08fd03fd06fd03fd07fd03fd07fd03fd09fd0df908fd03fd0afd0ffd08fd03fd0afd09fd02ff02fd05fd03fd07fd03fd18fb02fe06fe02fb08f909fb02fe07f908f90ffd07fc03fd07f706fd03fd07fc03fd07f706fd05fd05fd03fd08f978fd03fd27fd03fd7e4af92afa7e7e7e7e7e7e18fa09fc09fa1efe4eff6efd0dfc0dfd1cfc4cfe6efd0dfc0dfd1bfa4afd6efd0dfc0dfd1afd02fd07fe02fb07fb02fe07fc02fd08f908f707fd03fd07fd03fd07fd05fd05fd02fd09fd03fd06f80afd0efc0efd08fb03fd05fd04fd07fd03fd05fd03fd09f706fd04fe09fd0bfd03fd07fd03fd07fd05fd05fd02fd09fd03fd06fe03fd08fd24fd05fd01fd02fd05fe06fe07fd03fd05fd03fd09fc02fd06fd04fe09fd0bfd03fd07fd03fd07fd05fd06fa0afd03fd06ff03fd09fd24fd05fd02fd01fd05fe06fe07fd03fd05fd03fd09fd0dfb0cfd0bfd03fd07fd03fd07fd02ff02fd07fc0bfd03fd09fd0cfd0efc0efd07fd03fb06fe06fe07fd03fd05fd03fd09fd0ffb0afd0bfd03fd07fd03fd07fd02ff02fd07fc0bfd03fd08fd0efd0dfc0dfd19fe06fe07fd03fd05fd03fd09fd0cfe04fd09fd01fd07fd03fd08fd01fd09fc01fc07fa0bf908fd03ff0bfd0dfc0dfd19fe06fe07f807f809fd0cfe04fd09fd01fd07fd03fd09fb0bfd01fd07fd02fd0bfb08fd03fe0bfd0dfc0dfd19f607fd11fd08fb0cf90bfb09fb02fe09fd0cfd01fd07fd02fd0dfd08f80cfa09fc09fa1af607fd11fd7cfd69fb0ffb77fa",le=[16,6],ue=[1/le[0],1/le[1]];class _e{constructor(){this._texture=new x,this._buffer=new Float32Array(36864),this._currentSize=0,this._textScale=14,this._horizontalTextAlign="left",this._verticalTextAlign="top",this._shader=new m("TextRenderer",{vertexSrc:de,fragmentSrc:ce,attributes:["a_vertex_position","a_vertex_texCoord","a_offset_position","a_offset_texCoord","a_offset_color","a_offset_scale"],uniforms:["u_composedMatrix","u_texture"]});const e=new g.GeometryBuilder;e.reset().setPrimitiveType("triangles").addVbo().addVboAttribute("a_vertex_position","vec2f").addVboAttribute("a_vertex_texCoord","vec2f").setStride(16).addVbo().setVboAsDynamic().setVboAsInstanced().addVboAttribute("a_offset_position","vec3f").addVboAttribute("a_offset_texCoord","vec2f").addVboAttribute("a_offset_color","vec3f").addVboAttribute("a_offset_scale","float").setStride(36),this._geometry=new g.Geometry(this._shader,e.getDef());const t=[{position:[.5,-.5],texCoord:[1*ue[0],1*ue[1]]},{position:[-.5,-.5],texCoord:[0*ue[0],1*ue[1]]},{position:[.5,.5],texCoord:[1*ue[0],0*ue[1]]},{position:[-.5,.5],texCoord:[0*ue[0],0*ue[1]]}],n=[1,0,2,1,2,3],i=[];for(const e of n){const n=t[e];i.push(n.position[0],n.position[1],n.texCoord[0],n.texCoord[1])}this._geometry.updateBuffer(0,i,i.length),this._geometry.setPrimitiveCount(i.length/4),this._geometry.setFloatBufferSize(1,36864),this._texCoordMap=new Map([[" ",[0*ue[0],0*ue[1]]],["!",[1*ue[0],0*ue[1]]],['"',[2*ue[0],0*ue[1]]],["#",[3*ue[0],0*ue[1]]],["$",[4*ue[0],0*ue[1]]],["%",[5*ue[0],0*ue[1]]],["&",[6*ue[0],0*ue[1]]],["'",[7*ue[0],0*ue[1]]],["(",[8*ue[0],0*ue[1]]],[")",[9*ue[0],0*ue[1]]],["*",[10*ue[0],0*ue[1]]],["+",[11*ue[0],0*ue[1]]],[",",[12*ue[0],0*ue[1]]],["-",[13*ue[0],0*ue[1]]],[".",[14*ue[0],0*ue[1]]],["/",[15*ue[0],0*ue[1]]],["0",[0*ue[0],1*ue[1]]],["1",[1*ue[0],1*ue[1]]],["2",[2*ue[0],1*ue[1]]],["3",[3*ue[0],1*ue[1]]],["4",[4*ue[0],1*ue[1]]],["5",[5*ue[0],1*ue[1]]],["6",[6*ue[0],1*ue[1]]],["7",[7*ue[0],1*ue[1]]],["8",[8*ue[0],1*ue[1]]],["9",[9*ue[0],1*ue[1]]],[":",[10*ue[0],1*ue[1]]],[";",[11*ue[0],1*ue[1]]],["<",[12*ue[0],1*ue[1]]],["=",[13*ue[0],1*ue[1]]],[">",[14*ue[0],1*ue[1]]],["?",[15*ue[0],1*ue[1]]],["@",[0*ue[0],2*ue[1]]],["A",[1*ue[0],2*ue[1]]],["B",[2*ue[0],2*ue[1]]],["C",[3*ue[0],2*ue[1]]],["D",[4*ue[0],2*ue[1]]],["E",[5*ue[0],2*ue[1]]],["F",[6*ue[0],2*ue[1]]],["G",[7*ue[0],2*ue[1]]],["H",[8*ue[0],2*ue[1]]],["I",[9*ue[0],2*ue[1]]],["J",[10*ue[0],2*ue[1]]],["K",[11*ue[0],2*ue[1]]],["L",[12*ue[0],2*ue[1]]],["M",[13*ue[0],2*ue[1]]],["N",[14*ue[0],2*ue[1]]],["O",[15*ue[0],2*ue[1]]],["P",[0*ue[0],3*ue[1]]],["Q",[1*ue[0],3*ue[1]]],["R",[2*ue[0],3*ue[1]]],["S",[3*ue[0],3*ue[1]]],["T",[4*ue[0],3*ue[1]]],["U",[5*ue[0],3*ue[1]]],["V",[6*ue[0],3*ue[1]]],["W",[7*ue[0],3*ue[1]]],["X",[8*ue[0],3*ue[1]]],["Y",[9*ue[0],3*ue[1]]],["Z",[10*ue[0],3*ue[1]]],["[",[11*ue[0],3*ue[1]]],["\\",[12*ue[0],3*ue[1]]],["]",[13*ue[0],3*ue[1]]],["^",[14*ue[0],3*ue[1]]],["_",[15*ue[0],3*ue[1]]],["`",[0*ue[0],4*ue[1]]],["a",[1*ue[0],4*ue[1]]],["b",[2*ue[0],4*ue[1]]],["c",[3*ue[0],4*ue[1]]],["d",[4*ue[0],4*ue[1]]],["e",[5*ue[0],4*ue[1]]],["f",[6*ue[0],4*ue[1]]],["g",[7*ue[0],4*ue[1]]],["h",[8*ue[0],4*ue[1]]],["i",[9*ue[0],4*ue[1]]],["j",[10*ue[0],4*ue[1]]],["k",[11*ue[0],4*ue[1]]],["l",[12*ue[0],4*ue[1]]],["m",[13*ue[0],4*ue[1]]],["n",[14*ue[0],4*ue[1]]],["o",[15*ue[0],4*ue[1]]],["p",[0*ue[0],5*ue[1]]],["q",[1*ue[0],5*ue[1]]],["r",[2*ue[0],5*ue[1]]],["s",[3*ue[0],5*ue[1]]],["t",[4*ue[0],5*ue[1]]],["u",[5*ue[0],5*ue[1]]],["v",[6*ue[0],5*ue[1]]],["w",[7*ue[0],5*ue[1]]],["x",[8*ue[0],5*ue[1]]],["y",[9*ue[0],5*ue[1]]],["z",[10*ue[0],5*ue[1]]],["{",[11*ue[0],5*ue[1]]],["|",[12*ue[0],5*ue[1]]],["}",[13*ue[0],5*ue[1]]],["~",[14*ue[0],5*ue[1]]]]);const r=new Uint8Array(98304);{let e=0;for(let t=0;t<he.length;t+=2){let n=parseInt(`${he.substring(t,t+2)}000000`,16)>>24,i=0;n<0&&(n=-n,i=255);for(let t=0;t<n;++t)r[4*e+0]=i,r[4*e+1]=i,r[4*e+2]=i,r[4*e+3]=i,++e}}this._texture.loadFromMemory(256,96,r)}setTextAlign(e,t){return this._horizontalTextAlign=e,this._verticalTextAlign=t,this}setTextScale(e){return this._textScale=e,this}pushText(e,t){if(0===e.length)return this;if(this._textScale<=0)return this;const n=[0];for(let t=0;t<e.length;++t)"\n"==e[t]?n.push(0):n[n.length-1]+=1;if(0===n.length)return this;let i=0;const r=[0,0],s=.5*this._textScale;switch(this._horizontalTextAlign){case"left":r[0]=t[0];break;case"centered":r[0]=t[0]-n[i]*s+s;break;case"right":r[0]=t[0]-n[i]*this._textScale+this._textScale}switch(this._verticalTextAlign){case"top":r[1]=t[1];break;case"centered":r[1]=t[1]+n.length*s-s;break;case"bottom":r[1]=t[1]-(n.length-1)*this._textScale}for(let o=0;o<e.length;++o){const a=e[o];if("\n"==a){switch(i+=1,this._horizontalTextAlign){case"left":r[0]=t[0];break;case"centered":r[0]=t[0]-n[i]*s+s;break;case"right":r[0]=t[0]-n[i]*this._textScale+this._textScale}r[1]-=this._textScale}else this._pushLetter(a,r),r[0]+=this._textScale}return this}_pushLetter(e,t){if(this._currentSize+90>=this._buffer.length)return;const n=this._texCoordMap.get(e);if(!n)throw new Error(`fail to find a letter, letter=${e}`);const i=[1,1,1],r=[0,0,0];for(let e=-1;e<=1;++e)for(let i=-1;i<=1;++i)this._buffer[this._currentSize++]=t[0]+2*i,this._buffer[this._currentSize++]=t[1]+2*e,this._buffer[this._currentSize++]=-.1,this._buffer[this._currentSize++]=n[0],this._buffer[this._currentSize++]=n[1],this._buffer[this._currentSize++]=r[0],this._buffer[this._currentSize++]=r[1],this._buffer[this._currentSize++]=r[2],this._buffer[this._currentSize++]=this._textScale;this._buffer[this._currentSize++]=t[0],this._buffer[this._currentSize++]=t[1],this._buffer[this._currentSize++]=0,this._buffer[this._currentSize++]=n[0],this._buffer[this._currentSize++]=n[1],this._buffer[this._currentSize++]=i[0],this._buffer[this._currentSize++]=i[1],this._buffer[this._currentSize++]=i[2],this._buffer[this._currentSize++]=this._textScale}flush(e){return 0===this._currentSize||(this._shader.bind((()=>{this._shader.setMatrix4Uniform("u_composedMatrix",e),this._shader.setTextureUniform("u_texture",this._texture,0),this._geometry.updateBuffer(1,this._buffer,this._currentSize),this._geometry.setInstancedCount(this._currentSize/9),this._geometry.render()})),x.unbind(),this.clear()),this}clear(){return this._currentSize=0,this}}class pe{constructor(e){this._debugSceneCamera=new Z,this._mainHudCamera=new Z,this._def=e,this.resize(this._def.canvasDomElement.width,this._def.canvasDomElement.height),u.initialize(this._def.canvasDomElement),this._rayTracerRenderer=new fe({canvasWidth:this._def.canvasDomElement.width,canvasHeight:this._def.canvasDomElement.height,fovy:70}),this._textRenderer=new _e,this._stackRenderers=new ne}initialize(){const e=u.getContext();e.pixelStorei(e.UNPACK_ALIGNMENT,1),e.disable(e.DEPTH_TEST),e.disable(e.BLEND),e.disable(e.CULL_FACE),e.depthFunc(e.NEVER),e.clearColor(0,0,0,1),e.clearDepth(1)}resize(e,t){this._debugSceneCamera.setViewportSize(e,t),this._debugSceneCamera.setAsPerspective({fovy:ae(70),near:1,far:500}),this._mainHudCamera.setViewportSize(e,t);const n=.5*e,i=.5*t;this._mainHudCamera.setAsOrthogonal({left:-n,right:+n,top:-i,bottom:+i,near:-200,far:200}),this._mainHudCamera.setEye([n,i,1]),this._mainHudCamera.setTarget([n,i,0]),this._mainHudCamera.setUpAxis([0,1,0]),this._mainHudCamera.computeMatrices()}_pushWireFrameSphere(e){const t=.5257311121191336*e.radius,n=.8506508083520399*e.radius,i=[[-t,0,n],[t,0,n],[-t,0,-n],[t,0,-n],[0,n,t],[0,n,-t],[0,-n,t],[0,-n,-t],[n,t,0],[-n,t,0],[n,-t,0],[-n,-t,0]];for(let t=0;t<i.length;++t)i[t][0]+=e.position[0],i[t][1]+=e.position[1],i[t][2]+=e.position[2];const r=[[0,4,1],[0,9,4],[9,5,4],[4,5,8],[4,8,1],[8,10,1],[8,3,10],[5,3,8],[5,2,3],[2,7,3],[7,10,3],[7,6,10],[7,11,6],[11,0,6],[0,1,6],[6,1,10],[9,0,11],[9,11,2],[9,2,5],[7,2,11]];for(const t of r){const n=i[t[0]],r=i[t[1]],s=i[t[2]];this._stackRenderers.pushLine(n,r,e.color),this._stackRenderers.pushLine(r,s,e.color),this._stackRenderers.pushLine(s,n,e.color)}}_pushWireFrameBox(e){const t=[L(-e.boxSize[0],-e.boxSize[1],-e.boxSize[2]),L(+e.boxSize[0],-e.boxSize[1],-e.boxSize[2]),L(-e.boxSize[0],+e.boxSize[1],-e.boxSize[2]),L(+e.boxSize[0],+e.boxSize[1],-e.boxSize[2]),L(-e.boxSize[0],-e.boxSize[1],+e.boxSize[2]),L(+e.boxSize[0],-e.boxSize[1],+e.boxSize[2]),L(-e.boxSize[0],+e.boxSize[1],+e.boxSize[2]),L(+e.boxSize[0],+e.boxSize[1],+e.boxSize[2])],n=[];t.forEach((t=>{const i=L(0,0,0);!function(e,t,n){var i=t[0],r=t[1],s=t[2],o=n[3]*i+n[7]*r+n[11]*s+n[15];o=o||1,e[0]=(n[0]*i+n[4]*r+n[8]*s+n[12])/o,e[1]=(n[1]*i+n[5]*r+n[9]*s+n[13])/o,e[2]=(n[2]*i+n[6]*r+n[10]*s+n[14])/o}(i,t,e.matrix),n.push(i)}));[[0,1],[1,3],[3,2],[2,0],[4,5],[5,7],[7,6],[6,4],[0,4],[1,5],[3,7],[2,6]].forEach((t=>{this._stackRenderers.pushLine(n[t[0]],n[t[1]],e.color)}))}_pushWireFrameTriangle(e){this._stackRenderers.pushLine(e.v0,e.v1,e.color),this._stackRenderers.pushLine(e.v1,e.v2,e.color),this._stackRenderers.pushLine(e.v2,e.v0,e.color)}safeSceneWireFrame(e){this._debugSceneCamera.setEye(this._rayTracerRenderer.camera.position),this._debugSceneCamera.setTarget(this._rayTracerRenderer.camera.target),this._debugSceneCamera.setUpAxis(this._rayTracerRenderer.camera.up),this._debugSceneCamera.computeMatrices(),this._stackRenderers.safeRender(this._debugSceneCamera.getComposedMatrix(),e)}flushHudWireFrame(){this._stackRenderers.flush(this._mainHudCamera.getComposedMatrix())}flushHudText(){this._textRenderer.flush(this._mainHudCamera.getComposedMatrix())}setupDebugRenderer(){this._rayTracerRenderer.spheres.forEach((e=>this._pushWireFrameSphere(e))),this._rayTracerRenderer.boxes.forEach((e=>this._pushWireFrameBox(e))),this._rayTracerRenderer.triangles.forEach((e=>this._pushWireFrameTriangle(e)))}get rayTracerRenderer(){return this._rayTracerRenderer}get stackRenderers(){return this._stackRenderers}get textRenderer(){return this._textRenderer}}const ge=[];let me=0;const xe=[];let ve=0;const be=[];for(let e=0;e<6;++e)for(let t=0;t<6;++t)be.push([[10*t-30,3*Math.random()-4,10*e-30],[Math.random(),Math.random(),Math.random()]]);class ye{constructor(e){this._currFrameTime=Date.now(),this._frameProfiler=new b,this._continuousTime=0,this._perfAutoScalingEnabled=!0,this._framesUntilNextCheck=60,this._canvasElement=e.canvasElement,this._def=e,this._freeFlyController=new q({coordinates:["Z","X","Y"],position:[-10,9,22],theta:.85*Math.PI,phi:.15*-Math.PI,mouseSensibility:.1,keyboardSensibility:.45*Math.PI,touchSensibility:.3,movingSpeed:10}),n.activate(),l.activate(this._canvasElement),c.allowPointerLockedOnClickEvent(this._canvasElement),c.addOnLockChange((()=>{c.isPointerLocked(this._canvasElement)?(this._def.logger.log("The pointer lock status is now locked"),r.activate()):(this._def.logger.log("The pointer lock status is now unlocked"),r.deactivate(),c.allowPointerLockedOnClickEvent(this._canvasElement))})),c.addOnLockError((e=>{this._def.logger.log(`The pointer lock sent an error, event: "${JSON.stringify(e)}"`)})),this._renderer=new pe({canvasDomElement:this._canvasElement}),this._renderer.initialize(),this._running=!1,this._errorGraphicContext=!1,this._def.resolution.addEventListener("input",(e=>{const t=e.target.value;this._setResolution(t)})),this._def.anti_aliasing_enabled.addEventListener("click",(()=>{const e=!0===this._def.anti_aliasing_enabled.checked;this._renderer.rayTracerRenderer.setAntiAliasing(e),this._def.logger.log("Anti aliasing change: "+(!0===e?"enabled":"disabled"))}));{const e=this._def.resolution.value;this._setResolution(e)}this._def.logger.log("user interface initialized"),this._def.perfAutoScaling.addEventListener("input",(()=>{this._framesUntilNextCheck=60,this._perfAutoScalingEnabled=!0===this._def.perfAutoScaling.checked,this._def.logger.log("Performance auto scaler change: "+(!0===this._perfAutoScalingEnabled?"enabled":"disabled"))}))}init(){return e(this,void 0,void 0,(function*(){yield this._renderer.initialize()}))}resize(e,t,n){let i=e,r=t;n?(this._canvasElement.style.position="absolute",i=window.innerWidth,r=window.innerHeight):this._canvasElement.style.position="relative",this._canvasElement.style.left="0px",this._canvasElement.style.top="0px",this._canvasElement.style.width=`${i}px`,this._canvasElement.style.height=`${r}px`,this._canvasElement.width=i,this._canvasElement.height=r,this._renderer.resize(i,r)}start(){this.isRunning()||(this._running=!0,this._tick())}stop(){this._running=!1}isRunning(){return this._running&&!this._errorGraphicContext}_tick(){const e=()=>{this._running&&!this._errorGraphicContext&&(window.requestAnimationFrame(e),this._mainLoop())};e()}_mainLoop(){const e=Date.now();let t=e-this._currFrameTime;if(this._currFrameTime=e,this._frameProfiler.pushDelta(t),!0===this._perfAutoScalingEnabled)if(t>40){if(t=40,--this._framesUntilNextCheck<0){this._def.logger.log("performance auto scaling: slow framerate, scaling down resolution");const e=parseInt(this._def.resolution.value,10)+1;e>=1&&e<=10&&(this._setResolution(e),this._def.resolution.value=`${e}`),this._framesUntilNextCheck=60}}else this._framesUntilNextCheck=60;const n=t/1e3;this._continuousTime+=n,this._freeFlyController.update(n),r.resetDelta();{const e=u.getContext();e.disable(e.DEPTH_TEST)}this._continuousTime+=n,((e,t,n,i,r,s)=>{{for(let t=1;t<6;++t)for(let n=1;n<6;++n){const i=be[6*(t-1)+(n-1)],r=be[6*(t-0)+(n-1)],s=be[6*(t-1)+(n-0)],o=be[6*(t-0)+(n-0)],a=i[1],f=o[1];e.rayTracerRenderer.pushTriangle({v0:r[0],v1:i[0],v2:s[0],color:a,reflection:.1,shadowEnabled:!0,lightEnabled:!0}),e.rayTracerRenderer.pushTriangle({v0:o[0],v1:r[0],v2:s[0],color:f,reflection:.1,shadowEnabled:!0,lightEnabled:!0})}e.rayTracerRenderer.pushTriangle({v0:[5,5,1],v1:[10,10,1],v2:[10,5,1],color:[1,1,1],reflection:.1,shadowEnabled:!0,lightEnabled:!0}),e.rayTracerRenderer.pushBox([-10,0,-10],0,0,0,[1,5,1],[1,1,1],0,!1),e.rayTracerRenderer.pushBox([10,0,-10],0,0,0,[1,5,1],[1,1,1],0,!1),e.rayTracerRenderer.pushBox([-10,0,10],0,0,0,[1,5,1],[1,1,1],0,!1),e.rayTracerRenderer.pushBox([10,0,10],0,0,0,[1,5,1],[1,1,1],0,!1),e.rayTracerRenderer.pushBox([5,0,10],0,0,0,[2,.5,1],[1,0,0],0,!1),e.rayTracerRenderer.pushBox([6,.5,10],0,0,0,[.75,.25,.5],[.5,.5,.5],0,!1),e.rayTracerRenderer.pushBox([4,-.25,11.5],0,0,0,[1,.25,.5],[1,1,0],0,!1),e.rayTracerRenderer.pushBox([4,-.25,8.5],0,0,0,[1,.25,.5],[1,1,0],0,!1),e.rayTracerRenderer.pushBox([4,1,10],0,0,0,[1,.5,.25],[1,1,0],0,!1),e.rayTracerRenderer.pushSphere([15,0,15],1,[1,1,1],.5,!1),e.rayTracerRenderer.pushSphere([5,0,5],1,[1,1,1],.5,!1);const o=(i/100*2-1)*Math.PI*2,a=(r/100*2-1)*Math.PI*2,f=(s/100*2-1)*Math.PI*2;e.rayTracerRenderer.pushBox([0,0,0],o,a,f,[2,1,.5],[1,.5,.5],.8,!0),e.rayTracerRenderer.pushBox([0,2.5,0],o,a,f,[2,1,.5],[1,.5,.5],.8,!0);for(let t=0;t<8;++t){const i=t/8;e.rayTracerRenderer.pushSphere([8*Math.sin(.5*n+2*Math.PI*i),1*Math.sin(.5*n+2*Math.PI*i)+1,8*Math.cos(.5*n+2*Math.PI*i)],.5,[i,1-i,0],0,!1)}e.rayTracerRenderer.pushSunLight([1,1,1],1);{const t=-.5*n,i=[7*Math.sin(t),4,7*Math.cos(t)],r=[7*Math.sin(t+.5*Math.PI),4,7*Math.cos(t+.5*Math.PI)];e.rayTracerRenderer.pushSphere(i,.5,[1,1,1],0,!1,!1,!1),e.rayTracerRenderer.pushSphere(r,.5,[1,1,1],0,!1,!1,!1),e.rayTracerRenderer.pushSpotLight(i,5,10),e.rayTracerRenderer.pushSpotLight(r,5,10)}if(me>0&&(me-=t),me<=0)me=3,ge.push({pos:[-8,0,-5],vel:[0,0,0],life:.35,maxLife:.35}),ve=0;else if(me>1&&me<3&&(ve>0&&(ve-=t),ve<=0)){ve=1/16;const e=(e,t)=>Math.random()*(t-e)+e,t=me>2&&me<3?5:1;for(let n=0;n<t;++n){const t=[2*e(-1,1),4+2*e(-1,1),2*e(-1,1)];xe.push({pos:[-8,1,-5],vel:t,life:1,maxLife:1})}}for(let n=0;n<ge.length;){if(ge[n].life-=t,ge[n].life<=0){ge.splice(n,1);continue}const i=ge[n].life/ge[n].maxLife,r=Math.sin(i*Math.PI),s=2*r;if(s>0){const t=2*r,i=2*r;e.rayTracerRenderer.pushSphere(ge[n].pos,s,[1,1,1],0,!1,!1,!1),e.rayTracerRenderer.pushSpotLight(ge[n].pos,5*t,5*i)}++n}{const n=L(1,.5,0),i=L(.2,.2,.2);let r=L(0,0,0);for(let s=0;s<xe.length;){if(xe[s].life-=t,xe[s].life<=0){xe.splice(s,1);continue}const{pos:o,vel:a}=xe[s];B(o,o,a,t);const f=xe[s].life/xe[s].maxLife,d=Math.sin(f*Math.PI);d>0&&(r=N(r,i,n,f),e.rayTracerRenderer.pushSphere(xe[s].pos,d,r,0,!1,!0)),++s}}}})(this._renderer,n,this._continuousTime,this._def.angle_x.value,this._def.angle_y.value,this._def.angle_z.value),this._renderer.rayTracerRenderer.lookAt(this._freeFlyController.getPosition(),this._freeFlyController.getTarget(),this._freeFlyController.getUpAxis()),this._renderer.rayTracerRenderer.render();!0===this._def.debug_mode_enabled.checked&&this._renderer.safeSceneWireFrame((()=>{this._renderer.setupDebugRenderer(),this._renderer.stackRenderers.pushLine([0,0,0],[100,0,0],[1,0,0]),this._renderer.stackRenderers.pushLine([0,0,0],[0,100,0],[0,1,0]),this._renderer.stackRenderers.pushLine([0,0,0],[0,0,100],[0,0,1])}));const i=u.getContext();i.clear(i.DEPTH_BUFFER_BIT),i.enable(i.DEPTH_TEST),i.depthFunc(i.LESS),Y(this._canvasElement,this._renderer.stackRenderers,this._renderer.textRenderer),((e,t,n,i,r,s=!1)=>{const o=5*Math.ceil(n.maxDelta/5);{i.pushOriginBoundRectangle(e,t,[0,0,0,.5]);const n=[[e[0]+0*t[0],e[1]+0*t[1],0],[e[0]+1*t[0],e[1]+0*t[1],0],[e[0]+1*t[0],e[1]+1*t[1],0],[e[0]+0*t[0],e[1]+1*t[1],0]];i.pushLine(n[0],n[1],[1,1,1]),i.pushLine(n[1],n[2],[1,1,1]),i.pushLine(n[2],n[3],[1,1,1]),i.pushLine(n[3],n[0],[1,1,1])}for(let n=5;n<o;n+=5){const r=n/o,s=[e[0]+0,e[1]+t[1]*r,0],a=[e[0]+t[0],e[1]+t[1]*r,0];i.pushLine(s,a,[.5,.5,.5])}if(n.framesDelta.length>=2){const r=t[0]/n.framesDelta.length;let s=n.framesDelta[0],a=0,f=t[1]*s/o;for(let d=1;d<n.framesDelta.length;++d){const c=n.framesDelta[d],h=d*r,l=t[1]*c/o,u=[e[0]+a,e[1]+f,0],_=[e[0]+h,e[1]+l,0];i.pushLine(u,_,[1,1,1]),s=c,a=h,f=l}}{const i=14,o=.5*i,a=n.averageDelta,f=n.maxDelta,d=n.minDelta;let c=`~${a.toFixed(0)}ms`,h=`<${f}ms`,l=`>${d}ms`;if(!0===s){const e=e=>e<999?e.toFixed(0):"???";c+=`\n~${e(1e3/a)}fps`,h+=`\n<${e(1e3/f)}fps`,l+=`\n>${e(1e3/d)}fps`}r.setTextScale(i).setTextAlign("left","top").pushText(c,[e[0]+7,e[1]-8]).setTextAlign("left","centered").pushText(h,[e[0]+t[0]+o,e[1]+t[1]-1*o]).pushText(l,[e[0]+t[0]+o,e[1]+1*o])}})([10,this._canvasElement.height-60,0],[100,50],this._frameProfiler,this._renderer.stackRenderers,this._renderer.textRenderer,!0),this._renderer.flushHudWireFrame(),this._renderer.flushHudText(),this._renderer.rayTracerRenderer.reset()}_setResolution(e){this._renderer.rayTracerRenderer.setResolutionCoef(1/e);const t=this._renderer.rayTracerRenderer.getCurrentSize(),n=t[0]*t[1];this._def.logger.log(`resolution changed (1/${e}) => ${t[0]}x${t[1]} (${n}px)`)}}window.addEventListener("load",(()=>e(void 0,void 0,void 0,(function*(){let t,n=null;window.addEventListener("error",(i=>e(void 0,void 0,void 0,(function*(){t?t.error(i.message):console.error(i.message),n&&n.stop()})))),t=new v("loggerOutput"),t.log("page loaded");const i=e=>{const t=document.querySelector(e);if(!t)throw new Error(`html element "${e}" not found`);return t},r=i("#rendering-canvas"),s=i("#auto-scaling-enabled"),o=i("#resolution"),a=i("#anti-aliasing-enabled"),f=i("#debug-mode-enabled"),d=i("#angle-x"),c=i("#angle-y"),h=i("#angle-z");if(!window.WebGL2RenderingContext)throw new Error("missing WebGL2 feature (unsupported)");n=new ye({canvasElement:r,logger:t,perfAutoScaling:s,resolution:o,anti_aliasing_enabled:a,debug_mode_enabled:f,angle_x:d,angle_y:c,angle_z:h}),t.log("initializing"),yield n.init(),t.log("initialized"),n.start(),t.log("running")}))),!1);
