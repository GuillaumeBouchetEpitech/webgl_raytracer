"use strict";function e(e,t,n,r){return new(n||(n=Promise))((function(i,o){function a(e){try{d(r.next(e))}catch(e){o(e)}}function s(e){try{d(r.throw(e))}catch(e){o(e)}}function d(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,s)}d((r=r.apply(e,t||[])).next())}))}!function(e,t){function n(e){return document.createElement(e)}function r(e,t){for(var n in t)try{e.style[n]=t[n]}catch(e){}return e}function i(e){return null==e?String(e):"object"==typeof e||"function"==typeof e?Object.prototype.toString.call(e).match(/\s([a-z]+)/i)[1].toLowerCase()||"object":typeof e}function o(e,t){if("array"!==i(t))return-1;if(t.indexOf)return t.indexOf(e);for(var n=0,r=t.length;n<r;n++)if(t[n]===e)return n;return-1}function a(){var e=arguments;for(var t in e[1])if(e[1].hasOwnProperty(t))switch(i(e[1][t])){case"object":e[0][t]=a({},e[0][t],e[1][t]);break;case"array":e[0][t]=e[1][t].slice(0);break;default:e[0][t]=e[1][t]}return e.length>2?a.apply(null,[e[0]].concat(Array.prototype.slice.call(e,2))):e[0]}function s(e){return 1===(e=Math.round(255*e).toString(16)).length?"0"+e:e}function d(e,t,n,r){e.addEventListener?e[r?"removeEventListener":"addEventListener"](t,n,!1):e.attachEvent&&e[r?"detachEvent":"attachEvent"]("on"+t,n)}var f;!function(){var t=e.performance;if(t&&(t.now||t.webkitNow)){var n=t.now?"now":"webkitNow";f=t[n].bind(t)}else f=function(){return+new Date}}();var c=e.cancelAnimationFrame||e.cancelRequestAnimationFrame,h=e.requestAnimationFrame;!function(){for(var t=["moz","webkit","o"],n=0,r=0,i=t.length;r<i&&!c;++r)c=e[t[r]+"CancelAnimationFrame"]||e[t[r]+"CancelRequestAnimationFrame"],h=c&&e[t[r]+"RequestAnimationFrame"];c||(h=function(t){var r=f(),i=Math.max(0,16-(r-n));return n=r+i,e.setTimeout((function(){t(r+i)}),i)},c=function(e){clearTimeout(e)})}();var l="string"===i(document.createElement("div").textContent)?"textContent":"innerText";function u(e,m){"object"===i(e)&&e.nodeType===t&&(m=e,e=document.body),e||(e=document.body);var g,x,v,b,y,T,E,w,S,R=this,D=a({},u.defaults,m||{}),k={},C=[],P=100,L=[],M=D.threshold,A=0,I=f()-M,F=[],B=[],z="fps"===D.show;function U(e,t,n,r){return x[0|e][Math.round(Math.min((t-n)/(r-n)*P,P))]}function N(){k.legend.fps!==z&&(k.legend.fps=z,k.legend[l]=z?"FPS":"ms"),E=z?R.fps:R.duration,k.count[l]=E>999?"999+":E.toFixed(E>99?0:D.decimals)}function O(){if(v=f(),I<v-D.threshold&&(R.fps-=R.fps/Math.max(1,60*D.smoothing/D.interval),R.duration=1e3/R.fps),function(){for(w=D.history;w--;)F[w]=0===w?R.fps:F[w-1],B[w]=0===w?R.duration:B[w-1]}(),N(),D.heat){if(L.length)for(w=L.length;w--;)L[w].el.style[g[L[w].name].heatOn]=z?U(g[L[w].name].heatmap,R.fps,0,D.maxFps):U(g[L[w].name].heatmap,R.duration,D.threshold,0);if(k.graph&&g.column.heatOn)for(w=C.length;w--;)C[w].style[g.column.heatOn]=z?U(g.column.heatmap,F[w],0,D.maxFps):U(g.column.heatmap,B[w],D.threshold,0)}if(k.graph)for(S=0;S<D.history;S++)C[S].style.height=(z?F[S]?Math.round(T/D.maxFps*Math.min(F[S],D.maxFps)):0:B[S]?Math.round(T/D.threshold*Math.min(B[S],D.threshold)):0)+"px"}function X(){D.interval<20?(b=h(X),O()):(b=setTimeout(X,D.interval),y=h(O))}function V(e){(e=e||window.event).preventDefault?(e.preventDefault(),e.stopPropagation()):(e.returnValue=!1,e.cancelBubble=!0),R.toggle()}function H(){D.toggleOn&&d(k.container,D.toggleOn,V,1),e.removeChild(k.container)}function W(){for(var t in k.container&&H(),function(){if(g=u.theme[D.theme],!(x=g.compiledHeatmaps||[]).length&&g.heatmaps.length){for(S=0;S<g.heatmaps.length;S++)for(x[S]=[],w=0;w<=P;w++)x[S][w]=(e=.33/P*w,t=g.heatmaps[S].saturation,r=void 0,i=void 0,o=void 0,a=void 0,d=void 0,f=void 0,c=void 0,0==(a=(n=g.heatmaps[S].lightness)<=.5?n*(1+t):n+t-n*t)?"#000":(c=a*((a-(d=2*n-a))/a)*((e*=6)-(f=Math.floor(e))),0===f||6===f?(r=a,i=d+c,o=d):1===f?(r=a-c,i=a,o=d):2===f?(r=d,i=a,o=d+c):3===f?(r=d,i=a-c,o=a):4===f?(r=d+c,i=d,o=a):(r=a,i=d,o=a-c),"#"+s(r)+s(i)+s(o)));g.compiledHeatmaps=x}var e,t,n,r,i,o,a,d,f,c}(),k.container=r(n("div"),g.container),k.count=k.container.appendChild(r(n("div"),g.count)),k.legend=k.container.appendChild(r(n("div"),g.legend)),k.graph=D.graph?k.container.appendChild(r(n("div"),g.graph)):0,L.length=0,k)k[t]&&g[t].heatOn&&L.push({name:t,el:k[t]});if(C.length=0,k.graph)for(k.graph.style.width=D.history*g.column.width+(D.history-1)*g.column.spacing+"px",w=0;w<D.history;w++)C[w]=k.graph.appendChild(r(n("div"),g.column)),C[w].style.position="absolute",C[w].style.bottom=0,C[w].style.right=w*g.column.width+w*g.column.spacing+"px",C[w].style.width=g.column.width+"px",C[w].style.height="0px";G(),N(),e.appendChild(k.container),k.graph&&(T=k.graph.clientHeight),D.toggleOn&&("click"===D.toggleOn&&(k.container.style.cursor="pointer"),d(k.container,D.toggleOn,V))}function G(){r(k.container,D)}R.options=D,R.fps=0,R.duration=0,R.isPaused=0,R.tickStart=function(){A=f()},R.tick=function(){v=f(),M+=(v-I-M)/D.smoothing,R.fps=1e3/M,R.duration=A<I?M:v-A,I=v},R.pause=function(){return b&&(R.isPaused=1,clearTimeout(b),c(b),c(y),b=y=0),R},R.resume=function(){return b||(R.isPaused=0,X()),R},R.set=function(e,t){return D[e]=t,z="fps"===D.show,-1!==o(e,_)&&W(),-1!==o(e,p)&&G(),R},R.showDuration=function(){return R.set("show","ms"),R},R.showFps=function(){return R.set("show","fps"),R},R.toggle=function(){return R.set("show",z?"ms":"fps"),R},R.hide=function(){return R.pause(),k.container.style.display="none",R},R.show=function(){return R.resume(),k.container.style.display="block",R},R.destroy=function(){R.pause(),H(),R.tick=R.tickStart=function(){}},W(),X()}u.extend=a,window.FPSMeter=u,u.defaults={interval:100,smoothing:10,show:"fps",toggleOn:"click",decimals:1,maxFps:60,threshold:100,position:"absolute",zIndex:10,left:"5px",top:"5px",right:"auto",bottom:"auto",margin:"0 0 0 0",theme:"dark",heat:0,graph:0,history:20};var _=["toggleOn","theme","heat","graph","history"],p=["position","zIndex","left","top","right","bottom","margin"]}(window),function(e,t,n){t.theme={};var r=t.theme.base={heatmaps:[],container:{heatOn:null,heatmap:null,padding:"5px",minWidth:"95px",height:"30px",lineHeight:"30px",textAlign:"right",textShadow:"none"},count:{heatOn:null,heatmap:null,position:"absolute",top:0,right:0,padding:"5px 10px",height:"30px",fontSize:"24px",fontFamily:"Consolas, Andale Mono, monospace",zIndex:2},legend:{heatOn:null,heatmap:null,position:"absolute",top:0,left:0,padding:"5px 10px",height:"30px",fontSize:"12px",lineHeight:"32px",fontFamily:"sans-serif",textAlign:"left",zIndex:2},graph:{heatOn:null,heatmap:null,position:"relative",boxSizing:"padding-box",MozBoxSizing:"padding-box",height:"100%",zIndex:1},column:{width:4,spacing:1,heatOn:null,heatmap:null}};t.theme.dark=t.extend({},r,{heatmaps:[{saturation:.8,lightness:.8}],container:{background:"#222",color:"#fff",border:"1px solid #1a1a1a",textShadow:"1px 1px 0 #222"},count:{heatOn:"color"},column:{background:"#3f3f3f"}}),t.theme.light=t.extend({},r,{heatmaps:[{saturation:.5,lightness:.5}],container:{color:"#666",background:"#fff",textShadow:"1px 1px 0 rgba(255,255,255,.5), -1px -1px 0 rgba(255,255,255,.5)",boxShadow:"0 0 0 1px rgba(0,0,0,.1)"},count:{heatOn:"color"},column:{background:"#eaeaea"}}),t.theme.colorful=t.extend({},r,{heatmaps:[{saturation:.5,lightness:.6}],container:{heatOn:"backgroundColor",background:"#888",color:"#fff",textShadow:"1px 1px 0 rgba(0,0,0,.2)",boxShadow:"0 0 0 1px rgba(0,0,0,.1)"},column:{background:"#777",backgroundColor:"rgba(0,0,0,.2)"}}),t.theme.transparent=t.extend({},r,{heatmaps:[{saturation:.8,lightness:.5}],container:{padding:0,color:"#fff",textShadow:"1px 1px 0 rgba(0,0,0,.5)"},count:{padding:"0 5px",height:"40px",lineHeight:"40px"},legend:{padding:"0 5px",height:"40px",lineHeight:"42px"},graph:{height:"40px"},column:{width:5,background:"#999",heatOn:"backgroundColor",opacity:.5}})}(window,FPSMeter);class t{constructor(e){if(this._lines=[],this._maxLines=30,this._textAreaElement=document.getElementById(e),!this._textAreaElement)throw new Error(`DOM elements not found, id=${e}`);this._textAreaElement.value=""}log(...e){if(0===e.length)return;const t=Array.prototype.slice.call(e).join(" ");console.log(t),this._pushText(t)}error(...e){if(0===e.length)return;const t=Array.prototype.slice.call(e).join(" ");console.error(t),this._pushText(`[ERR] - ${t}`)}_pushText(e){this._lines.push(e),this._lines.length>this._maxLines&&this._lines.splice(0,this._lines.length-this._maxLines),this._textAreaElement.value=`${this._lines.join("\n")}\n`,this._textAreaElement.scrollTop=this._textAreaElement.scrollHeight}peekLast(){if(this._lines.length>0)return this._lines[this._lines.length-1]}popLast(){this._lines.length>0&&this._lines.splice(this._lines.length-1,1)}}const n={Num0:48,Num1:49,Num2:50,Num3:51,Num4:52,Num5:53,Num6:54,Num7:55,Num8:56,Num9:57,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,Semicolon:186,Equal:187,Comma:188,Minus:189,Period:190,BackQuote:192,BracketLeft:219,Backslash:220,BracketRight:221,Quote:222,Shift:16,Ctrl:17,Alt:18,CapsLock:20,Tab:9,Enter:13,Pause:19,Escape:27,Space:32,PageUp:33,PageDown:34,End:35,Home:36,ArrowLeft:37,ArrowUp:38,ArrowRight:39,ArrowDown:40,PrintScreen:44,Insert:45,Delete:46,ContextMenu:93,ScrollLock:145,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,F13:124,F14:125,F15:126,F16:127,F17:128,F18:129,F19:130,F20:131,F21:132,F22:133,F23:134,F24:135,NumPad0:96,NumPad1:97,NumPad2:98,NumPad3:99,NumPad4:100,NumPad5:101,NumPad6:102,NumPad7:103,NumPad8:104,NumPad9:105,NumPadMultiply:106,NumPadAdd:107,NumPadSubtract:109,NumPadDecimal:110,NumPadDivide:111,NumLock:144,NumPadComma:194,NumPadEqual:12};const r=new class{constructor(){this._pressedKeysSet=new Set,this._preventDefaultKeysSet=new Set,this._activated=!1;this._activated=!1,this._handleKeyDown=(e=>{const{keyCode:t}=e;this._preventDefaultKeysSet.has(t)&&e.preventDefault(),this._pressedKeysSet.add(t)}).bind(this),this._handleKeyUp=(e=>{const{keyCode:t}=e;this._preventDefaultKeysSet.has(t)&&e.preventDefault(),this._pressedKeysSet.delete(t)}).bind(this)}isPressed(...e){for(const t of e)if(this._pressedKeysSet.has(n[t]))return!0;return!1}preventDefault(e){this._preventDefaultKeysSet.add(n[e])}enableDefault(e){this._preventDefaultKeysSet.delete(n[e])}activate(){this._activated||(this._pressedKeysSet.clear(),document.addEventListener("keydown",this._handleKeyDown),document.addEventListener("keyup",this._handleKeyUp),this._activated=!0)}deactivate(){this._activated&&(this._pressedKeysSet.clear(),document.removeEventListener("keydown",this._handleKeyDown),document.removeEventListener("keyup",this._handleKeyUp),this._activated=!1)}},i={Left:0,Middle:1,Right:2};const o=new class{constructor(){this._pressedButtonsSet=new Set,this._activated=!1,this._deltaX=0,this._deltaY=0;this._activated=!1,this._handleMouseDown=(e=>{this._pressedButtonsSet.add(e.button)}).bind(this),this._handleMouseUp=(e=>{this._pressedButtonsSet.delete(e.button)}).bind(this),this._handleMouseMove=(e=>{this._deltaX+=e.movementX||e.mozMovementX||e.webkitMovementX||0,this._deltaY+=e.movementY||e.mozMovementY||e.webkitMovementY||0}).bind(this)}activate(){this._activated||(this._pressedButtonsSet.clear(),document.addEventListener("mousedown",this._handleMouseDown),document.addEventListener("mouseup",this._handleMouseUp),document.addEventListener("mousemove",this._handleMouseMove),this._activated=!0)}deactivate(){this._activated&&(this._pressedButtonsSet.clear(),document.removeEventListener("mousedown",this._handleMouseDown),document.removeEventListener("mouseup",this._handleMouseUp),document.removeEventListener("mousemove",this._handleMouseMove),this._activated=!1)}isButtonPressed(e){return this._pressedButtonsSet.has(i[e])}deltaX(){return this._deltaX}deltaY(){return this._deltaY}resetDelta(){this._deltaX=0,this._deltaY=0}},a=["requestPointerLock","mozRequestPointerLock","webkitRequestPointerLock"],s=["exitPointerLock","mozExitPointerLock","webkitExitPointerLock"],d=["pointerLockElement","mozPointerLockElement","webkitPointerLockElement"],f=[{methodName:"onpointerlockchange",propertyName:"pointerlockchange"},{methodName:"onmozpointerlockchange",propertyName:"mozpointerlockchange"},{methodName:"onwebkitpointerlockchange",propertyName:"webkitpointerlockchange"}],c=[{methodName:"onpointerlockerror",propertyName:"pointerlockerror"},{methodName:"onmozpointerlockerror",propertyName:"mozpointerlockerror"},{methodName:"onwebkitpointerlockerror",propertyName:"webkitpointerlockerror"}];const h=new class{constructor(){this._onLockChangeCallbacks=[],this._onLockErrorCallbacks=[],this._timeSinceLastLockChange=0,this._isInitialized=!1}_initialize(){if(this._isInitialized)return;this._isInitialized=!0;const e=()=>{this._timeSinceLastLockChange=Date.now(),this._onLockChangeCallbacks.forEach((e=>e()))},t=e=>{this._timeSinceLastLockChange=Date.now(),this._onLockErrorCallbacks.forEach((t=>t(e)))};for(const t of f)if(t.methodName in document){document.addEventListener(t.propertyName,e,!1);break}for(const e of c)if(e.methodName in document){document.addEventListener(e.propertyName,t,!1);break}}canBePointerLocked(e){for(const t of a)if(t in e)return!0;return!1}isPointerLocked(e){for(const t of d)if(t in document)return document[t]===e;return!1}requestPointerLock(t){return e(this,void 0,void 0,(function*(){if(this.isPointerLocked(t))return{success:!1,message:"element already locked"};if(this._initialize(),this._timeSinceLastLockChange>0){const e=(Date.now()-this._timeSinceLastLockChange)/1e3;if(e<1.1)return{success:!1,message:`request for lock was too early, time to wait: ${e.toFixed(2)}sec`}}this._timeSinceLastLockChange=Date.now();for(const e of a)if(e in t){const n={unadjustedMovement:!1};try{yield t[e](n)}catch(e){return{success:!1,message:`request for lock was too early, time to wait: ${((Date.now()-this._timeSinceLastLockChange)/1e3).toFixed(2)}sec`}}return this._timeSinceLastLockChange=Date.now(),{success:!0,message:"request for lock done"}}return{success:!1,message:"unsupported request for lock"}}))}allowPointerLockedOnClickEvent(t){if(t===this._latestRequestHtmlElement)return;this._latestRequestHtmlElement=t;const n=()=>e(this,void 0,void 0,(function*(){t.removeEventListener("click",n);const e=yield this.requestPointerLock(t);this._latestRequestHtmlElement=void 0,e.success||this.allowPointerLockedOnClickEvent(t)}));t.addEventListener("click",n)}exitPointerLock(){for(const e of s)if(e in document){document[e]();break}}addOnLockChange(e){this._onLockChangeCallbacks.push(e)}removeOnLockChange(e){const t=this._onLockChangeCallbacks.indexOf(e);t<0||this._onLockChangeCallbacks.splice(t,1)}addOnLockError(e){this._onLockErrorCallbacks.push(e)}removeOnLockError(e){const t=this._onLockErrorCallbacks.indexOf(e);t<0||this._onLockErrorCallbacks.splice(t,1)}};class l{constructor(e,t,n){this.createdAt=Date.now(),this.deltaX=0,this.deltaY=0,this.id=e,this.positionX=t,this.positionY=n}resetDelta(){this.deltaX=0,this.deltaY=0}}const u=new class{constructor(){this._pressedButtonsSet=new Set,this._activated=!1,this._allTouchData=[];this._activated=!1,this._handleTouchStart=(e=>{e.preventDefault();for(let t=0;t<e.changedTouches.length;++t){const n=e.changedTouches[t];this._allTouchData.push(new l(n.identifier,n.pageX,n.pageY))}}).bind(this),this._handleTouchEnd=(e=>{e.preventDefault();for(let t=0;t<e.changedTouches.length;++t){const n=e.changedTouches[t],r=this._allTouchData.findIndex((e=>e.id===n.identifier));r<0||this._allTouchData.splice(r,1)}}).bind(this),this._handleTouchMove=(e=>{e.preventDefault();for(let t=0;t<e.changedTouches.length;++t){const n=e.changedTouches[t],r=this._allTouchData.findIndex((e=>e.id===n.identifier));if(r<0)continue;const i=this._allTouchData[r];i.deltaX+=n.pageX-i.positionX,i.deltaY+=n.pageY-i.positionY,i.positionX=n.pageX,i.positionY=n.pageY}}).bind(this)}activate(){this._activated||(this._pressedButtonsSet.clear(),document.addEventListener("touchstart",this._handleTouchStart),document.addEventListener("touchend",this._handleTouchEnd),document.addEventListener("touchmove",this._handleTouchMove),this._activated=!0)}deactivate(){this._activated&&(this._pressedButtonsSet.clear(),document.removeEventListener("touchstart",this._handleTouchStart),document.removeEventListener("touchend",this._handleTouchEnd),document.removeEventListener("touchmove",this._handleTouchMove),this._activated=!1)}getTouchData(){return this._allTouchData}resetDeltas(){this._allTouchData.forEach((e=>e.resetDelta()))}};var _=1e-6,p="undefined"!=typeof Float32Array?Float32Array:Array;function m(){var e=new p(16);return p!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function x(e,t,n){var r=t[0],i=t[1],o=t[2],a=t[3],s=t[4],d=t[5],f=t[6],c=t[7],h=t[8],l=t[9],u=t[10],_=t[11],p=t[12],m=t[13],g=t[14],x=t[15],v=n[0],b=n[1],y=n[2],T=n[3];return e[0]=v*r+b*s+y*h+T*p,e[1]=v*i+b*d+y*l+T*m,e[2]=v*o+b*f+y*u+T*g,e[3]=v*a+b*c+y*_+T*x,v=n[4],b=n[5],y=n[6],T=n[7],e[4]=v*r+b*s+y*h+T*p,e[5]=v*i+b*d+y*l+T*m,e[6]=v*o+b*f+y*u+T*g,e[7]=v*a+b*c+y*_+T*x,v=n[8],b=n[9],y=n[10],T=n[11],e[8]=v*r+b*s+y*h+T*p,e[9]=v*i+b*d+y*l+T*m,e[10]=v*o+b*f+y*u+T*g,e[11]=v*a+b*c+y*_+T*x,v=n[12],b=n[13],y=n[14],T=n[15],e[12]=v*r+b*s+y*h+T*p,e[13]=v*i+b*d+y*l+T*m,e[14]=v*o+b*f+y*u+T*g,e[15]=v*a+b*c+y*_+T*x,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var v=function(e,t,n,r,i){var o,a=1/Math.tan(t/2);return e[0]=a/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(o=1/(r-i),e[10]=(i+r)*o,e[14]=2*i*r*o):(e[10]=-1,e[14]=-2*r),e};var b=function(e,t,n,r,i,o,a){var s=1/(t-n),d=1/(r-i),f=1/(o-a);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*d,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*s,e[13]=(i+r)*d,e[14]=(a+o)*f,e[15]=1,e};function y(e,t,n,r){var i,o,a,s,d,f,c,h,l,u,p=t[0],m=t[1],x=t[2],v=r[0],b=r[1],y=r[2],T=n[0],E=n[1],w=n[2];return Math.abs(p-T)<_&&Math.abs(m-E)<_&&Math.abs(x-w)<_?g(e):(c=p-T,h=m-E,l=x-w,i=b*(l*=u=1/Math.hypot(c,h,l))-y*(h*=u),o=y*(c*=u)-v*l,a=v*h-b*c,(u=Math.hypot(i,o,a))?(i*=u=1/u,o*=u,a*=u):(i=0,o=0,a=0),s=h*a-l*o,d=l*i-c*a,f=c*o-h*i,(u=Math.hypot(s,d,f))?(s*=u=1/u,d*=u,f*=u):(s=0,d=0,f=0),e[0]=i,e[1]=s,e[2]=c,e[3]=0,e[4]=o,e[5]=d,e[6]=h,e[7]=0,e[8]=a,e[9]=f,e[10]=l,e[11]=0,e[12]=-(i*p+o*m+a*x),e[13]=-(s*p+d*m+f*x),e[14]=-(c*p+h*m+l*x),e[15]=1,e)}function T(){var e=new p(3);return p!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function E(e){var t=new p(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function w(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function S(e,t,n){var r=new p(3);return r[0]=e,r[1]=t,r[2]=n,r}function R(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function D(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function k(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function C(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function P(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function L(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e}function M(e,t){var n=t[0],r=t[1],i=t[2],o=n*n+r*r+i*i;return o>0&&(o=1/Math.sqrt(o)),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e}function A(e,t,n){var r=t[0],i=t[1],o=t[2],a=n[0],s=n[1],d=n[2];return e[0]=i*d-o*s,e[1]=o*a-r*d,e[2]=r*s-i*a,e}function I(e,t,n,r){var i=t[0],o=t[1],a=t[2];return e[0]=i+r*(n[0]-i),e[1]=o+r*(n[1]-o),e[2]=a+r*(n[2]-a),e}var F=k;function B(){var e=new p(4);return p!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}T(),function(){var e,t=(e=new p(4),p!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e)}();var z;T(),S(1,0,0),S(0,1,0),B(),B(),z=new p(9),p!=Float32Array&&(z[1]=0,z[2]=0,z[3]=0,z[5]=0,z[6]=0,z[7]=0),z[0]=1,z[4]=1,z[8]=1,function(){var e=function(){var e=new p(2);return p!=Float32Array&&(e[0]=0,e[1]=0),e}()}();const U={X:0,Y:1,Z:2};class N{constructor(e){this._isActivated=!1,this._theta=0,this._phi=0,this._touchWasActive=!1,this._touchStartTime=0,this._touchMoveForward=!1,this._position=S(0,0,0),this._target=S(0,0,0),this._forwardAxis=S(1,0,0),this._leftAxis=S(0,0,1),this._upAxis=S(0,1,0),this._mouseSensibility=e.mouseSensibility,this._keyboardSensibility=e.keyboardSensibility,this._touchSensibility=e.touchSensibility,this._movingSpeed=e.movingSpeed,R(this._position,e.position),this._axisIndices=[e.coordinates?U[e.coordinates[0]]:U.X,e.coordinates?U[e.coordinates[1]]:U.Y,e.coordinates?U[e.coordinates[2]]:U.Z],this._theta=e.theta,this._phi=e.phi}isActivated(){return this._isActivated}update(e){let t=!1,n=!1,i=!1,a=!1,s=0,d=0;const f=Math.PI/180;s-=o.deltaX()*this._mouseSensibility*f,d-=o.deltaY()*this._mouseSensibility*f;const c=u.getTouchData().length>0;if(c){if(!this._touchWasActive){const e=Date.now();(e-this._touchStartTime)/1e3<.25?this._touchMoveForward=!0:this._touchStartTime=e}const e=u.getTouchData()[0];s-=e.deltaX*this._touchSensibility*f,d-=e.deltaY*this._touchSensibility*f}else this._touchMoveForward=!1;this._touchWasActive=c,this._touchMoveForward&&(t=!0);const h=this._movingSpeed*e,l=S(0,0,0);P(l,this._forwardAxis,h);const _=S(0,0,0);P(_,this._leftAxis,h),r.isPressed("Z","W")&&(t=!0),r.isPressed("S")&&(n=!0),r.isPressed("A","Q")&&(i=!0),r.isPressed("D")&&(a=!0);const p=this._keyboardSensibility*e;r.isPressed("ArrowUp")?d+=p:r.isPressed("ArrowDown")&&(d-=p),r.isPressed("ArrowLeft")?s+=p:r.isPressed("ArrowRight")&&(s-=p),this._theta+=s,this._phi+=d;const m=.5*Math.PI,g=.95*m;this._phi=Math.min(Math.max(this._phi,-g),+g);const x=Math.cos(this._theta),v=Math.sin(this._theta),[b,y,T]=this._axisIndices,E=Math.cos(this._phi+m);this._upAxis[b]=E*x,this._upAxis[y]=E*v,this._upAxis[T]=Math.sin(this._phi+m);const w=Math.cos(this._phi);this._forwardAxis[b]=w*x,this._forwardAxis[y]=w*v,this._forwardAxis[T]=Math.sin(this._phi),A(this._leftAxis,this._upAxis,this._forwardAxis),t?D(this._position,this._position,l):n&&F(this._position,this._position,l),i?D(this._position,this._position,_):a&&F(this._position,this._position,_),D(this._target,this._position,this._forwardAxis)}getPosition(){return this._position}setPosition(e){R(this._position,e)}getTarget(){return this._target}getUpAxis(){return this._upAxis}getTheta(){return this._theta}getPhi(){return this._phi}getTouchMoveForward(){return this._touchMoveForward}}class O{static initialize(e){if(O._gl=e.getContext("webgl2",{alpha:!1,antialias:!1,depth:!0,failIfMajorPerformanceCaveat:!1,powerPreference:"high-performance",premultipliedAlpha:!0,preserveDrawingBuffer:!0,stencil:!1}),!O._gl)throw new Error("could not create webgl context")}static getContext(){if(!O._gl)throw new Error("webgl context not initialized");return O._gl}}O._gl=null;class X{constructor(){this._textureObject=null}initialize(e=[]){if(this._textureObject)throw new Error("data texture already initialized");const t=O.getContext();this._textureObject=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this._textureObject),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),this.update(e)}update(e){if(!this._textureObject)throw new Error("data texture not initialized");const t=O.getContext();t.bindTexture(t.TEXTURE_2D,this._textureObject);const n=new Float32Array(e),r=t.R32F,i=e.length,o=t.RED,a=t.FLOAT;t.texImage2D(t.TEXTURE_2D,0,r,i,1,0,o,a,n)}bind(){if(!this._textureObject)throw new Error("data texture not initialized");const e=O.getContext();e.bindTexture(e.TEXTURE_2D,this._textureObject)}}class V{constructor(){const e=O.getContext();this._frameBuffer=e.createFramebuffer()}attachTexture(e){const t=O.getContext();t.bindFramebuffer(t.FRAMEBUFFER,this._frameBuffer);t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e.getRawObject(),0)}bind(){const e=O.getContext();e.bindFramebuffer(e.FRAMEBUFFER,this._frameBuffer)}static unbind(){const e=O.getContext();e.bindFramebuffer(e.FRAMEBUFFER,null)}}var H;!function(e){let t,n;e.BytesPerPixel=4,function(e){e[e.float=0]="float",e[e.vec2f=1]="vec2f",e[e.vec3f=2]="vec3f",e[e.vec4f=3]="vec4f",e[e.mat3f=4]="mat3f",e[e.mat4f=5]="mat4f"}(t=e.AttributeType||(e.AttributeType={})),function(e){e[e.lines=0]="lines",e[e.triangles=1]="triangles",e[e.triangleStrip=2]="triangleStrip"}(n=e.PrimitiveType||(e.PrimitiveType={}));e.Geometry=class{constructor(r,i){this._primitiveStart=0,this._primitiveCount=0,this._instanceCount=0,this._isInstanced=!1;const o=O.getContext();if(0===i.vbos.length)throw new Error("empty vbo defintion");for(const e of i.vbos){if(0===e.attrs.length)throw new Error("empty vbo attribute defintion");for(const t of e.attrs)if(!r.hasAttribute(t.name))throw new Error(`attribute not found, name="${t.name}"`)}switch(this._def=i,i.primitiveType){case n.lines:this._primitiveType=o.LINES;break;case n.triangles:this._primitiveType=o.TRIANGLES;break;case n.triangleStrip:this._primitiveType=o.TRIANGLE_STRIP;break;default:throw new Error("primitive type not found")}const a=o.createVertexArray();if(!a)throw new Error("fail o create a vao unit");this._vao=a,o.bindVertexArray(this._vao),this._vbos=[];for(const n of this._def.vbos){const i=o.createBuffer();if(!i)throw new Error("fail o create a vbo unit");this._vbos.push(i),o.bindBuffer(o.ARRAY_BUFFER,i);let a=n.stride||0;if(!a){for(const e of n.attrs)switch(e.type){case t.float:a+=1;break;case t.vec2f:a+=2;break;case t.vec3f:a+=3;break;case t.vec4f:a+=4;break;case t.mat3f:a+=9;break;case t.mat4f:a+=16}a*=e.BytesPerPixel}for(const i of n.attrs){let s=1,d=1;switch(i.type){case t.float:s=1,d=1;break;case t.vec2f:s=2,d=1;break;case t.vec3f:s=3,d=1;break;case t.vec4f:s=4,d=1;break;case t.mat3f:s=3,d=3;break;case t.mat4f:s=4,d=4}const f=r.getAttribute(i.name);for(let t=0;t<d;++t){const r=f+t,d=(i.index+t*s)*e.BytesPerPixel;o.enableVertexAttribArray(r),o.vertexAttribPointer(r,s,o.FLOAT,!1,a,d),!0===n.instanced&&(o.vertexAttribDivisor(r,1),this._isInstanced=!0)}}}o.bindVertexArray(null)}dispose(){const e=O.getContext();for(const t of this._vbos)e.deleteBuffer(t);e.deleteVertexArray(this._vao)}updateBuffer(e,t,n=!1){if(e<0||e>=this._vbos.length)throw new Error("no buffer avaialble to tha index");const r=O.getContext(),i=this._vbos[e],o=t instanceof Float32Array?t:new Float32Array(t),a=n?r.DYNAMIC_DRAW:r.STATIC_DRAW;r.bindBuffer(r.ARRAY_BUFFER,i),r.bufferData(r.ARRAY_BUFFER,o,a),r.bindBuffer(r.ARRAY_BUFFER,null)}render(){if(0==this._primitiveCount||this._isInstanced&&0==this._instanceCount)return;const e=O.getContext();e.bindVertexArray(this._vao),!0===this._isInstanced?e.drawArraysInstanced(this._primitiveType,this._primitiveStart,this._primitiveCount,this._instanceCount):e.drawArrays(this._primitiveType,this._primitiveStart,this._primitiveCount),e.bindVertexArray(null)}setPrimitiveStart(e){this._primitiveStart=e}setPrimitiveCount(e){this._primitiveCount=e}setInstancedCount(e){this._instanceCount=e}}}(H||(H={}));class W{constructor(e){this._attributes=new Map,this._uniforms=new Map;const t=O.getContext(),n=this._getShader(e.vertexSrc,t.VERTEX_SHADER),r=this._getShader(e.fragmentSrc,t.FRAGMENT_SHADER),i=t.createProgram();if(!i)throw new Error("could not create a shader program");if(t.attachShader(i,n),t.attachShader(i,r),t.linkProgram(i),t.deleteShader(n),t.deleteShader(r),!t.getProgramParameter(i,t.LINK_STATUS)){const e=t.getProgramInfoLog(i);throw new Error("Failed to initialized shaders, Error linking:"+e)}this._program=i,this.bind(),this._getAttributes(e.attributes),this._getUniforms(e.uniforms),W.unbind()}bind(){O.getContext().useProgram(this._program)}static unbind(){O.getContext().useProgram(null)}hasAttribute(e){return this._attributes.has(e)}getAttribute(e){const t=this._attributes.get(e);if(void 0===t)throw new Error(`attribute not found: ${e}`);return t}getUniform(e){const t=this._uniforms.get(e);if(void 0===t)throw new Error(`uniform not found: ${e}`);return t}setInteger1Uniform(e,t){O.getContext().uniform1i(this.getUniform(e),t)}setInteger2Uniform(e,t,n){O.getContext().uniform2i(this.getUniform(e),t,n)}setInteger3Uniform(e,t,n,r){O.getContext().uniform3i(this.getUniform(e),t,n,r)}setFloat1Uniform(e,t){O.getContext().uniform1f(this.getUniform(e),t)}setFloat2Uniform(e,t,n){O.getContext().uniform2f(this.getUniform(e),t,n)}setFloat3Uniform(e,t,n,r){O.getContext().uniform3f(this.getUniform(e),t,n,r)}setMatrix4Uniform(e,t){O.getContext().uniformMatrix4fv(this.getUniform(e),!1,t)}_getAttributes(e){const t=O.getContext();for(let n=0;n<e.length;++n){const r=t.getAttribLocation(this._program,e[n]);if(r<0)throw new Error(`attribute not found => ${e[n]}`);this._attributes.set(e[n],r)}}_getUniforms(e){const t=O.getContext();for(let n=0;n<e.length;++n){const r=t.getUniformLocation(this._program,e[n]);if(null===r)throw new Error(`uniform not found => ${e[n]}`);this._uniforms.set(e[n],r)}}_getShader(e,t){const n=O.getContext(),r=n.createShader(t);if(!r)throw new Error("could not create a shader");if(n.shaderSource(r,e),n.compileShader(r),!n.getShaderParameter(r,n.COMPILE_STATUS)){let e=n.getShaderInfoLog(r);throw e||(e="failed to compile a shader"),new Error(e)}return r}}class G{constructor(){this._width=0,this._height=0,this._texture=null}allocate(e,t,n=!1){if(this._texture)throw new Error("texture already initialized");const r=O.getContext();this._texture=r.createTexture(),r.bindTexture(r.TEXTURE_2D,this._texture),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE);const i=n?r.NEAREST:r.LINEAR;r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,i),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,i);const o=r.RGBA,a=r.RGBA,s=r.UNSIGNED_BYTE;r.texImage2D(r.TEXTURE_2D,0,o,e,t,0,a,s,null)}resize(e,t){if(!this._texture)throw new Error("texture not initialized");const n=O.getContext();n.bindTexture(n.TEXTURE_2D,this._texture);const r=n.RGBA,i=n.RGBA,o=n.UNSIGNED_BYTE;n.texImage2D(n.TEXTURE_2D,0,r,e,t,0,i,o,null)}load(t,n=!1){return e(this,void 0,void 0,(function*(){const e=O.getContext();this._texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this._texture);const r=e.RGBA,i=e.RGBA,o=e.UNSIGNED_BYTE,a=new Uint8Array([0,0,255,255]);return e.texImage2D(e.TEXTURE_2D,0,r,1,1,0,i,o,a),e.bindTexture(e.TEXTURE_2D,null),new Promise(((a,s)=>{const d=new Image;d.onerror=s,d.onload=()=>{this._width=d.width,this._height=d.height,e.bindTexture(e.TEXTURE_2D,this._texture),e.texImage2D(e.TEXTURE_2D,0,r,i,o,d),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE);const t=n?e.NEAREST:e.LINEAR;e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,t),e.bindTexture(e.TEXTURE_2D,null),a()},d.src=t}))}))}loadFromMemory(e,t,n,r=!1){const i=O.getContext();this._texture=i.createTexture(),i.bindTexture(i.TEXTURE_2D,this._texture),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE);const o=r?i.NEAREST:i.LINEAR;i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,o),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,o);const a=i.RGBA,s=i.RGBA,d=i.UNSIGNED_BYTE;i.texImage2D(i.TEXTURE_2D,0,a,e,t,0,s,d,n),i.bindTexture(i.TEXTURE_2D,null)}getWidth(){if(!this._texture)throw new Error("texture not initialized");return this._width}getHeight(){if(!this._texture)throw new Error("texture not initialized");return this._height}bind(){if(!this._texture)throw new Error("texture not initialized");const e=O.getContext();e.bindTexture(e.TEXTURE_2D,this._texture)}static unbind(){const e=O.getContext();e.bindTexture(e.TEXTURE_2D,null)}getRawObject(){if(!this._texture)throw new Error("texture not initialized");return this._texture}}const j="\n#version 300 es\n\nprecision highp float;\n\nuniform mat4 u_composedMatrix;\n\nin vec2 a_vertex_position;\nin vec2 a_vertex_texCoord;\nin vec3 a_offset_position;\nin vec2 a_offset_texCoord;\nin vec3 a_offset_color;\nin float a_offset_scale;\n\nout vec2 v_texCoord;\nflat out vec3 v_color;\n\nvoid main(void)\n{\n  vec3 position = vec3(a_vertex_position, 0.0) * a_offset_scale + a_offset_position;\n\n  gl_Position = u_composedMatrix * vec4(position, 1.0);\n\n  v_texCoord = a_vertex_texCoord + a_offset_texCoord;\n  v_color = a_offset_color;\n}\n".trim(),Y="\n#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D u_texture;\n\nin vec2 v_texCoord;\nflat in vec3 v_color;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  vec4 textureColor = texture(u_texture, v_texCoord);\n  if (textureColor.a < 0.5)\n  {\n    discard;\n  }\n  else\n  {\n    o_color = vec4(v_color, textureColor.a);\n  }\n}\n\n".trim(),q="\n#version 300 es\n\nprecision highp float;\n\nuniform mat4 u_composedMatrix;\n\nin vec3 a_vertex_position;\nin vec4 a_vertex_color;\n\nflat out vec4 v_color;\n\nvoid main(void)\n{\n  gl_Position = u_composedMatrix * vec4(a_vertex_position, 1.0);\n\n  v_color = a_vertex_color;\n}\n".trim(),K="\n#version 300 es\n\nprecision lowp float;\n\nflat in vec4 v_color;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  o_color = v_color;\n}\n\n".trim(),$="\n\n#version 300 es\n\nprecision highp float;\n\nin vec2 a_vertexPosition;\nin vec3 a_plotPosition;\n\nout vec3 v_position;\n\nvoid main(void)\n{\n  gl_Position = vec4(a_vertexPosition, 1.0, 1.0);\n\n  v_position = a_plotPosition;\n}\n\n".trim(),Z='\n\n#version 300 es\n\nprecision highp float;\n\n//\n//\n//\n\nuniform vec3        u_cameraEye;\n\n//\n\nuniform sampler2D   u_sceneTextureData;\nuniform int         u_sceneTextureSize;\n\nuniform int       u_spheresStart;\nuniform int       u_spheresStop;\n\nuniform int       u_boxesStart;\nuniform int       u_boxesStop;\n\nuniform int       u_trianglesStart;\nuniform int       u_trianglesStop;\n\n//\n\nuniform sampler2D   u_lightsTextureData;\n\nuniform int       u_sunLightsStart;\nuniform int       u_sunLightsStop;\n\nuniform int       u_spotLightsStart;\nuniform int       u_spotLightsStop;\n\n//\n//\n//\n\nin vec3  v_position;\n\nout vec4 o_color;\n\n//\n\nconst float     g_ambiantLight = 0.2;\n\nconst int       g_reflectionMax = 2;\nconst bool      g_shadowsEnabled = true;\n\nconst vec3      g_backgroundColor = vec3(0.4);\n\n//\n\nstruct RayValues\n{\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct RayResult\n{\n  bool hasHit;\n  float depth;\n  vec3 position;\n  vec3 normal;\n  vec4 color;\n  float reflection;\n  bool lightEnabled;\n};\n\n//\n//\n//\n//\n//\n\nfloat getSceneDataByIndex(int index)\n{\n  return texelFetch(u_sceneTextureData, ivec2(index, 0), 0).x;\n}\n\nvec3 getSceneVec3ByIndex(int index)\n{\n  return vec3(\n    texelFetch(u_sceneTextureData, ivec2(index + 0, 0), 0).x,\n    texelFetch(u_sceneTextureData, ivec2(index + 1, 0), 0).x,\n    texelFetch(u_sceneTextureData, ivec2(index + 2, 0), 0).x\n  );\n}\n\nfloat getLightsDataByIndex(int index)\n{\n  return texelFetch(u_lightsTextureData, ivec2(index, 0), 0).x;\n}\n\nvec3 getLightsVec3ByIndex(int index)\n{\n  return vec3(\n    texelFetch(u_lightsTextureData, ivec2(index + 0, 0), 0).x,\n    texelFetch(u_lightsTextureData, ivec2(index + 1, 0), 0).x,\n    texelFetch(u_lightsTextureData, ivec2(index + 2, 0), 0).x\n  );\n}\n\n//\n//\n//\n//\n//\n\nbool intersectSphere(RayValues ray, float radius, out float distance, out vec3 normal)\n{\n  float nearValue = 0.001; // TODO: hardcoded\n  float farValue = 100.0; // TODO: hardcoded\n\n  float b = dot(ray.origin, ray.direction);\n  float c = dot(ray.origin, ray.origin) - radius * radius;\n  float h = b * b - c;\n  if (h < 0.0)\n    return false;\n\n  h = sqrt(h);\n\n  float d1 = -b - h;\n  if (d1 >= nearValue && d1 <= farValue)\n  {\n    normal = normalize(ray.origin + ray.direction * d1);\n    distance = d1;\n    return true;\n  }\n\n  float d2 = -b + h;\n  if (d2 >= nearValue && d2 <= farValue)\n  {\n    normal = normalize(ray.origin + ray.direction * d2);\n    distance = d2;\n    return true;\n  }\n\n  return false;\n}\n\nbool intersectBox(RayValues ray, vec3 boxSize, out float distance, out vec3 normal)\n{\n  float nearValue = 0.001; // TODO: hardcoded\n  float farValue = 100.0; // TODO: hardcoded\n\n  //\n  //\n  // sad hack: fix a shadow related bug\n\n  if (ray.direction.x == 0.0) ray.direction.x = -1e-8;\n  if (ray.direction.y == 0.0) ray.direction.y = -1e-8;\n  if (ray.direction.z == 0.0) ray.direction.z = -1e-8;\n\n  // sad hack: fix a shadow related bug\n  //\n  //\n\n  vec3 m = sign(ray.direction) / max(abs(ray.direction), 1e-8);\n  vec3 n = m * ray.origin;\n  vec3 k = abs(m) * boxSize;\n\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n\n  float tN = max(max(t1.x, t1.y), t1.z);\n  float tF = min(min(t2.x, t2.y), t2.z);\n\n  if (tN > tF || tF <= 0.0)\n    return false;\n\n  if (tN >= nearValue && tN <= farValue)\n  {\n    normal = normalize(-sign(ray.direction) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz));\n    distance = tN;\n    return true;\n  }\n\n  if (tF >= nearValue && tF <= farValue)\n  {\n    normal = normalize(-sign(ray.direction) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz));\n    distance = tF;\n    return true;\n  }\n\n  return false;\n}\n\nbool intersectTriangle(RayValues ray, vec3 v0, vec3 v1, vec3 v2, out float distance, out vec3 normal)\n{\n  float nearValue = 0.001; // TODO: hardcoded\n  float farValue = 100.0; // TODO: hardcoded\n\n  vec3 v1v0 = v1 - v0;\n  vec3 v2v0 = v2 - v0;\n  vec3 rov0 = ray.origin - v0;\n\n  vec3 n = cross(v1v0, v2v0);\n  vec3 q = cross(rov0, ray.direction);\n  float d = 1.0 / dot(ray.direction, n);\n  float u = d * dot(-q, v2v0);\n  float v = d * dot(q, v1v0);\n  float t = d * dot(-n, rov0);\n\n  if (u < 0.0 || v < 0.0 || (u + v) > 1.0 || t < nearValue || t > farValue)\n    return false;\n\n  normal = normalize(-n);\n  distance = t;\n  return true;\n}\n\n// float intersectPlane(RayValues ray, vec3 normal, float offset)\n// {\n//     return -(dot(ray.origin, normal) + offset) / dot(ray.direction, normal);\n// }\n\n// float intersectPlane2(RayValues ray, vec3 normal, float offset)\n// {\n//     float nearValue = 0.001; // TODO: hardcoded\n//     float farValue = 1000.0; // TODO: hardcoded\n\n//     float a = dot(ray.direction, normal);\n//     float d = -(dot(ray.origin, normal) + offset) / a;\n\n//     if (a > 0.0 || d < nearValue || d > farValue)\n//         return -1.0;\n\n//     return d;\n// }\n\n// float diskIntersect(RayValues ray, vec3 center, vec3 normal, float radius)\n// {\n//     vec3  o = ray.origin - center;\n//     float t = -dot(normal, o) / dot(ray.direction, normal);\n//     vec3  q = o + ray.direction * t;\n//     return (dot(q, q) < radius * radius) ? t : -1.0;\n// }\n\n//\n//\n//\n//\n//\n\nbool intersectScene(RayValues ray, out RayResult result, bool shadowMode)\n{\n  float bestDistance = -1.0;\n\n  result.hasHit = false;\n\n  if (u_sceneTextureSize <= 0)\n    return false;\n\n  RayValues tmpRay;\n  vec3 normal;\n\n  for (int index = u_spheresStart; index < u_spheresStop; index += 11)\n  {\n    bool shadowEnabled = (getSceneDataByIndex(index + 8) != 0.0);\n\n    if (shadowMode && !shadowEnabled)\n      continue;\n\n    tmpRay.origin = ray.origin;\n    tmpRay.direction = ray.direction;\n\n    vec3 center = getSceneVec3ByIndex(index + 0);\n\n    tmpRay.origin -= center;\n\n    float radius = getSceneDataByIndex(index + 3);\n\n    float currDistance = 0.0;\n    if (!intersectSphere(tmpRay, radius, currDistance, normal) || (bestDistance > 0.0 && currDistance > bestDistance))\n      continue;\n\n    bestDistance = currDistance;\n\n    result.hasHit = true;\n    result.depth = bestDistance;\n    result.position = ray.origin + bestDistance * ray.direction;\n    result.normal = normal;\n\n    bool chessboardMaterial = (getSceneDataByIndex(index + 10) != 0.0);\n\n    if (chessboardMaterial)\n    {\n      // vec3 txPos = (txx * vec4(result.position - center, 1.0)).xyz;\n      vec3 txPos = (vec4(result.position - center, 1.0)).xyz;\n      // chessboard color effect\n      if (fract(txPos.x * 0.2) > 0.5 == fract(txPos.z * 0.2) > 0.5 == fract(txPos.y * 0.2) > 0.5)\n      {\n        result.color = vec4(1.0);\n        result.reflection = 0.3;\n      }\n      else\n      {\n        result.color = vec4(0.0, 0.4, 0.45, 1.0);\n        result.reflection = 0.0;\n      }\n    }\n    else\n    {\n      vec3 color = getSceneVec3ByIndex(index + 4);\n\n      float reflection = getSceneDataByIndex(index + 7);\n\n      result.color = vec4(color, 0.5);\n      result.reflection = reflection;\n    }\n\n    bool lightEnabled = (getSceneDataByIndex(index + 9) != 0.0);\n    result.lightEnabled = lightEnabled;\n\n    // if (shadowMode)\n    //     return true;\n  }\n\n  for (int index = u_boxesStart; index < u_boxesStop; index += 26)\n  {\n    bool shadowEnabled = (getSceneDataByIndex(index + 23) != 0.0);\n\n    if (shadowMode && !shadowEnabled)\n      continue;\n\n    tmpRay.origin = ray.origin;\n    tmpRay.direction = ray.direction;\n\n    mat4 normalTransformationMatrix = mat4(\n      getSceneDataByIndex(index + 0),\n      getSceneDataByIndex(index + 1),\n      getSceneDataByIndex(index + 2),\n      getSceneDataByIndex(index + 3),\n\n      getSceneDataByIndex(index + 4),\n      getSceneDataByIndex(index + 5),\n      getSceneDataByIndex(index + 6),\n      getSceneDataByIndex(index + 7),\n\n      getSceneDataByIndex(index + 8),\n      getSceneDataByIndex(index + 9),\n      getSceneDataByIndex(index + 10),\n      getSceneDataByIndex(index + 11),\n\n      getSceneDataByIndex(index + 12),\n      getSceneDataByIndex(index + 13),\n      getSceneDataByIndex(index + 14),\n      getSceneDataByIndex(index + 15)\n    );\n\n    vec3 boxSize = getSceneVec3ByIndex(index + 16);\n\n    mat4 inversedTransformationMatrix = inverse(normalTransformationMatrix);\n\n    // convert ray from world space to box space\n    tmpRay.origin = (inversedTransformationMatrix * vec4(tmpRay.origin, 1.0)).xyz;\n    tmpRay.direction = (inversedTransformationMatrix * vec4(tmpRay.direction, 0.0)).xyz;\n\n    float currDistance = 0.0;\n    if (!intersectBox(tmpRay, boxSize, currDistance, normal) || (bestDistance > 0.0 && currDistance > bestDistance))\n      continue;\n\n    bestDistance = currDistance;\n\n    // convert normal from box space to world space\n    normal = (normalTransformationMatrix * vec4(normal, 0.0)).xyz;\n\n    result.hasHit = true;\n    result.depth = bestDistance;\n    result.position = ray.origin + bestDistance * ray.direction;\n    result.normal = normal;\n\n    bool chessboardMaterial = (getSceneDataByIndex(index + 25) != 0.0);\n\n    if (chessboardMaterial)\n    {\n      vec3 txPos = (inversedTransformationMatrix * vec4(result.position, 1.0)).xyz;\n\n      // chessboard color effect\n      if (fract(txPos.x * 0.2) > 0.5 == fract(txPos.z * 0.2) > 0.5 == fract(txPos.y * 0.2) > 0.5)\n      {\n        result.color = vec4(1.0);\n        result.reflection = 0.3;\n      }\n      else\n      {\n        result.color = vec4(0.0, 0.4, 0.45, 1.0);\n        result.reflection = 0.0;\n      }\n    }\n    else\n    {\n      vec3 color = getSceneVec3ByIndex(index + 19);\n\n      float reflection = getSceneDataByIndex(index + 22);\n\n      result.color = vec4(color, 1.0);\n      result.reflection = reflection;\n    }\n\n    bool lightEnabled = (getSceneDataByIndex(index + 24) != 0.0);\n    result.lightEnabled = lightEnabled;\n\n    // if (shadowMode)\n    //     return true;\n  }\n\n  for (int index = u_trianglesStart; index < u_trianglesStop; index += 15)\n  {\n    bool shadowEnabled = (getSceneDataByIndex(index + 13) != 0.0);\n\n    if (shadowMode && !shadowEnabled)\n      continue;\n\n    tmpRay.origin = ray.origin;\n    tmpRay.direction = ray.direction;\n\n    vec3 v0 = getSceneVec3ByIndex(index + 0);\n    vec3 v1 = getSceneVec3ByIndex(index + 3);\n    vec3 v2 = getSceneVec3ByIndex(index + 6);\n\n    float currDistance = 0.0;\n    if (!intersectTriangle(tmpRay, v0, v1, v2, currDistance, normal) || (bestDistance > 0.0 && currDistance > bestDistance))\n      continue;\n\n    bestDistance = currDistance;\n\n    result.hasHit = true;\n    result.depth = bestDistance;\n    result.position = ray.origin + bestDistance * ray.direction;\n    result.normal = normal;\n\n    vec3 color = getSceneVec3ByIndex(index + 9);\n\n    float reflection = getSceneDataByIndex(index + 12);\n\n    result.color = vec4(color, 1.0);\n    result.reflection = reflection;\n\n    bool lightEnabled = (getSceneDataByIndex(index + 14) != 0.0);\n    result.lightEnabled = lightEnabled;\n\n    // if (shadowMode)\n    //     return true;\n  }\n\n  { // plane test\n\n    // vec3 planeNormal = normalize(vec3(0.0, 0.0, 1.0));\n    // float val = intersectPlane(tmpRay, planeNormal, 35.0/4.0*3.0);\n\n    // vec3 planeNormal = normalize(vec3(0.0, 0.0, 1.0));\n    // float val = intersectPlane(tmpRay, planeNormal, 0.0);\n\n    // vec3 planeNormal = normalize(vec3(0.0, 0.0, 1.0));\n    // float val = intersectPlane(tmpRay, planeNormal, 10.0);\n\n    // if (val > 0.0 && (bestDistance <= 0.0 || val < bestDistance))\n    // {\n    //     result.hasHit = true;\n    //     result.depth = val;\n    //     result.position = ray.origin + val * ray.direction;\n    //     result.normal = vec3(planeNormal);\n    //     result.color = vec4(1.0, 1.0, 1.0, 1.0);\n    //     result.reflection = 0.0;\n    //     result.lightEnabled = true;\n    // }\n\n  } // plane test\n\n  return result.hasHit;\n}\n\nfloat lightAt(vec3 impactPosition, vec3 impactNormal, vec3 viewer)\n{\n  float bestIntensity = 0.0;\n\n  for (int index = u_sunLightsStart; index < u_sunLightsStop; index += 4)\n  {\n    if (!g_shadowsEnabled)\n      continue;\n\n    vec3 lightDir = getLightsVec3ByIndex(index + 0);\n    float localIntensity = getLightsDataByIndex(index + 3);\n\n    float coef = localIntensity;\n    lightDir = normalize(lightDir);\n\n    // is the light blocked by an object?\n    RayResult result;\n    if (intersectScene(RayValues(impactPosition, lightDir), result, true))\n      continue; // an object is shadowing this light: ignore this light\n\n    //\n    //\n    //\n\n    float intensity = 0.0;\n    vec3 reflection = reflect(-lightDir, impactNormal);\n    intensity += 0.6 * pow(max(dot(reflection, viewer), 0.0), 30.0);\n    intensity += 1.0 * dot(lightDir, impactNormal);\n\n    intensity *= coef;\n\n    if (bestIntensity < intensity)\n      bestIntensity = intensity;\n  }\n\n  for (int index = u_spotLightsStart; index < u_spotLightsStop; index += 5)\n  {\n    vec3 lightDir = vec3(1.0);\n    float coef = 1.0;\n\n    // spot light\n\n    vec3 lightPos = getLightsVec3ByIndex(index + 0);\n    float lightRadius = getLightsDataByIndex(index + 3);\n\n    vec3 lightToImpactVec3 = lightPos - impactPosition;\n\n    // is too far?\n    float lightToImpactDistance = length(lightToImpactVec3);\n    if (lightToImpactDistance > lightRadius)\n      continue; // too far\n\n    lightDir.x = lightToImpactVec3.x / lightToImpactDistance; // normalize\n    lightDir.y = lightToImpactVec3.y / lightToImpactDistance; // normalize\n    lightDir.z = lightToImpactVec3.z / lightToImpactDistance; // normalize\n\n    float localIntensity = getLightsDataByIndex(index + 4);\n\n    coef = localIntensity * (1.0 - lightToImpactDistance / lightRadius);\n\n    if (!g_shadowsEnabled)\n      continue;\n\n    // is the light blocked by an object?\n    RayResult result;\n    if (intersectScene(RayValues(impactPosition, lightDir), result, true))\n    {\n      // avoid "opposite shadows"\n      if (result.depth < lightToImpactDistance)\n        continue; // shadow\n    }\n\n    //\n    //\n    //\n\n    float intensity = 0.0;\n    vec3 reflection = reflect(-lightDir, impactNormal);\n    intensity += 0.6 * pow(max(dot(reflection, viewer), 0.0), 30.0);\n    intensity += 1.0 * dot(lightDir, impactNormal);\n\n    intensity *= coef;\n\n    if (bestIntensity < intensity)\n      bestIntensity = intensity;\n  }\n\n  return max(g_ambiantLight, bestIntensity);\n}\n\nvoid main()\n{\n  //\n  //\n  // initial ray\n\n  vec3 rayDir = normalize(v_position - u_cameraEye); // camera direction\n  vec3 finalPixelColor = g_backgroundColor;\n\n  RayValues currRay = RayValues(u_cameraEye, rayDir);\n  RayResult result;\n\n  result.position = u_cameraEye;\n  result.reflection = 1.0;\n  result.lightEnabled = true;\n\n  float lastReflection = 1.0;\n\n  const int maxIteration = g_reflectionMax;\n  for (int iterationLeft = maxIteration; iterationLeft >= 0; --iterationLeft)\n  {\n    if (result.reflection <= 0.05)\n      break;\n\n    bool mustStop = false;\n\n    currRay = RayValues(result.position, rayDir);\n\n    result.hasHit = intersectScene(currRay, result, false);\n\n    vec3 tmpColor = g_backgroundColor;\n\n    if (result.hasHit)\n    {\n      float lightIntensity = 1.0;\n\n      if (result.lightEnabled)\n      {\n        lightIntensity = lightAt(result.position, result.normal, -currRay.direction);\n\n        if (lightIntensity <= 0.0)\n        {\n          // not lighted\n          mustStop = true;\n        }\n      }\n\n      tmpColor = result.color.xyz * lightIntensity;\n    }\n\n    finalPixelColor = finalPixelColor * (1.0 - lastReflection) + tmpColor * lastReflection;\n\n    if (mustStop || !result.hasHit)\n    {\n      break;\n    }\n\n    lastReflection *= result.reflection;\n\n    rayDir = reflect(rayDir, result.normal);\n  }\n\n  o_color = vec4(finalPixelColor, 1.0);\n}\n\n'.trim(),Q="\n\n#version 300 es\n\nprecision highp float;\n\nin vec2 a_vertexPosition;\nin vec2 a_vertexTextureCoord;\n\nout vec2 v_textureCoord;\n\nvoid main(void)\n{\n  v_textureCoord = a_vertexTextureCoord;\n\n  gl_Position = vec4(a_vertexPosition, 1.0, 1.0);\n}\n\n".trim(),J="\n\n#version 300 es\n\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec2 u_step;\n\nin vec2 v_textureCoord;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  // gl_FragColor = texture(u_texture, v_textureCoord);\n\n  float total = 0.0;\n  vec4 accumulated = vec4(0.0);\n\n  //\n\n  if (v_textureCoord.x - u_step.x > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x - u_step.x, v_textureCoord.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.x + u_step.x > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x + u_step.x, v_textureCoord.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.y - u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x, v_textureCoord.y - u_step.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.y + u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x, v_textureCoord.y + u_step.y));\n    total += 1.0;\n  }\n\n  //\n\n  if (v_textureCoord.x - u_step.x > 0.0 && v_textureCoord.y - u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x - u_step.x, v_textureCoord.y - u_step.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.x + u_step.x > 0.0 && v_textureCoord.y - u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x + u_step.x, v_textureCoord.y - u_step.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.x - u_step.x > 0.0 && v_textureCoord.y + u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x - u_step.x, v_textureCoord.y + u_step.y));\n    total += 1.0;\n  }\n\n  if (v_textureCoord.x + u_step.x > 0.0 && v_textureCoord.y + u_step.y > 0.0)\n  {\n    accumulated += texture(u_texture, vec2(v_textureCoord.x + u_step.x, v_textureCoord.y + u_step.y));\n    total += 1.0;\n  }\n\n  //\n\n  if (total > 0.0)\n    o_color = accumulated / total;\n  else\n    o_color = vec4(1.0, 0.0, 0.0, 1.0); // warning\n}\n\n".trim(),ee=e=>e*Math.PI/180;class te{constructor(e,t){this._resolutionCoef=1,this._antiAliasing=!1,this._spheres=[],this._boxes=[],this._triangles=[],this._sunLights=[],this._spotLights=[],this._renderWidth=this._canvasWidth=e,this._renderHeight=this._canvasHeight=t,this._rayTracerShaderProgram=new W({vertexSrc:$,fragmentSrc:Z,attributes:["a_vertexPosition","a_plotPosition"],uniforms:["u_cameraEye","u_sceneTextureData","u_sceneTextureSize","u_spheresStart","u_spheresStop","u_boxesStart","u_boxesStop","u_trianglesStart","u_trianglesStop","u_lightsTextureData","u_sunLightsStart","u_sunLightsStop","u_spotLightsStart","u_spotLightsStop"]}),this._textureShaderProgram=new W({vertexSrc:Q,fragmentSrc:J,attributes:["a_vertexPosition","a_vertexTextureCoord"],uniforms:["u_texture","u_step"]}),this._finalTexture=new G,this._finalTexture.allocate(this._renderWidth,this._renderHeight,!0),this._frameBuffer=new V,this._frameBuffer.attachTexture(this._finalTexture);this._rayTracerGeometry=new H.Geometry(this._rayTracerShaderProgram,{vbos:[{attrs:[{name:"a_vertexPosition",type:H.AttributeType.vec2f,index:0}],stride:8,instanced:!1},{attrs:[{name:"a_plotPosition",type:H.AttributeType.vec3f,index:0}],stride:12,instanced:!1}],primitiveType:H.PrimitiveType.triangleStrip});const n=[];n.push(1,1),n.push(-1,1),n.push(1,-1),n.push(-1,-1),this._rayTracerGeometry.updateBuffer(0,n,!1),this._rayTracerGeometry.setPrimitiveStart(0),this._rayTracerGeometry.setPrimitiveCount(4),this._screenGeometry=new H.Geometry(this._textureShaderProgram,{vbos:[{attrs:[{name:"a_vertexPosition",type:H.AttributeType.vec2f,index:0},{name:"a_vertexTextureCoord",type:H.AttributeType.vec2f,index:2}],stride:16,instanced:!1}],primitiveType:H.PrimitiveType.triangleStrip});const r=[];r.push(1,1,1,1),r.push(-1,1,0,1),r.push(1,-1,1,0),r.push(-1,-1,0,0),this._screenGeometry.updateBuffer(0,r,!1),this._screenGeometry.setPrimitiveStart(0),this._screenGeometry.setPrimitiveCount(4),this._sceneDataTexture=new X,this._sceneDataTexture.initialize(),this._lightsDataTexture=new X,this._lightsDataTexture.initialize(),this._camera={position:S(0,0,0),target:S(1.5,1.5,1.5),up:S(0,1,0)}}pushSphere(e,t,n,r,i,o=!0,a=!0){if(t<=0)throw new Error("invalid sphere radius");if(r<0||r>1)throw new Error("invalid sphere reflection");this._spheres.push({position:[e[0],e[1],e[2]],radius:t,color:[n[0],n[1],n[2]],reflection:r,chessboard:i,shadowEnabled:o,lightEnabled:a})}pushBox(e,t,n,r,i,o,a,s,d=!0,f=!0){if(i[0]<=0||i[1]<=0||i[2]<=0)throw new Error("invalid box size");if(a<0||a>1)throw new Error("invalid box reflection");const c=m();g(c),function(e,t,n){var r,i,o,a,s,d,f,c,h,l,u,_,p=n[0],m=n[1],g=n[2];t===e?(e[12]=t[0]*p+t[4]*m+t[8]*g+t[12],e[13]=t[1]*p+t[5]*m+t[9]*g+t[13],e[14]=t[2]*p+t[6]*m+t[10]*g+t[14],e[15]=t[3]*p+t[7]*m+t[11]*g+t[15]):(r=t[0],i=t[1],o=t[2],a=t[3],s=t[4],d=t[5],f=t[6],c=t[7],h=t[8],l=t[9],u=t[10],_=t[11],e[0]=r,e[1]=i,e[2]=o,e[3]=a,e[4]=s,e[5]=d,e[6]=f,e[7]=c,e[8]=h,e[9]=l,e[10]=u,e[11]=_,e[12]=r*p+s*m+h*g+t[12],e[13]=i*p+d*m+l*g+t[13],e[14]=o*p+f*m+u*g+t[14],e[15]=a*p+c*m+_*g+t[15])}(c,c,e),function(e,t,n){var r=Math.sin(n),i=Math.cos(n),o=t[0],a=t[1],s=t[2],d=t[3],f=t[8],c=t[9],h=t[10],l=t[11];t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*i-f*r,e[1]=a*i-c*r,e[2]=s*i-h*r,e[3]=d*i-l*r,e[8]=o*r+f*i,e[9]=a*r+c*i,e[10]=s*r+h*i,e[11]=d*r+l*i}(c,c,n),function(e,t,n){var r=Math.sin(n),i=Math.cos(n),o=t[0],a=t[1],s=t[2],d=t[3],f=t[4],c=t[5],h=t[6],l=t[7];t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*i+f*r,e[1]=a*i+c*r,e[2]=s*i+h*r,e[3]=d*i+l*r,e[4]=f*i-o*r,e[5]=c*i-a*r,e[6]=h*i-s*r,e[7]=l*i-d*r}(c,c,r),function(e,t,n){var r=Math.sin(n),i=Math.cos(n),o=t[4],a=t[5],s=t[6],d=t[7],f=t[8],c=t[9],h=t[10],l=t[11];t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=o*i+f*r,e[5]=a*i+c*r,e[6]=s*i+h*r,e[7]=d*i+l*r,e[8]=f*i-o*r,e[9]=c*i-a*r,e[10]=h*i-s*r,e[11]=l*i-d*r}(c,c,t),this._boxes.push({matrix:c,boxSize:E(i),color:E(o),reflection:a,chessboard:s,shadowEnabled:d,lightEnabled:f})}pushTriangle({v0:e,v1:t,v2:n,color:r,reflection:i,shadowEnabled:o,lightEnabled:a}){if(i<0||i>1)throw new Error("invalid triangle reflection");this._triangles.push({v0:E(e),v1:E(t),v2:E(n),color:E(r),reflection:i,shadowEnabled:o,lightEnabled:a})}pushSunLight(e,t){if(t<=0)throw new Error("intensity cannot be 0");if(0===w(e))throw new Error("direction cannot be 0");const n=M(E(e),e);this._sunLights.push({direction:n,intensity:t})}pushSpotLight(e,t,n){if(t<=0)throw new Error("intensity cannot be 0");if(n<=0)throw new Error("radius cannot be <= 0");this._spotLights.push({position:E(e),intensity:t,radius:n})}lookAt(e,t,n){R(this._camera.position,e);let r=F(T(),t,e);r=M(r,r),r=D(r,e,r),R(this._camera.target,r);const i=M(T(),n);R(this._camera.up,i)}render(){const e=O.getContext(),t=this._computeCameraFarCorners();this._rayTracerGeometry.updateBuffer(1,t,!0);const n=Math.floor(this._renderWidth),r=Math.floor(this._renderHeight);this._frameBuffer.bind(),e.viewport(0,0,n,r),e.clear(e.COLOR_BUFFER_BIT);{const t=this._rayTracerShaderProgram;t.bind(),t.setFloat3Uniform("u_cameraEye",this._camera.position[0],this._camera.position[1],this._camera.position[2]);{const n=[];t.setInteger1Uniform("u_spheresStart",0);for(const e of this._spheres)n.push(e.position[0],e.position[1],e.position[2]),n.push(e.radius),n.push(e.color[0],e.color[1],e.color[2]),n.push(e.reflection),n.push(e.shadowEnabled?1:0),n.push(e.lightEnabled?1:0),n.push(e.chessboard?1:0);t.setInteger1Uniform("u_spheresStop",n.length),t.setInteger1Uniform("u_boxesStart",n.length);for(const e of this._boxes){for(let t=0;t<16;++t)n.push(e.matrix[t]);n.push(e.boxSize[0],e.boxSize[1],e.boxSize[2]),n.push(e.color[0],e.color[1],e.color[2]),n.push(e.reflection),n.push(e.shadowEnabled?1:0),n.push(e.lightEnabled?1:0),n.push(e.chessboard?1:0)}t.setInteger1Uniform("u_boxesStop",n.length),t.setInteger1Uniform("u_trianglesStart",n.length);for(const e of this._triangles)n.push(e.v0[0],e.v0[1],e.v0[2]),n.push(e.v1[0],e.v1[1],e.v1[2]),n.push(e.v2[0],e.v2[1],e.v2[2]),n.push(e.color[0],e.color[1],e.color[2]),n.push(e.reflection),n.push(e.shadowEnabled?1:0),n.push(e.lightEnabled?1:0);t.setInteger1Uniform("u_trianglesStop",n.length),e.activeTexture(e.TEXTURE0+0),this._sceneDataTexture.bind(),this._sceneDataTexture.update(n),t.setInteger1Uniform("u_sceneTextureData",0),t.setInteger1Uniform("u_sceneTextureSize",n.length)}{const n=[];t.setInteger1Uniform("u_sunLightsStart",0);for(const e of this._sunLights)n.push(e.direction[0],e.direction[1],e.direction[2]),n.push(e.intensity);t.setInteger1Uniform("u_sunLightsStop",n.length),t.setInteger1Uniform("u_spotLightsStart",n.length);for(const e of this._spotLights)n.push(e.position[0],e.position[1],e.position[2]),n.push(e.radius),n.push(e.intensity);t.setInteger1Uniform("u_spotLightsStop",n.length),e.activeTexture(e.TEXTURE0+1),this._lightsDataTexture.bind(),this._lightsDataTexture.update(n),t.setInteger1Uniform("u_lightsTextureData",1)}this._rayTracerGeometry.render()}V.unbind(),e.viewport(0,0,this._canvasWidth,this._canvasHeight),e.clear(e.COLOR_BUFFER_BIT);{const t=this._textureShaderProgram;if(t.bind(),t.setInteger1Uniform("u_texture",0),e.activeTexture(e.TEXTURE0+0),this._finalTexture.bind(),t.getUniform("u_step"),this._antiAliasing){const e=.005*(1-this._renderWidth/this._canvasWidth),n=.005*(1-this._renderHeight/this._canvasHeight);t.setFloat2Uniform("u_step",e,n)}else t.setFloat2Uniform("u_step",0,0);this._screenGeometry.render(),G.unbind()}W.unbind()}reset(){this._sunLights.length=0,this._spotLights.length=0,this._spheres.length=0,this._boxes.length=0,this._triangles.length=0}setResolutionCoef(e){e===this._resolutionCoef||e<=0||e>1||(this._resolutionCoef=e,this._renderWidth=Math.floor(this._canvasWidth*this._resolutionCoef),this._renderHeight=Math.floor(this._canvasHeight*this._resolutionCoef),this._finalTexture.resize(this._renderWidth,this._renderHeight))}getResolutionCoef(){return this._resolutionCoef}setAntiAliasing(e){this._antiAliasing=e}getAntiAliasing(){return this._antiAliasing}getCurrentSize(){return[this._renderWidth,this._renderHeight]}_computeCameraFarCorners(){const e=F(T(),this._camera.target,this._camera.position),t=A(T(),e,this._camera.up),n=A(T(),t,e),r=ee(35),i=1*Math.cos(r)/Math.sin(r),o=C(T(),e,S(i,i,i)),a=D(T(),this._camera.position,o),s=this._canvasWidth/this._canvasHeight,d=C(T(),t,S(s,s,s)),f=D(T(),a,n),c=k(T(),a,n),h=k(T(),f,d),l=k(T(),c,d),u=D(T(),f,d),_=D(T(),c,d);return[u[0],u[1],u[2],h[0],h[1],h[2],_[0],_[1],_[2],l[0],l[1],l[2]]}get canvasWidth(){return this._canvasWidth}get canvasHeight(){return this._canvasHeight}get renderWidth(){return this._renderWidth}get renderHeight(){return this._renderHeight}get camera(){return this._camera}get spheres(){return this._spheres}get boxes(){return this._boxes}get triangles(){return this._triangles}get sunLights(){return this._sunLights}get spotLights(){return this._spotLights}}class ne{constructor(e,t){this._vertices=[];const n=Object.assign(Object.assign({},t),{primitiveType:H.PrimitiveType.lines});this._geometry=new H.Geometry(e,n)}pushLine(e,t,n){var r,i;this._vertices.push(e[0],e[1],e[2]),this._vertices.push(n[0],n[1],n[2],null!==(r=n[3])&&void 0!==r?r:1),this._vertices.push(t[0],t[1],t[2]),this._vertices.push(n[0],n[1],n[2],null!==(i=n[3])&&void 0!==i?i:1)}canRender(){return this._vertices.length>0}flush(){0!==this._vertices.length&&(this._geometry.updateBuffer(0,this._vertices,!0),this._geometry.setPrimitiveCount(this._vertices.length/7),this._geometry.render(),this._vertices.length=0)}}class re{constructor(e,t){this._vertices=[];const n=Object.assign(Object.assign({},t),{primitiveType:H.PrimitiveType.triangles});this._geometry=new H.Geometry(e,n)}pushLine(e,t,n,r){const i=t[0]-e[0],o=t[1]-e[1],a=Math.atan2(o,i)+.5*Math.PI,s=Math.cos(a)*n*.5,d=Math.sin(a)*n*.5,f=[[e[0]-s,e[1]-d,e[2]],[e[0]+s,e[1]+d,e[2]],[t[0]-s,t[1]-d,t[2]],[t[0]+s,t[1]+d,t[2]]];[0,3,2,0,1,3].forEach((e=>{var t;const n=f[e];this._vertices.push(n[0],n[1],n[2]),this._vertices.push(r[0],r[1],r[2],null!==(t=r[3])&&void 0!==t?t:1)}))}pushRotatedLine(e,t,n,r,i){this.pushLine([e[0]-n*Math.cos(t),e[1]-n*Math.sin(t),e[2]],[e[0]+n*Math.cos(t),e[1]+n*Math.sin(t),e[2]],r,i)}pushOriginBoundRectangle(e,t,n){const r=[e[0]+t[0],e[1]+t[1]],i=[[e[0],e[1],e[2]],[r[0],e[1],e[2]],[r[0],r[1],e[2]],[e[0],r[1],e[2]]];[0,3,2,0,1,2].forEach((e=>{var t;const r=i[e];this._vertices.push(r[0],r[1],r[2]),this._vertices.push(n[0],n[1],n[2],null!==(t=n[3])&&void 0!==t?t:1)}))}pushCenteredRectangle(e,t,n){const r=[e[0]-.5*t[0],e[1]-.5*t[1],e[2]];this.pushOriginBoundRectangle(r,t,n)}canRender(){return this._vertices.length>0}flush(){0!==this._vertices.length&&(this._geometry.updateBuffer(0,this._vertices,!0),this._geometry.setPrimitiveCount(this._vertices.length/7),this._geometry.render(),this._vertices.length=0)}}class ie{constructor(){this._shader=new W({vertexSrc:q,fragmentSrc:K,attributes:["a_vertex_position","a_vertex_color"],uniforms:["u_composedMatrix"]});const e={vbos:[{attrs:[{name:"a_vertex_position",type:H.AttributeType.vec3f,index:0},{name:"a_vertex_color",type:H.AttributeType.vec4f,index:3}],stride:28,instanced:!1}],primitiveType:H.PrimitiveType.lines};this._wireFramesStackRenderer=new ne(this._shader,e),this._trianglesStackRenderer=new re(this._shader,e)}pushLine(e,t,n){this._wireFramesStackRenderer.pushLine(e,t,n)}pushThickLine(e,t,n,r){this._trianglesStackRenderer.pushLine(e,t,n,r)}pushRotatedLine(e,t,n,r,i){this._trianglesStackRenderer.pushRotatedLine(e,t,n,r,i)}pushOriginBoundRectangle(e,t,n){this._trianglesStackRenderer.pushOriginBoundRectangle(e,t,n)}pushCenteredRectangle(e,t,n){this._trianglesStackRenderer.pushCenteredRectangle(e,t,n)}flush(e){(this._wireFramesStackRenderer.canRender()||this._trianglesStackRenderer.canRender())&&(this._shader.bind(),this._shader.setMatrix4Uniform("u_composedMatrix",e),this._wireFramesStackRenderer.flush(),this._trianglesStackRenderer.flush())}}const oe="7e7e28fd03fd07fe04fe0aff02ff7e4dfd0cfd03fd07fe04fe0aff02ff1afc0dfd10fc08fc0ffe55ff15fb0bfd03fd07fe04fe08f707fd04ff07fe02fe0cfd0ffd0cfd0aff03fe03ff0afe44fe15fb0bfd03fd04f204f607fd03fe07fe02fe0cfd0efd0efd0aff02fe02ff0bfe43fd15fb0cfe03fe05f204fe01ff02ff0afd02fd07fe02fe0bfd0efd10fd0afa0cfe42fd16fb1bfe04fe07fe01ff02ff0efd09fc1cfd12fd09fa0cfe41fd17fb1bfe04fe07f70bfd0afc04ff17fd12fd06f405f616f61cfd19fd1cfe04fe08f709fd0bfb02fe17fd12fd06f405f616f61bfd1afd1cfe04fe0aff02ff01fe08fd0bfe02fa17fd12fd09fa0cfe3efd37f207ff02ff01fe07fd02fd07fe03fc19fd10fd0afa0cfe3dfd38f204f607fe03fd07fe03fd1bfd0efd0aff02fe02ff0bfe0cfd1dfd0dfd1dfd1cfe04fe07f708ff04fd07fe02fb1bfd0cfd0aff03fe03ff0afe0cfd1dfd0cfd1efd1cfe04fe0aff02ff1afb02fe1bfc08fc0ffe1cfd1dfd0bfd1ffd1cfe04fe0aff02ff7afd7e7e7e7e7e7e0efd17fd10fc0af80bfe0bf909f90dfd08f609fb08f506f808f82cfd19fd0df807fd04fd0afe0afd03fd07fd03fd0bfc08fd0ffd0bfd05fd05fd04fd06fd04fd2afd1bfd0bfc02fc06fd03fc09fd0afd04fd06fd04fd09fb08fd0efd0cfd05fd05fd04fd06fd04fd09fd0cfd0efd1dfd0afe05fd06fd02fb06fa11fd0dfd08fe01fd08fd0dfd0dfd05fd05fd04fd06fd04fd09fd0cfd0dfd0af409fd10fd06fd02fb06fa10fd0dfd08fe02fd08fd0dfd15fd05fb02fd06fd04fd09fd0cfd0cfd0bf40afd0efd07fd01fe01fd09fd0ffd0bfb08fe03fd08f808f70efd08fa08f626fd23fd0cfd08fd01fe01fd09fd0efd0cfb08f606f707f60cfd09fa09f726fd23fd0bfd09fb02fd09fd0dfd10fd07f60cfc06fd04fd0bfd08fd02fb0dfd09fd0cfd0cfd0bf40afd0cfd09fb02fd09fd0cfd12fd0bfd0ffd06fd04fd0afd09fd04fd0dfd09fd0cfd0dfd0af409fd19fc03fd09fd0bfd03fd06fd04fd0bfd08fd04fd06fd04fd09fd0afd04fd0cfd0afd0cfd0efd1dfd1afd04fd09fd0afd04fd06fd03fd0cfd08fd03fd07fd04fd09fd0afd04fd0bfd19fd10fd1bfd0ffd0af807f707f607f90bf907f909f80afd0bf809fb2efd19fd10fd7e51fd17fd11fd7e7e7e7e13f87e78fd05fd08fc09f709f907f808f606f608f907fd03fd07f90df905fc03fd06fb0bfd05fd05fd05fd08fb08fd05fd07fa09fd03fd07fd03fd07fd02fd08fd04fe07fd04fe07fd03fd06fd03fd09fd11fd08fd03fd07fd0cfc03fc05fd05fd07fd01fd07fd05fd06fd02fd08fd03fd06fd04fd07fd03fd07fd05ff07fd05ff06fd04fd06fd03fd09fd11fd08fd02fd08fd0cfb01fb05fc04fd06fd03fd06fd05fd05fd04fd07fd03fd06fd0efd03fd07fd0dfd0cfd04fd06fd03fd09fd11fd08fd01fd09fd0cf505fb03fd05fd05fd05fd02fa05fd04fd07fd03fd06fd0efd03fd07fd03fe08fd03fe07fd0dfd03fd09fd11fd08fa0afd0cf505fa02fd05fd05fd05fd02fa05fd04fd07f807fd0efd03fd07f808f807fd0df709fd11fd08fb0bfd0cfd01fd01fd05fd01fd01fd05fd05fd05fd02fa05fd04fd07f807fd0efd03fd07f808f807fd0df709fd11fd08fb0bfd0cfd02ff02fd05fd02fa05fd05fd05fd02fa05f607fd03fd06fd0efd03fd07fd03fe08fd03fe07fd02fb06fd03fd09fd0bfd03fd08fa0afd0cfd05fd05fd03fb05fd05fd05fd0dfd04fd07fd03fd06fd0efd03fd07fd0dfd0cfd04fd06fd03fd09fd0bfd03fd08fd01fd09fd05ff06fd05fd05fd04fc05fd05fd05fd0dfd04fd07fd03fd06fd04fd07fd03fd07fd05ff07fd0cfd04fd06fd03fd09fd0bfd03fd08fd02fd08fd04fe06fd05fd05fd05fd06fd03fd06fd0dfd04fd07fd03fd07fd03fd07fd02fd08fd04fe07fd0dfd03fd06fd03fd09fd0bfd03fd08fd03fd07fd03fd06fd05fd05fd05fd07fd01fd07fd0dfd04fd06f709f907f808f606fb0df806fd03fd07f90af908fc03fd06f606fd05fd05fd05fd08fb0af87e7e7e7e7e7e7e68fe1af70afb08f708f807f505fd03fd07fd03fd07fd05fd05fd03fd07fd03fd07f608f907ff11f90afc1afd03fd07fc01fc07fd03fd06fd04fd06fe02fd02fe05fd03fd07fd03fd07fd05fd05fd03fd07fd03fd07fd04fd08fd0bfe14fd09fa19fd03fd07fd03fd07fd03fd06fd04fd06ff03fd03ff05fd03fd07fd03fd07fd05fd05fd03fd07fd03fd07fe05fd08fd0bfd13fd08fd02fd18fd03fd06fd05fd06fd03fd06fd04fd0afd09fd03fd07fd03fd07fd05fd06fd01fd08fd03fd07ff05fd09fd0cfd12fd07fd04fd17fd03fd06fd05fd06fd03fd06fd11fd09fd03fd07fd03fd07fd05fd07fb09fd03fd0cfd0afd0dfd11fd28f807fd05fd06f808f90cfd09fd03fd07fd03fd07fd02ff02fd08fd0bfd01fd0cfd0bfd0efd10fd28f807fd05fd06f809f90bfd09fd03fd07fd03fd07fd02ff02fd08fd0cfb0cfd0cfd0ffd0ffd28fd0cfd03fb06fd02fd0efd0afd09fd03fd07fd03fd07fd02ff02fd07fb0cfd0cfd0dfd10fd0efd28fd0cfd02fa06fd03fd06fd04fd0afd09fd03fd07fd03fd08f707fd01fd0bfd0bfd05ff08fd11fd0dfd28fd0df707fd03fd06fd04fd0afd09fd03fd08fd01fd09fc01fc06fd03fd0afd0afd05fe08fd12fd0cfd28fd0df707fd03fd06fd04fd0afd09fd03fd09fb0bfd01fd07fd03fd0afd0afd04fd08fd13fd0bfd27fb12fd06fc03fd07f809f908f90bfd0cfd01fd07fd03fd08f908f608f910fd06f93cfa7e54f07e72f07e7e7e7e0bfd1dfc21fb19fb18fc10fd0ffd07fc0dfa39fd1efd22fd19fd01fd18fd10fd0ffd08fd10fd3bfd1cfd22fd19fd01fd18fd10fd0ffd08fd10fd3bfd1cfd22fd19fd1cfd2dfd10fd4af909f808f909f808f90afd0cfb02fe07fd01fc08fa0cfa08fd03fd0afd09f606f809f91efd08fd03fd06fd03fd07fd03fd07fd03fd07f808fd03fd08fc02fd0afd0ffd08fd02fd0bfd09fd02ff02fd05fd03fd07fd03fd1dfd08fd03fd06fd03fd07fd03fd07fd03fd07f808fd03fd08fc02fd0afd0ffd08fd01fd0cfd09fd02ff02fd05fd03fd07fd03fd18f808fd03fd06fd0dfd03fd07f709fd0bfd03fd08fd03fd0afd0ffd08fa0dfd09fd02ff02fd05fd03fd07fd03fd17fd03fd08fd03fd06fd0dfd03fd07fd0ffd0bfd03fd08fd03fd0afd0ffd08fd01fd0cfd09fd02ff02fd05fd03fd07fd03fd17fd03fd08fd03fd06fd03fd07fd03fd07fd03fd09fd0cf808fd03fd0afd0ffd08fd02fd0bfd09fd02ff02fd05fd03fd07fd03fd17fd03fd08fd03fd06fd03fd07fd03fd07fd03fd09fd0df908fd03fd0afd0ffd08fd03fd0afd09fd02ff02fd05fd03fd07fd03fd18fb02fe06fe02fb08f909fb02fe07f908f90ffd07fc03fd07f706fd03fd07fc03fd07f706fd05fd05fd03fd08f978fd03fd27fd03fd7e4af92afa7e7e7e7e7e7e18fa09fc09fa1efe4eff6efd0dfc0dfd1cfc4cfe6efd0dfc0dfd1bfa4afd6efd0dfc0dfd1afd02fd07fe02fb07fb02fe07fc02fd08f908f707fd03fd07fd03fd07fd05fd05fd02fd09fd03fd06f80afd0efc0efd08fb03fd05fd04fd07fd03fd05fd03fd09f706fd04fe09fd0bfd03fd07fd03fd07fd05fd05fd02fd09fd03fd06fe03fd08fd24fd05fd01fd02fd05fe06fe07fd03fd05fd03fd09fc02fd06fd04fe09fd0bfd03fd07fd03fd07fd05fd06fa0afd03fd06ff03fd09fd24fd05fd02fd01fd05fe06fe07fd03fd05fd03fd09fd0dfb0cfd0bfd03fd07fd03fd07fd02ff02fd07fc0bfd03fd09fd0cfd0efc0efd07fd03fb06fe06fe07fd03fd05fd03fd09fd0ffb0afd0bfd03fd07fd03fd07fd02ff02fd07fc0bfd03fd08fd0efd0dfc0dfd19fe06fe07fd03fd05fd03fd09fd0cfe04fd09fd01fd07fd03fd08fd01fd09fc01fc07fa0bf908fd03ff0bfd0dfc0dfd19fe06fe07f807f809fd0cfe04fd09fd01fd07fd03fd09fb0bfd01fd07fd02fd0bfb08fd03fe0bfd0dfc0dfd19f607fd11fd08fb0cf90bfb09fb02fe09fd0cfd01fd07fd02fd0dfd08f80cfa09fc09fa1af607fd11fd7cfd69fb0ffb77fa",ae=[16,6],se=[1/ae[0],1/ae[1]];class de{constructor(){this._texture=new G,this._vertices=[],this._shader=new W({vertexSrc:j,fragmentSrc:Y,attributes:["a_vertex_position","a_vertex_texCoord","a_offset_position","a_offset_texCoord","a_offset_color","a_offset_scale"],uniforms:["u_composedMatrix","u_texture"]});const e={vbos:[{attrs:[{name:"a_vertex_position",type:H.AttributeType.vec2f,index:0},{name:"a_vertex_texCoord",type:H.AttributeType.vec2f,index:2}],stride:16,instanced:!1},{attrs:[{name:"a_offset_position",type:H.AttributeType.vec3f,index:0},{name:"a_offset_texCoord",type:H.AttributeType.vec2f,index:3},{name:"a_offset_color",type:H.AttributeType.vec3f,index:5},{name:"a_offset_scale",type:H.AttributeType.float,index:8}],stride:36,instanced:!0}],primitiveType:H.PrimitiveType.triangles};this._geometry=new H.Geometry(this._shader,e);const t=[{position:[.5,-.5],texCoord:[1*se[0],1*se[1]]},{position:[-.5,-.5],texCoord:[0*se[0],1*se[1]]},{position:[.5,.5],texCoord:[1*se[0],0*se[1]]},{position:[-.5,.5],texCoord:[0*se[0],0*se[1]]}],n=[1,0,2,1,3,2],r=[];for(const e of n){const n=t[e];r.push(n.position[0],n.position[1],n.texCoord[0],n.texCoord[1])}this._geometry.updateBuffer(0,r),this._geometry.setPrimitiveCount(r.length/4),this._texCoordMap=new Map([[" ",[0*se[0],0*se[1]]],["!",[1*se[0],0*se[1]]],['"',[2*se[0],0*se[1]]],["#",[3*se[0],0*se[1]]],["$",[4*se[0],0*se[1]]],["%",[5*se[0],0*se[1]]],["&",[6*se[0],0*se[1]]],["'",[7*se[0],0*se[1]]],["(",[8*se[0],0*se[1]]],[")",[9*se[0],0*se[1]]],["*",[10*se[0],0*se[1]]],["+",[11*se[0],0*se[1]]],[",",[12*se[0],0*se[1]]],["-",[13*se[0],0*se[1]]],[".",[14*se[0],0*se[1]]],["/",[15*se[0],0*se[1]]],["0",[0*se[0],1*se[1]]],["1",[1*se[0],1*se[1]]],["2",[2*se[0],1*se[1]]],["3",[3*se[0],1*se[1]]],["4",[4*se[0],1*se[1]]],["5",[5*se[0],1*se[1]]],["6",[6*se[0],1*se[1]]],["7",[7*se[0],1*se[1]]],["8",[8*se[0],1*se[1]]],["9",[9*se[0],1*se[1]]],[":",[10*se[0],1*se[1]]],[";",[11*se[0],1*se[1]]],["<",[12*se[0],1*se[1]]],["=",[13*se[0],1*se[1]]],[">",[14*se[0],1*se[1]]],["?",[15*se[0],1*se[1]]],["@",[0*se[0],2*se[1]]],["A",[1*se[0],2*se[1]]],["B",[2*se[0],2*se[1]]],["C",[3*se[0],2*se[1]]],["D",[4*se[0],2*se[1]]],["E",[5*se[0],2*se[1]]],["F",[6*se[0],2*se[1]]],["G",[7*se[0],2*se[1]]],["H",[8*se[0],2*se[1]]],["I",[9*se[0],2*se[1]]],["J",[10*se[0],2*se[1]]],["K",[11*se[0],2*se[1]]],["L",[12*se[0],2*se[1]]],["M",[13*se[0],2*se[1]]],["N",[14*se[0],2*se[1]]],["O",[15*se[0],2*se[1]]],["P",[0*se[0],3*se[1]]],["Q",[1*se[0],3*se[1]]],["R",[2*se[0],3*se[1]]],["S",[3*se[0],3*se[1]]],["T",[4*se[0],3*se[1]]],["U",[5*se[0],3*se[1]]],["V",[6*se[0],3*se[1]]],["W",[7*se[0],3*se[1]]],["X",[8*se[0],3*se[1]]],["Y",[9*se[0],3*se[1]]],["Z",[10*se[0],3*se[1]]],["[",[11*se[0],3*se[1]]],["\\",[12*se[0],3*se[1]]],["]",[13*se[0],3*se[1]]],["^",[14*se[0],3*se[1]]],["_",[15*se[0],3*se[1]]],["`",[0*se[0],4*se[1]]],["a",[1*se[0],4*se[1]]],["b",[2*se[0],4*se[1]]],["c",[3*se[0],4*se[1]]],["d",[4*se[0],4*se[1]]],["e",[5*se[0],4*se[1]]],["f",[6*se[0],4*se[1]]],["g",[7*se[0],4*se[1]]],["h",[8*se[0],4*se[1]]],["i",[9*se[0],4*se[1]]],["j",[10*se[0],4*se[1]]],["k",[11*se[0],4*se[1]]],["l",[12*se[0],4*se[1]]],["m",[13*se[0],4*se[1]]],["n",[14*se[0],4*se[1]]],["o",[15*se[0],4*se[1]]],["p",[0*se[0],5*se[1]]],["q",[1*se[0],5*se[1]]],["r",[2*se[0],5*se[1]]],["s",[3*se[0],5*se[1]]],["t",[4*se[0],5*se[1]]],["u",[5*se[0],5*se[1]]],["v",[6*se[0],5*se[1]]],["w",[7*se[0],5*se[1]]],["x",[8*se[0],5*se[1]]],["y",[9*se[0],5*se[1]]],["z",[10*se[0],5*se[1]]],["{",[11*se[0],5*se[1]]],["|",[12*se[0],5*se[1]]],["}",[13*se[0],5*se[1]]],["~",[14*se[0],5*se[1]]]]);const i=new Uint8Array(98304);{let e=0;for(let t=0;t<oe.length;t+=2){let n=parseInt(`${oe.substring(t,t+2)}000000`,16)>>24,r=0;n<0&&(n=-n,r=255);for(let t=0;t<n;++t)i[4*e+0]=r,i[4*e+1]=r,i[4*e+2]=r,i[4*e+3]=r,++e}}this._texture.loadFromMemory(256,96,i,!0)}pushText(e,t,n){const r=[t[0],t[1]];for(let i=0;i<e.length;++i){const o=e[i];"\n"!=o?(this._pushLetter(o,r,n),r[0]+=n):(r[0]=t[0],r[1]-=n)}}pushCenteredText(e,t,n){const r=[0];for(let t=0;t<e.length;++t)"\n"==e[t]?r.push(0):r[r.length-1]+=1;let i=0;const o=[0,0];o[0]=t[0]-r[i]*n*.5+.5*n,o[1]=t[1]+r.length*n*.5-.5*n;for(let a=0;a<e.length;++a){const s=e[a];"\n"==s?(i+=1,o[0]=t[0]-r[i]*n*.5+.5*n,o[1]-=n):(this._pushLetter(s,o,n),o[0]+=n)}}pushRightAlignedText(e,t,n){const r=[0];for(let t=0;t<e.length;++t)"\n"==e[t]?r.push(0):r[r.length-1]+=1;let i=0;const o=[0,0];o[0]=t[0]-r[i]*n+n,o[1]=t[1];for(let a=0;a<e.length;++a){const s=e[a];"\n"==s?(i+=1,o[0]=t[0]-r[i]*n+n,o[1]-=n):(this._pushLetter(s,o,n),o[0]+=n)}}_pushLetter(e,t,n){const r=this._texCoordMap.get(e);if(!r)throw new Error(`fail to find a letter, letter=${e}`);const i=[1,1,1],o=[0,0,0];for(let e=-1;e<=1;++e)for(let i=-1;i<=1;++i)this._vertices.push(t[0]+2*i,t[1]+2*e,-.1,r[0],r[1],o[0],o[1],o[2],n);this._vertices.push(t[0],t[1],0,r[0],r[1],i[0],i[1],i[2],n)}flush(e){this._shader.bind(),this._shader.setMatrix4Uniform("u_composedMatrix",e),this._texture.bind(),this._geometry.updateBuffer(1,this._vertices,!0),this._geometry.setInstancedCount(this._vertices.length/9),this._geometry.render(),G.unbind(),this._vertices.length=0}}class fe{constructor(e){O.initialize(e),this._rayTracerRenderer=new te(e.width,e.height),this._textRenderer=new de,this._stackRenderers=new ie}initialize(){return e(this,void 0,void 0,(function*(){const e=O.getContext();e.pixelStorei(e.UNPACK_ALIGNMENT,1),e.disable(e.DEPTH_TEST),e.disable(e.BLEND),e.disable(e.CULL_FACE),e.depthFunc(e.NEVER),e.clearColor(0,0,0,1),e.clearDepth(1),this._sceneMatrices={projection:m(),modelView:m(),composed:m()},this._hudMatrices={projection:m(),modelView:m(),composed:m()}}))}_pushWireFrameSphere(e){const t=.5257311121191336*e.radius,n=.8506508083520399*e.radius,r=[[-t,0,n],[t,0,n],[-t,0,-n],[t,0,-n],[0,n,t],[0,n,-t],[0,-n,t],[0,-n,-t],[n,t,0],[-n,t,0],[n,-t,0],[-n,-t,0]];for(let t=0;t<r.length;++t)r[t][0]+=e.position[0],r[t][1]+=e.position[1],r[t][2]+=e.position[2];const i=[[0,4,1],[0,9,4],[9,5,4],[4,5,8],[4,8,1],[8,10,1],[8,3,10],[5,3,8],[5,2,3],[2,7,3],[7,10,3],[7,6,10],[7,11,6],[11,0,6],[0,1,6],[6,1,10],[9,0,11],[9,11,2],[9,2,5],[7,2,11]];for(const t of i){const n=r[t[0]],i=r[t[1]],o=r[t[2]];this._stackRenderers.pushLine(n,i,e.color),this._stackRenderers.pushLine(i,o,e.color),this._stackRenderers.pushLine(o,n,e.color)}}_pushWireFrameBox(e){const t=[S(-e.boxSize[0],-e.boxSize[1],-e.boxSize[2]),S(+e.boxSize[0],-e.boxSize[1],-e.boxSize[2]),S(-e.boxSize[0],+e.boxSize[1],-e.boxSize[2]),S(+e.boxSize[0],+e.boxSize[1],-e.boxSize[2]),S(-e.boxSize[0],-e.boxSize[1],+e.boxSize[2]),S(+e.boxSize[0],-e.boxSize[1],+e.boxSize[2]),S(-e.boxSize[0],+e.boxSize[1],+e.boxSize[2]),S(+e.boxSize[0],+e.boxSize[1],+e.boxSize[2])],n=[];t.forEach((t=>{const r=S(0,0,0);!function(e,t,n){var r=t[0],i=t[1],o=t[2],a=n[3]*r+n[7]*i+n[11]*o+n[15];a=a||1,e[0]=(n[0]*r+n[4]*i+n[8]*o+n[12])/a,e[1]=(n[1]*r+n[5]*i+n[9]*o+n[13])/a,e[2]=(n[2]*r+n[6]*i+n[10]*o+n[14])/a}(r,t,e.matrix),n.push(r)}));[[0,1],[1,3],[3,2],[2,0],[4,5],[5,7],[7,6],[6,4],[0,4],[1,5],[3,7],[2,6]].forEach((t=>{this._stackRenderers.pushLine(n[t[0]],n[t[1]],e.color)}))}_pushWireFrameTriangle(e){this._stackRenderers.pushLine(e.v0,e.v1,e.color),this._stackRenderers.pushLine(e.v1,e.v2,e.color),this._stackRenderers.pushLine(e.v2,e.v0,e.color)}flushSceneWireFrame(){this._stackRenderers.flush(this._sceneMatrices.composed)}flushHudWireFrame(){this._stackRenderers.flush(this._hudMatrices.composed)}flushHudText(){this._textRenderer.flush(this._hudMatrices.composed)}setupDebugRenderer(){v(this._sceneMatrices.projection,ee(70),this._rayTracerRenderer.canvasWidth/this._rayTracerRenderer.canvasHeight,1,500),y(this._sceneMatrices.modelView,this._rayTracerRenderer.camera.position,this._rayTracerRenderer.camera.target,this._rayTracerRenderer.camera.up),x(this._sceneMatrices.composed,this._sceneMatrices.projection,this._sceneMatrices.modelView),this._rayTracerRenderer.spheres.forEach((e=>this._pushWireFrameSphere(e))),this._rayTracerRenderer.boxes.forEach((e=>this._pushWireFrameBox(e))),this._rayTracerRenderer.triangles.forEach((e=>this._pushWireFrameTriangle(e)))}setupHudRenderer(){const{canvasWidth:e,canvasHeight:t}=this._rayTracerRenderer;b(this._hudMatrices.projection,.5*-e,.5*+e,.5*-t,.5*+t,-200,200),m(),y(this._hudMatrices.modelView,[.5*+e,.5*+t,1],[.5*+e,.5*+t,0],[0,1,0]),x(this._hudMatrices.composed,this._hudMatrices.projection,this._hudMatrices.modelView)}get rayTracerRenderer(){return this._rayTracerRenderer}get stackRenderers(){return this._stackRenderers}get textRenderer(){return this._textRenderer}}let ce=!1;window.addEventListener("load",(()=>e(void 0,void 0,void 0,(function*(){const e=new t("loggerOutput");e.log("page loaded");window.addEventListener("error",(t=>{e?e.error(t.message):console.error(t.message),ce=!1}),!1);const n=document.getElementById("complete-loop-fpsmeter"),i=document.getElementById("update-fpsmeter"),a={main:new FPSMeter(n,{theme:"dark"}),step:new FPSMeter(i,{theme:"dark"})};a.step.toggle();const s=document.getElementById("rendering-canvas"),d=new fe(s);yield d.initialize(),e.log("renderer initialized");const f={perfAutoScaling:document.getElementById("auto-scaling-enabled"),resolution:document.getElementById("resolution"),anti_aliasing_enabled:document.getElementById("anti-aliasing-enabled"),angle_x:document.getElementById("angle-x"),angle_y:document.getElementById("angle-y"),angle_z:document.getElementById("angle-z"),angle_w:document.getElementById("angle-w"),debug_mode_enabled:document.getElementById("debug-mode-enabled")},c=t=>{d.rayTracerRenderer.setResolutionCoef(1/t);const n=d.rayTracerRenderer.getCurrentSize(),r=n[0]*n[1];e.log(`resolution changed (1/${t}) => ${n[0]}x${n[1]} (${r}px)`)};f.resolution.addEventListener("input",(e=>{const t=e.target.value;c(t)})),f.anti_aliasing_enabled.addEventListener("click",(()=>{const t=!0===f.anti_aliasing_enabled.checked;d.rayTracerRenderer.setAntiAliasing(t),e.log("Anti aliasing change: "+(!0===t?"enabled":"disabled"))}));{const e=f.resolution.value;c(e)}e.log("user interface initialized");const l=new N({coordinates:["Z","X","Y"],position:[-10,9,22],theta:.85*Math.PI,phi:.15*-Math.PI,mouseSensibility:.1,keyboardSensibility:.45*Math.PI,touchSensibility:.3,movingSpeed:10});r.activate(),h.allowPointerLockedOnClickEvent(s),h.addOnLockChange((()=>{h.isPointerLocked(s)?(e.log("The pointer lock status is now locked"),o.activate()):(e.log("The pointer lock status is now unlocked"),o.deactivate(),h.allowPointerLockedOnClickEvent(s))})),h.addOnLockError((t=>{e.log(`The pointer lock sent an error, event: "${JSON.stringify(t)}"`)}));let u=0,_=Date.now(),p=0,m=!0;let g=60;f.perfAutoScaling.addEventListener("input",(()=>{g=60,m=!0===f.perfAutoScaling.checked,e.log("Performance auto scaler change: "+(!0===m?"enabled":"disabled"))}));const x=[];let v=0;const b=[];let y=0;const T=[];for(let e=0;e<6;++e)for(let t=0;t<6;++t)T.push([[10*t-30,3*Math.random()-4,10*e-30],[Math.random(),Math.random(),Math.random()]]);ce=!0;const E=()=>{ce&&window.requestAnimationFrame(E),a.main.tick(),a.main.tickStart(),a.step.tickStart();const t=Date.now();if(u=(t-_)/1e3,_=t,!0===m)if(u>1/40){if(u=1/40,--g<0){e.log("performance auto scaling: slow framerate, scaling down resolution");const t=parseInt(f.resolution.value,10)+1;t>=1&&t<=10&&(c(t),f.resolution.value=`${t}`),g=60}}else g=60;p+=u,l.update(u),o.resetDelta();{for(let e=1;e<6;++e)for(let t=1;t<6;++t){const n=T[6*(e-1)+(t-1)],r=T[6*(e-0)+(t-1)],i=T[6*(e-1)+(t-0)],o=T[6*(e-0)+(t-0)],a=n[1],s=o[1];d.rayTracerRenderer.pushTriangle({v0:r[0],v1:n[0],v2:i[0],color:a,reflection:.1,shadowEnabled:!0,lightEnabled:!0}),d.rayTracerRenderer.pushTriangle({v0:o[0],v1:r[0],v2:i[0],color:s,reflection:.1,shadowEnabled:!0,lightEnabled:!0})}d.rayTracerRenderer.pushTriangle({v0:[5,5,1],v1:[10,10,1],v2:[10,5,1],color:[1,1,1],reflection:.1,shadowEnabled:!0,lightEnabled:!0}),d.rayTracerRenderer.pushBox([-10,0,-10],0,0,0,[1,5,1],[1,1,1],0,!1),d.rayTracerRenderer.pushBox([10,0,-10],0,0,0,[1,5,1],[1,1,1],0,!1),d.rayTracerRenderer.pushBox([-10,0,10],0,0,0,[1,5,1],[1,1,1],0,!1),d.rayTracerRenderer.pushBox([10,0,10],0,0,0,[1,5,1],[1,1,1],0,!1),d.rayTracerRenderer.pushBox([5,0,10],0,0,0,[2,.5,1],[1,0,0],0,!1),d.rayTracerRenderer.pushBox([6,.5,10],0,0,0,[.75,.25,.5],[.5,.5,.5],0,!1),d.rayTracerRenderer.pushBox([4,-.25,11.5],0,0,0,[1,.25,.5],[1,1,0],0,!1),d.rayTracerRenderer.pushBox([4,-.25,8.5],0,0,0,[1,.25,.5],[1,1,0],0,!1),d.rayTracerRenderer.pushBox([4,1,10],0,0,0,[1,.5,.25],[1,1,0],0,!1),d.rayTracerRenderer.pushSphere([15,0,15],1,[1,1,1],.5,!1),d.rayTracerRenderer.pushSphere([5,0,5],1,[1,1,1],.5,!1);const e=(f.angle_x.value/100*2-1)*Math.PI*2,t=(f.angle_y.value/100*2-1)*Math.PI*2,n=(f.angle_z.value/100*2-1)*Math.PI*2;d.rayTracerRenderer.pushBox([0,0,0],e,t,n,[2,1,.5],[1,.5,.5],.8,!0),d.rayTracerRenderer.pushBox([0,2.5,0],e,t,n,[2,1,.5],[1,.5,.5],.8,!0);for(let e=0;e<8;++e){const t=e/8;d.rayTracerRenderer.pushSphere([8*Math.sin(.5*p+2*Math.PI*t),1*Math.sin(.5*p+2*Math.PI*t)+1,8*Math.cos(.5*p+2*Math.PI*t)],.5,[t,1-t,0],0,!1)}d.rayTracerRenderer.pushSunLight([1,1,1],1);{const e=-.5*p,t=[7*Math.sin(e),4,7*Math.cos(e)],n=[7*Math.sin(e+.5*Math.PI),4,7*Math.cos(e+.5*Math.PI)];d.rayTracerRenderer.pushSphere(t,.5,[1,1,1],0,!1,!1,!1),d.rayTracerRenderer.pushSphere(n,.5,[1,1,1],0,!1,!1,!1),d.rayTracerRenderer.pushSpotLight(t,5,10),d.rayTracerRenderer.pushSpotLight(n,5,10)}if(v>0&&(v-=u),v<=0)v=3,x.push({pos:[-8,0,-5],vel:[0,0,0],life:.35,maxLife:.35}),y=0;else if(v>1&&v<3&&(y>0&&(y-=u),y<=0)){y=1/16;const e=(e,t)=>Math.random()*(t-e)+e,t=v>2&&v<3?5:1;for(let n=0;n<t;++n){const t=[2*e(-1,1),4+2*e(-1,1),2*e(-1,1)];b.push({pos:[-8,1,-5],vel:t,life:1,maxLife:1})}}for(let e=0;e<x.length;){if(x[e].life-=u,x[e].life<=0){x.splice(e,1);continue}const t=x[e].life/x[e].maxLife,n=Math.sin(t*Math.PI),r=2*n;if(r>0){const t=2*n,i=2*n;d.rayTracerRenderer.pushSphere(x[e].pos,r,[1,1,1],0,!1,!1,!1),d.rayTracerRenderer.pushSpotLight(x[e].pos,5*t,5*i)}++e}{const e=S(1,.5,0),t=S(.2,.2,.2);let n=S(0,0,0);for(let r=0;r<b.length;){if(b[r].life-=u,b[r].life<=0){b.splice(r,1);continue}const{pos:i,vel:o}=b[r];L(i,i,o,u);const a=b[r].life/b[r].maxLife,s=Math.sin(a*Math.PI);s>0&&(n=I(n,t,e,a),d.rayTracerRenderer.pushSphere(b[r].pos,s,n,0,!1,!0)),++r}}}d.rayTracerRenderer.lookAt(l.getPosition(),l.getTarget(),l.getUpAxis()),d.rayTracerRenderer.render();!0===f.debug_mode_enabled.checked&&(d.setupDebugRenderer(),d.stackRenderers.pushLine([0,0,0],[100,0,0],[1,0,0]),d.stackRenderers.pushLine([0,0,0],[0,100,0],[0,1,0]),d.stackRenderers.pushLine([0,0,0],[0,0,100],[0,0,1]),d.flushSceneWireFrame()),d.setupHudRenderer(),((e,t)=>{const n=[],i=[.2,.2,.2],o=[.2,.6,.2];n.push({center:[680,125],size:[40,40],text:"A\nQ",color:r.isPressed("A","Q")?o:i}),n.push({center:[725,125],size:[40,40],text:"S",color:r.isPressed("S")?o:i}),n.push({center:[725,170],size:[40,40],text:"W\nZ",color:r.isPressed("W","Z")?o:i}),n.push({center:[770,125],size:[40,40],text:"D",color:r.isPressed("D")?o:i}),n.push({center:[680,25],size:[40,40],lines:[{a:[15,0],b:[-8,0],thickness:6,color:[1,1,1]},{a:[0,10],b:[-12,-2],thickness:6,color:[1,1,1]},{a:[0,-10],b:[-12,2],thickness:6,color:[1,1,1]}],color:r.isPressed("ArrowLeft")?o:i}),n.push({center:[725,25],size:[40,40],lines:[{a:[0,15],b:[0,-8],thickness:6,color:[1,1,1]},{a:[10,0],b:[-2,-12],thickness:6,color:[1,1,1]},{a:[-10,0],b:[2,-12],thickness:6,color:[1,1,1]}],color:r.isPressed("ArrowDown")?o:i}),n.push({center:[725,70],size:[40,40],lines:[{a:[0,-15],b:[0,8],thickness:6,color:[1,1,1]},{a:[10,0],b:[-2,12],thickness:6,color:[1,1,1]},{a:[-10,0],b:[2,12],thickness:6,color:[1,1,1]}],color:r.isPressed("ArrowUp")?o:i}),n.push({center:[770,25],size:[40,40],lines:[{a:[-15,0],b:[8,0],thickness:6,color:[1,1,1]},{a:[0,10],b:[12,-2],thickness:6,color:[1,1,1]},{a:[0,-10],b:[12,2],thickness:6,color:[1,1,1]}],color:r.isPressed("ArrowRight")?o:i}),h.canBePointerLocked(t)?n.push({center:[550,35],size:[210,60],text:"Mouse\nSupported",color:[0,.5,0]}):n.push({center:[550,35],size:[210,60],text:"Mouse Events\nNot Supported",color:[.5,0,0]}),n.forEach((t=>{const{center:n}=t;e.stackRenderers.pushCenteredRectangle(S(n[0],n[1],-.3),t.size,[0,0,0]),e.stackRenderers.pushCenteredRectangle(S(n[0],n[1],-.2),[t.size[0]-2,t.size[1]-2],t.color),t.text&&e.textRenderer.pushCenteredText(t.text,n,16),t.lines&&t.lines.forEach((t=>{e.stackRenderers.pushThickLine([n[0]+t.a[0],n[1]+t.a[1],0],[n[0]+t.b[0],n[1]+t.b[1],0],t.thickness,t.color)}))}))})(d,s),d.flushHudWireFrame(),d.flushHudText(),d.rayTracerRenderer.reset(),a.step.tick()};e.log("running"),E()}))),!1);
