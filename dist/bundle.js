"use strict";function e(e,t,i,n){return new(i||(i=Promise))((function(r,a){function s(e){try{h(n.next(e))}catch(e){a(e)}}function o(e){try{h(n.throw(e))}catch(e){a(e)}}function h(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,o)}h((n=n.apply(e,t||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;const t=["requestFullscreen","webkitRequestFullscreen","mozRequestFullScreen","msRequestFullscreen"],i=["fullscreenchange","webkitfullscreenchange","mozfullscreenchange","msfullscreenchange"],n=new class{constructor(){this._onFullScreenChangeCallbacks=[],this._isInitialized=!1}_initialize(){if(this._isInitialized)return;this._isInitialized=!0;const e=()=>{this._onFullScreenChangeCallbacks.forEach((e=>e()))};for(const t of i)document.addEventListener(t,e,!1)}isCompatible(e){for(const i of t)if(i in e)return!0;return!1}isFullScreen(e){return document.fullscreenElement===e}requestFullScreen(i){return e(this,void 0,void 0,(function*(){if(this.isFullScreen(i))return{success:!1,message:"element already in full screen"};this._initialize();for(const e of t)if(e in i)return i[e](),{success:!0,message:"request for full screen done"};return{success:!1,message:"unsupported request for full screen"}}))}addOnFullScreenChange(e){this._onFullScreenChangeCallbacks.push(e)}removeOnFullScreenChange(e){const t=this._onFullScreenChangeCallbacks.indexOf(e);t<0||this._onFullScreenChangeCallbacks.splice(t,1)}removeAllCallbacks(){this._onFullScreenChangeCallbacks.length=0}},r={Num0:48,Num1:49,Num2:50,Num3:51,Num4:52,Num5:53,Num6:54,Num7:55,Num8:56,Num9:57,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,Semicolon:186,Equal:187,Comma:188,Minus:189,Period:190,BackQuote:192,BracketLeft:219,Backslash:220,BracketRight:221,Quote:222,Shift:16,Ctrl:17,Alt:18,CapsLock:20,Tab:9,Enter:13,Pause:19,Escape:27,Space:32,PageUp:33,PageDown:34,End:35,Home:36,ArrowLeft:37,ArrowUp:38,ArrowRight:39,ArrowDown:40,PrintScreen:44,Insert:45,Delete:46,ContextMenu:93,ScrollLock:145,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,F13:124,F14:125,F15:126,F16:127,F17:128,F18:129,F19:130,F20:131,F21:132,F22:133,F23:134,F24:135,NumPad0:96,NumPad1:97,NumPad2:98,NumPad3:99,NumPad4:100,NumPad5:101,NumPad6:102,NumPad7:103,NumPad8:104,NumPad9:105,NumPadMultiply:106,NumPadAdd:107,NumPadSubtract:109,NumPadDecimal:110,NumPadDivide:111,NumLock:144,NumPadComma:194,NumPadEqual:12},a=e=>e>=r.A&&e<=r.Z,s=e=>e>=r.Num0&&e<=r.Num9||e>=r.NumPad0&&e<=r.NumPad9,o=new class{constructor(){this._pressedKeysSet=new Set,this._preventDefaultKeysSet=new Set,this._activated=!1,this._activated=!1,this._handleKeyDown=(e=>{const{keyCode:t}=e;this._onEvent&&this._onEvent(),this._preventDefaultKeysSet.has(t)&&e.preventDefault(),this._pressedKeysSet.add(t)}).bind(this),this._handleKeyUp=(e=>{const{keyCode:t}=e;this._onEvent&&this._onEvent(),this._preventDefaultKeysSet.has(t)&&e.preventDefault(),this._pressedKeysSet.delete(t)}).bind(this)}isPressed(...e){for(const t of e)if(this._pressedKeysSet.has(r[t]))return!0;return!1}preventDefault(e){this._preventDefaultKeysSet.add(r[e])}enableDefault(e){this._preventDefaultKeysSet.delete(r[e])}activate(){this._activated||(this._pressedKeysSet.clear(),document.addEventListener("keydown",this._handleKeyDown),document.addEventListener("keyup",this._handleKeyUp),this._activated=!0)}deactivate(){this._activated&&(this._pressedKeysSet.clear(),document.removeEventListener("keydown",this._handleKeyDown),document.removeEventListener("keyup",this._handleKeyUp),this._activated=!1)}onEvent(e){this._onEvent=e}},h={Left:0,Middle:1,Right:2},d=new class{constructor(){this._pressedButtonsSet=new Set,this._activated=!1,this._positionX=0,this._positionY=0,this._deltaX=0,this._deltaY=0,this._wheelDeltaY=0,this._activated=!1,this._handleMouseDown=(e=>{this._onEvent&&this._onEvent(),this._positionX=e.pageX,this._positionY=e.pageY,this._pressedButtonsSet.add(e.button)}).bind(this),this._handleMouseUp=(e=>{this._onEvent&&this._onEvent(),this._positionX=e.pageX,this._positionY=e.pageY,this._pressedButtonsSet.delete(e.button)}).bind(this),this._handleMouseMove=(e=>{this._onEvent&&this._onEvent(),this._positionX=e.pageX,this._positionY=e.pageY,this._deltaX+=e.movementX||e.mozMovementX||e.webkitMovementX||0,this._deltaY+=e.movementY||e.mozMovementY||e.webkitMovementY||0}).bind(this),this._handleMouseWheel=(e=>{this._onEvent&&this._onEvent(),this._wheelDeltaY+=e.deltaY||0}).bind(this)}activate(e){this._activated||(this._pressedButtonsSet.clear(),e.addEventListener("mousedown",this._handleMouseDown),e.addEventListener("mouseup",this._handleMouseUp),e.addEventListener("mousemove",this._handleMouseMove),e.addEventListener("wheel",this._handleMouseWheel),this._activated=!0)}deactivate(e){this._activated&&(this._pressedButtonsSet.clear(),e.removeEventListener("mousedown",this._handleMouseDown),e.removeEventListener("mouseup",this._handleMouseUp),e.removeEventListener("mousemove",this._handleMouseMove),e.removeEventListener("wheel",this._handleMouseWheel),this._activated=!1)}isButtonPressed(e){return this._pressedButtonsSet.has(h[e])}get positionX(){return this._positionX}get positionY(){return this._positionY}deltaX(){return this._deltaX}deltaY(){return this._deltaY}wheelDeltaY(){return this._wheelDeltaY}resetDeltas(){this._deltaX=0,this._deltaY=0,this._wheelDeltaY=0}onEvent(e){this._onEvent=e}},c=["requestPointerLock","mozRequestPointerLock","webkitRequestPointerLock"],l=["exitPointerLock","mozExitPointerLock","webkitExitPointerLock"],f=["pointerLockElement","mozPointerLockElement","webkitPointerLockElement"],u=[{methodName:"onpointerlockchange",propertyName:"pointerlockchange"},{methodName:"onmozpointerlockchange",propertyName:"mozpointerlockchange"},{methodName:"onwebkitpointerlockchange",propertyName:"webkitpointerlockchange"}],_=[{methodName:"onpointerlockerror",propertyName:"pointerlockerror"},{methodName:"onmozpointerlockerror",propertyName:"mozpointerlockerror"},{methodName:"onwebkitpointerlockerror",propertyName:"webkitpointerlockerror"}],g=new class{constructor(){this._onLockChangeCallbacks=[],this._onLockErrorCallbacks=[],this._timeSinceLastLockChange=0,this._isInitialized=!1}_initialize(){if(this._isInitialized)return;this._isInitialized=!0;const e=()=>{this._timeSinceLastLockChange=Date.now(),this._onLockChangeCallbacks.forEach((e=>e()))},t=e=>{this._timeSinceLastLockChange=Date.now(),this._onLockErrorCallbacks.forEach((t=>t(e)))};for(const t of u)if(t.methodName in document){document.addEventListener(t.propertyName,e,!1);break}for(const e of _)if(e.methodName in document){document.addEventListener(e.propertyName,t,!1);break}}canBePointerLocked(e){for(const t of c)if(t in e)return!0;return!1}isPointerLocked(e){for(const t of f)if(t in document)return document[t]===e;return!1}requestPointerLock(t){return e(this,void 0,void 0,(function*(){if(this.isPointerLocked(t))return{success:!1,message:"element already locked"};if(this._initialize(),this._timeSinceLastLockChange>0){const e=(Date.now()-this._timeSinceLastLockChange)/1e3;if(e<1.1)return{success:!1,message:`request for lock was too early, time to wait: ${e.toFixed(2)}sec`}}this._timeSinceLastLockChange=Date.now();for(const e of c)if(e in t){const i={unadjustedMovement:!1};try{yield t[e](i)}catch(e){return{success:!1,message:`request for lock was too early, time to wait: ${((Date.now()-this._timeSinceLastLockChange)/1e3).toFixed(2)}sec`}}return this._timeSinceLastLockChange=Date.now(),{success:!0,message:"request for lock done"}}return{success:!1,message:"unsupported request for lock"}}))}allowPointerLockedOnClickEvent(t){if(t===this._latestRequestHtmlElement)return;this._latestRequestHtmlElement=t;const i=()=>e(this,void 0,void 0,(function*(){t.removeEventListener("click",i);const e=yield this.requestPointerLock(t);this._latestRequestHtmlElement=void 0,e.success||this.allowPointerLockedOnClickEvent(t)}));t.addEventListener("click",i)}exitPointerLock(){for(const e of l)if(e in document){document[e]();break}}addOnLockChange(e){this._onLockChangeCallbacks.push(e)}removeOnLockChange(e){const t=this._onLockChangeCallbacks.indexOf(e);t<0||this._onLockChangeCallbacks.splice(t,1)}addOnLockError(e){this._onLockErrorCallbacks.push(e)}removeOnLockError(e){const t=this._onLockErrorCallbacks.indexOf(e);t<0||this._onLockErrorCallbacks.splice(t,1)}removeAllCallbacks(){this._onLockChangeCallbacks.length=0,this._onLockErrorCallbacks.length=0}};class p{constructor(e,t,i){this.createdAt=Date.now(),this.deltaX=0,this.deltaY=0,this.id=e,this.positionX=t,this.positionY=i}resetDelta(){this.deltaX=0,this.deltaY=0}}const m=new class{constructor(){this._activated=!1,this._allTouchDataMap=new Map,this._allCachedTouchDataArray=[],this._activated=!1,this._handleTouchStart=(e=>{e.preventDefault(),this._onEvent&&this._onEvent();for(let t=0;t<e.changedTouches.length;++t){const{identifier:i,pageX:n,pageY:r}=e.changedTouches[t],a=new p(i,n,r);this._allTouchDataMap.set(`${i}`,a),this._allCachedTouchDataArray.length=0}}).bind(this),this._handleTouchEnd=(e=>{e.preventDefault(),this._onEvent&&this._onEvent();for(let t=0;t<e.changedTouches.length;++t){const{identifier:i}=e.changedTouches[t];this._allTouchDataMap.delete(`${i}`),this._allCachedTouchDataArray.length=0}}).bind(this),this._handleTouchMove=(e=>{e.preventDefault(),this._onEvent&&this._onEvent();for(let t=0;t<e.changedTouches.length;++t){const{identifier:i,pageX:n,pageY:r}=e.changedTouches[t],a=this._allTouchDataMap.get(`${i}`);if(!a)continue;const s=n-a.positionX,o=r-a.positionY;a.deltaX+=s,a.deltaY+=o,a.positionX=n,a.positionY=r}}).bind(this)}isSupported(e){return"ontouchstart"in e}activate(e){this.isSupported(e)&&(this._activated||(this._allTouchDataMap.clear(),this._allCachedTouchDataArray.length=0,e.addEventListener("touchstart",this._handleTouchStart),e.addEventListener("touchend",this._handleTouchEnd),e.addEventListener("touchcancel",this._handleTouchEnd),e.addEventListener("touchmove",this._handleTouchMove,{passive:!1}),this._activated=!0))}deactivate(e){this._activated&&(this._allTouchDataMap.clear(),this._allCachedTouchDataArray.length=0,e.removeEventListener("touchstart",this._handleTouchStart),e.removeEventListener("touchend",this._handleTouchEnd),e.removeEventListener("touchcancel",this._handleTouchEnd),e.removeEventListener("touchmove",this._handleTouchMove),this._activated=!1)}_refreshCache(){0===this._allCachedTouchDataArray.length&&(this._allCachedTouchDataArray=[...this._allTouchDataMap.values()])}getTouchData(){return this._refreshCache(),this._allCachedTouchDataArray}resetDeltas(){this._refreshCache(),this._allCachedTouchDataArray.forEach((e=>e.resetDelta()))}onEvent(e){this._onEvent=e}},x=new class{constructor(){this._activated=!1,this._onVisibilityChangeCallbacks=[],this._handleVisibilityChange=(()=>{const e=this.isVisible();this._onVisibilityChangeCallbacks.forEach((t=>t(e)))}).bind(this)}activate(){this.isSupported()&&(this._activated||(document.addEventListener("visibilitychange",this._handleVisibilityChange,!1),this._activated=!0))}deactivate(){this._activated&&(document.removeEventListener("visibilitychange",this._handleVisibilityChange,!1),this._activated=!1)}isSupported(){return"onvisibilitychange"in document}isVisible(){return"visible"===document.visibilityState}addVisibilityChange(e){this._onVisibilityChangeCallbacks.push(e)}removeVisibilityChange(e){const t=this._onVisibilityChangeCallbacks.indexOf(e);t<0||this._onVisibilityChangeCallbacks.splice(t,1)}removeAllCallbacks(){this._onVisibilityChangeCallbacks.length=0}},b=()=>!!window.WebGL2RenderingContext;var v=Object.freeze({__proto__:null,AllKeyCodes:r,GlobalFullScreenManager:n,GlobalKeyboardManager:o,GlobalMouseManager:d,GlobalPointerLockManager:g,GlobalTouchManager:m,GlobalVisibilityManager:x,isAlphanumeric:e=>s(e)||a(e),isLetter:a,isNumber:s,isWebGL2Supported:b,isWebWorkerSupported:()=>!!window.Worker}),y=1e-6,w="undefined"!=typeof Float32Array?Float32Array:Array;function S(){var e=new w(16);return w!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function T(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function E(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function R(e,t,i){var n=t[0],r=t[1],a=t[2],s=t[3],o=t[4],h=t[5],d=t[6],c=t[7],l=t[8],f=t[9],u=t[10],_=t[11],g=t[12],p=t[13],m=t[14],x=t[15],b=i[0],v=i[1],y=i[2],w=i[3];return e[0]=b*n+v*o+y*l+w*g,e[1]=b*r+v*h+y*f+w*p,e[2]=b*a+v*d+y*u+w*m,e[3]=b*s+v*c+y*_+w*x,b=i[4],v=i[5],y=i[6],w=i[7],e[4]=b*n+v*o+y*l+w*g,e[5]=b*r+v*h+y*f+w*p,e[6]=b*a+v*d+y*u+w*m,e[7]=b*s+v*c+y*_+w*x,b=i[8],v=i[9],y=i[10],w=i[11],e[8]=b*n+v*o+y*l+w*g,e[9]=b*r+v*h+y*f+w*p,e[10]=b*a+v*d+y*u+w*m,e[11]=b*s+v*c+y*_+w*x,b=i[12],v=i[13],y=i[14],w=i[15],e[12]=b*n+v*o+y*l+w*g,e[13]=b*r+v*h+y*f+w*p,e[14]=b*a+v*d+y*u+w*m,e[15]=b*s+v*c+y*_+w*x,e}function A(e,t,i){var n,r,a,s,o,h,d,c,l,f,u,_,g=i[0],p=i[1],m=i[2];return t===e?(e[12]=t[0]*g+t[4]*p+t[8]*m+t[12],e[13]=t[1]*g+t[5]*p+t[9]*m+t[13],e[14]=t[2]*g+t[6]*p+t[10]*m+t[14],e[15]=t[3]*g+t[7]*p+t[11]*m+t[15]):(n=t[0],r=t[1],a=t[2],s=t[3],o=t[4],h=t[5],d=t[6],c=t[7],l=t[8],f=t[9],u=t[10],_=t[11],e[0]=n,e[1]=r,e[2]=a,e[3]=s,e[4]=o,e[5]=h,e[6]=d,e[7]=c,e[8]=l,e[9]=f,e[10]=u,e[11]=_,e[12]=n*g+o*p+l*m+t[12],e[13]=r*g+h*p+f*m+t[13],e[14]=a*g+d*p+u*m+t[14],e[15]=s*g+c*p+_*m+t[15]),e}function M(e,t,i){var n=Math.sin(i),r=Math.cos(i),a=t[0],s=t[1],o=t[2],h=t[3],d=t[8],c=t[9],l=t[10],f=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*r-d*n,e[1]=s*r-c*n,e[2]=o*r-l*n,e[3]=h*r-f*n,e[8]=a*n+d*r,e[9]=s*n+c*r,e[10]=o*n+l*r,e[11]=h*n+f*r,e}function C(e,t){var i=t[0],n=t[1],r=t[2],a=t[3],s=i+i,o=n+n,h=r+r,d=i*s,c=n*s,l=n*o,f=r*s,u=r*o,_=r*h,g=a*s,p=a*o,m=a*h;return e[0]=1-l-_,e[1]=c+m,e[2]=f-p,e[3]=0,e[4]=c-m,e[5]=1-d-_,e[6]=u+g,e[7]=0,e[8]=f+p,e[9]=u-g,e[10]=1-d-l,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(){var e=new w(3);return w!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function P(e){var t=new w(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function I(e,t,i){var n=new w(3);return n[0]=e,n[1]=t,n[2]=i,n}function B(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function k(e,t,i,n){return e[0]=t,e[1]=i,e[2]=n,e}function z(e,t,i){return e[0]=t[0]+i[0],e[1]=t[1]+i[1],e[2]=t[2]+i[2],e}function F(e,t,i){return e[0]=t[0]-i[0],e[1]=t[1]-i[1],e[2]=t[2]-i[2],e}function L(e,t,i){return e[0]=t[0]*i[0],e[1]=t[1]*i[1],e[2]=t[2]*i[2],e}function N(e,t,i){return e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e}function V(e,t){var i=t[0],n=t[1],r=t[2],a=i*i+n*n+r*r;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function U(e,t,i){var n=t[0],r=t[1],a=t[2],s=i[0],o=i[1],h=i[2];return e[0]=r*h-a*o,e[1]=a*s-n*h,e[2]=n*o-r*s,e}function G(e,t,i,n){var r=t[0],a=t[1],s=t[2];return e[0]=r+n*(i[0]-r),e[1]=a+n*(i[1]-a),e[2]=s+n*(i[2]-s),e}function X(e,t,i){var n=t[0],r=t[1],a=t[2],s=i[3]*n+i[7]*r+i[11]*a+i[15];return s=s||1,e[0]=(i[0]*n+i[4]*r+i[8]*a+i[12])/s,e[1]=(i[1]*n+i[5]*r+i[9]*a+i[13])/s,e[2]=(i[2]*n+i[6]*r+i[10]*a+i[14])/s,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var O,W=F;function H(){var e=new w(4);return w!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function Y(e,t,i,n){var r=new w(4);return r[0]=e,r[1]=t,r[2]=i,r[3]=n,r}function $(e,t,i){var n=t[0],r=t[1],a=t[2],s=t[3];return e[0]=i[0]*n+i[4]*r+i[8]*a+i[12]*s,e[1]=i[1]*n+i[5]*r+i[9]*a+i[13]*s,e[2]=i[2]*n+i[6]*r+i[10]*a+i[14]*s,e[3]=i[3]*n+i[7]*r+i[11]*a+i[15]*s,e}function q(){var e=new w(4);return w!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function j(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e}function K(e,t,i){i*=.5;var n=Math.sin(i);return e[0]=n*t[0],e[1]=n*t[1],e[2]=n*t[2],e[3]=Math.cos(i),e}function Z(e,t){var i=new w(2);return i[0]=e,i[1]=t,i}D(),H(),D(),I(1,0,0),I(0,1,0),q(),q(),O=new w(9),w!=Float32Array&&(O[1]=0,O[2]=0,O[3]=0,O[5]=0,O[6]=0,O[7]=0),O[0]=1,O[4]=1,O[8]=1,function(){var e=new w(2);w!=Float32Array&&(e[0]=0,e[1]=0)}();const Q=e=>e*Math.PI/180,J={X:0,Y:1,Z:2};var ee=Object.freeze({__proto__:null,FreeFlyController:class{constructor(e){this._isActivated=!1,this._theta=0,this._phi=0,this._touchWasActive=!1,this._touchStartTime=0,this._touchMoveForward=!1,this._position=I(0,0,0),this._target=I(0,0,0),this._forwardAxis=I(1,0,0),this._leftAxis=I(0,0,1),this._upAxis=I(0,1,0),this._move_forwardAxis=I(1,0,0),this._move_leftAxis=I(0,0,1),this._move_upAxis=I(0,1,0),this._mouseSensibility=e.mouseSensibility,this._keyboardSensibility=e.keyboardSensibility,this._touchSensibility=e.touchSensibility,this._movingSpeed=e.movingSpeed,B(this._position,e.position),this._axisIndices=[e.coordinates?J[e.coordinates[0]]:J.X,e.coordinates?J[e.coordinates[1]]:J.Y,e.coordinates?J[e.coordinates[2]]:J.Z],this._theta=e.theta,this._phi=e.phi}isActivated(){return this._isActivated}activate(){this._isActivated=!0,o.preventDefault("Z"),o.preventDefault("W"),o.preventDefault("S"),o.preventDefault("A"),o.preventDefault("Q"),o.preventDefault("D"),o.preventDefault("Shift"),o.preventDefault("C"),o.preventDefault("Space"),o.preventDefault("ArrowUp"),o.preventDefault("ArrowDown"),o.preventDefault("ArrowLeft"),o.preventDefault("ArrowRight")}deactivate(){this._isActivated=!1,o.enableDefault("Z"),o.enableDefault("W"),o.enableDefault("S"),o.enableDefault("A"),o.enableDefault("Q"),o.enableDefault("D"),o.enableDefault("Shift"),o.enableDefault("C"),o.enableDefault("Space"),o.enableDefault("ArrowUp"),o.enableDefault("ArrowDown"),o.enableDefault("ArrowLeft"),o.enableDefault("ArrowRight")}isInteractedWith(){return o.isPressed("Z","W","S","A","Q","D")||o.isPressed("Shift","C","Space")||o.isPressed("ArrowUp","ArrowDown","ArrowLeft","ArrowRight")}update(e,t=!1){let i=!1,n=!1,r=!1,a=!1,s=!1,h=!1,c=!1,l=0,f=0;{const t=d.deltaX()*this._mouseSensibility,i=d.deltaY()*this._mouseSensibility;l-=Q(t)*e,f-=Q(i)*e}const u=m.getTouchData().length>0;if(u){if(!this._touchWasActive){const e=Date.now();(e-this._touchStartTime)/1e3<.25?this._touchMoveForward=!0:this._touchStartTime=e}const t=m.getTouchData()[0],i=t.deltaX*this._touchSensibility,n=t.deltaY*this._touchSensibility;l-=Q(i)*e,f-=Q(n)*e}else this._touchMoveForward=!1;this._touchWasActive=u,this._touchMoveForward&&(i=!0),o.isPressed("Z","W")&&(i=!0),o.isPressed("S")&&(n=!0),o.isPressed("A","Q")&&(r=!0),o.isPressed("D")&&(a=!0),o.isPressed("Shift")&&(s=!0),t||(o.isPressed("C")&&(h=!0),o.isPressed("Space")&&(c=!0));const _=this._movingSpeed*(s?4:1)*e,g=this._keyboardSensibility*e;o.isPressed("ArrowUp")?f+=g:o.isPressed("ArrowDown")&&(f-=g),o.isPressed("ArrowLeft")?l+=g:o.isPressed("ArrowRight")&&(l-=g),this._theta+=l,this._phi+=f;const p=.5*Math.PI,x=.95*p;this._phi=Math.min(Math.max(this._phi,-x),+x);const b=Math.cos(this._theta),v=Math.sin(this._theta),[y,w,S]=this._axisIndices,T=Math.cos(this._phi+p);this._upAxis[y]=T*b,this._upAxis[w]=T*v,this._upAxis[S]=Math.sin(this._phi+p);const E=Math.cos(this._phi);this._forwardAxis[y]=E*b,this._forwardAxis[w]=E*v,this._forwardAxis[S]=Math.sin(this._phi),U(this._leftAxis,this._upAxis,this._forwardAxis),t?(this._move_forwardAxis[y]=b,this._move_forwardAxis[w]=v,this._move_forwardAxis[S]=0,this._move_leftAxis[y]=-v,this._move_leftAxis[w]=b,this._move_leftAxis[S]=0,this._move_upAxis[y]=0,this._move_upAxis[w]=0,this._move_upAxis[S]=1):(B(this._move_forwardAxis,this._forwardAxis),B(this._move_leftAxis,this._leftAxis),B(this._move_upAxis,this._upAxis));const R=I(0,0,0);N(R,this._move_forwardAxis,_);const A=I(0,0,0);N(A,this._move_leftAxis,_);const M=I(0,0,0);N(M,this._move_upAxis,_),i?z(this._position,this._position,R):n&&W(this._position,this._position,R),r?z(this._position,this._position,A):a&&W(this._position,this._position,A),c?z(this._position,this._position,M):h&&W(this._position,this._position,M),z(this._target,this._position,this._forwardAxis)}getPosition(){return this._position}setPosition(e){B(this._position,e),z(this._target,this._position,this._forwardAxis)}getTarget(){return this._target}getUpAxis(){return this._upAxis}getTheta(){return this._theta}getPhi(){return this._phi}getTouchMoveForward(){return this._touchMoveForward}}});const te=(e,t,i)=>Math.min(Math.max(e,t),i),ie=e=>e>1?e-Math.floor(e):e,ne=e=>(e*=2)<1?e:1-(e-=1),re=(e,t,i)=>t+(i-t)*e;class ae{constructor(){this._framesDelta=[],this._averageDelta=0,this._minDelta=0,this._maxDelta=0}pushDelta(e){this._framesDelta.length>=100&&this._framesDelta.shift(),this._framesDelta.push(e),this._minDelta=999999999,this._maxDelta=-999999999,this._averageDelta=0;for(const e of this._framesDelta)this._minDelta=Math.min(this._minDelta,e),this._maxDelta=Math.max(this._maxDelta,e),this._averageDelta+=e;this._averageDelta/=this._framesDelta.length}get framesDelta(){return this._framesDelta}get averageDelta(){return this._averageDelta}get minDelta(){return this._minDelta}get maxDelta(){return this._maxDelta}}var se,oe;!function(e){e[e.perspective=0]="perspective",e[e.orthogonal=1]="orthogonal"}(se||(se={})),function(e){e[e.Right=0]="Right",e[e.Left=1]="Left",e[e.Bottom=2]="Bottom",e[e.Top=3]="Top",e[e.Back=4]="Back",e[e.Front=5]="Front"}(oe||(oe={}));const he=(e,t,i)=>{const n=H(),r=H(),a=[];return e.forEach((e=>{if(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=1,$(r,n,t),0===r[3])return null;r[3]=1/r[3],r[0]*=r[3],r[1]*=r[3],r[2]*=r[3],r[0]=(.5*r[0]+.5)*i[2]+i[0],r[1]=(.5*r[1]+.5)*i[3]+i[1],a.push(B(D(),r))})),a},de=(e,t,i)=>{const n=function(e,t){var i=t[0],n=t[1],r=t[2],a=t[3],s=t[4],o=t[5],h=t[6],d=t[7],c=t[8],l=t[9],f=t[10],u=t[11],_=t[12],g=t[13],p=t[14],m=t[15],x=i*o-n*s,b=i*h-r*s,v=i*d-a*s,y=n*h-r*o,w=n*d-a*o,S=r*d-a*h,T=c*g-l*_,E=c*p-f*_,R=c*m-u*_,A=l*p-f*g,M=l*m-u*g,C=f*m-u*p,D=x*C-b*M+v*A+y*R-w*E+S*T;return D?(D=1/D,e[0]=(o*C-h*M+d*A)*D,e[1]=(r*M-n*C-a*A)*D,e[2]=(g*S-p*w+m*y)*D,e[3]=(f*w-l*S-u*y)*D,e[4]=(h*R-s*C-d*E)*D,e[5]=(i*C-r*R+a*E)*D,e[6]=(p*v-_*S-m*b)*D,e[7]=(c*S-f*v+u*b)*D,e[8]=(s*M-o*R+d*T)*D,e[9]=(n*R-i*M-a*T)*D,e[10]=(_*w-g*v+m*x)*D,e[11]=(l*v-c*w-u*x)*D,e[12]=(o*E-s*A-h*T)*D,e[13]=(i*A-n*E+r*T)*D,e[14]=(g*b-_*y-p*x)*D,e[15]=(c*y-l*b+f*x)*D,e):null}(S(),t);return ce(e,n,i)},ce=(e,t,i)=>{const n=[],r=H();return e.forEach((e=>{r[0]=(e[0]-i[0])/i[2]*2-1,r[1]=(e[1]-i[1])/i[3]*2-1,r[2]=2*e[2]-1,r[3]=1,$(r,r,t),0!==r[3]&&(r[3]=1/r[3],r[0]*=r[3],r[1]*=r[3],r[2]*=r[3],n.push(B(D(),r)))})),n};var le=Object.freeze({__proto__:null,Camera:class{constructor(){this._projectionType=se.perspective,this._viewportPos=Z(0,0),this._viewportSize=Z(0,0),this._projectionMatrix=S(),this._viewMatrix=S(),this._composedMatrix=S(),this._eye=I(0,0,0),this._target=I(0,0,0),this._upAxis=I(0,0,0)}setAsPerspective(e){this._projectionType=se.perspective;let t=e.aspectRatio;void 0===t&&(t=this._viewportSize[0]/this._viewportSize[1]),this._perspectiveData={fovy:e.fovy,aspectRatio:t,near:e.near,far:e.far}}setAsOrthogonal(e){this._projectionType=se.orthogonal,this._orthogonalData=Object.assign({},e)}setViewportPos(e,t){this._viewportPos[0]=e,this._viewportPos[1]=t}getViewportPos(){return this._viewportPos}setViewportSize(e,t){this._viewportSize[0]=e,this._viewportSize[1]=t,this._projectionType!==se.perspective&&this._perspectiveData&&(this._perspectiveData.aspectRatio=this._viewportSize[0]/this._viewportSize[1])}getViewportSize(){return this._viewportSize}lookAt(e,t,i){this.setEye(e),this.setTarget(t),this.setUpAxis(i)}setEye(e){B(this._eye,e)}setTarget(e){B(this._target,e)}setUpAxis(e){B(this._upAxis,e)}getEye(){return this._eye}getTarget(){return this._target}getUpAxis(){return this._upAxis}computeMatrices(){if(this._projectionType===se.perspective){const{fovy:e,aspectRatio:t,near:i,far:n}=this._perspectiveData;!function(e,t,i,n,r){var a,s=1/Math.tan(t/2);e[0]=s/i,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=r&&r!==1/0?(a=1/(n-r),e[10]=(r+n)*a,e[14]=2*r*n*a):(e[10]=-1,e[14]=-2*n)}(this._projectionMatrix,Q(e),t,i,n)}else if(this._projectionType===se.orthogonal){const{left:e,right:t,top:i,bottom:n,near:r,far:a}=this._orthogonalData;!function(e,t,i,n,r,a,s){var o=1/(t-i),h=1/(n-r),d=1/(a-s);e[0]=-2*o,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*h,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*d,e[11]=0,e[12]=(t+i)*o,e[13]=(r+n)*h,e[14]=(s+a)*d,e[15]=1}(this._projectionMatrix,e,t,i,n,r,a)}!function(e,t,i,n){var r,a,s,o,h,d,c,l,f,u,_=t[0],g=t[1],p=t[2],m=n[0],x=n[1],b=n[2],v=i[0],w=i[1],S=i[2];Math.abs(_-v)<y&&Math.abs(g-w)<y&&Math.abs(p-S)<y?E(e):(c=_-v,l=g-w,f=p-S,r=x*(f*=u=1/Math.hypot(c,l,f))-b*(l*=u),a=b*(c*=u)-m*f,s=m*l-x*c,(u=Math.hypot(r,a,s))?(r*=u=1/u,a*=u,s*=u):(r=0,a=0,s=0),o=l*s-f*a,h=f*r-c*s,d=c*a-l*r,(u=Math.hypot(o,h,d))?(o*=u=1/u,h*=u,d*=u):(o=0,h=0,d=0),e[0]=r,e[1]=o,e[2]=c,e[3]=0,e[4]=a,e[5]=h,e[6]=l,e[7]=0,e[8]=s,e[9]=d,e[10]=f,e[11]=0,e[12]=-(r*_+a*g+s*p),e[13]=-(o*_+h*g+d*p),e[14]=-(c*_+l*g+f*p),e[15]=1)}(this._viewMatrix,this._eye,this._target,this._upAxis),this.computeComposedMatrix()}computeComposedMatrix(){R(this._composedMatrix,this._projectionMatrix,this._viewMatrix)}setProjectionMatrix(e){T(this._projectionMatrix,e)}setViewMatrix(e){T(this._viewMatrix,e)}setComposedMatrix(e){T(this._composedMatrix,e)}getProjectionMatrix(){return this._projectionMatrix}getViewMatrix(){return this._viewMatrix}getComposedMatrix(){return this._composedMatrix}getPerspectiveData(){if(this._projectionType!==se.perspective)throw new Error("not a perspective projection");return this._perspectiveData}getOrthogonalData(){if(this._projectionType!==se.orthogonal)throw new Error("not an orthogonal projection");return this._orthogonalData}},FrustumCulling:class{constructor(){this._frustum=new Float32Array(24)}_setPlane(e,t,i,n){const r=4*e;this._frustum[r+0]=t[0]+i[0]*n,this._frustum[r+1]=t[1]+i[1]*n,this._frustum[r+2]=t[2]+i[2]*n,this._frustum[r+3]=t[3]+i[3]*n;const a=Math.sqrt(this._frustum[r+0]*this._frustum[r+0]+this._frustum[r+1]*this._frustum[r+1]+this._frustum[r+2]*this._frustum[r+2]);0!==a&&(this._frustum[r+0]/=a,this._frustum[r+1]/=a,this._frustum[r+2]/=a,this._frustum[r+3]/=a)}calculateFrustum(e,t){const i=R(S(),e,t),n=Y(i[0],i[4],i[8],i[12]),r=Y(i[1],i[5],i[9],i[13]),a=Y(i[2],i[6],i[10],i[14]),s=Y(i[3],i[7],i[11],i[15]);this._setPlane(oe.Right,s,n,-1),this._setPlane(oe.Left,s,n,1),this._setPlane(oe.Bottom,s,r,1),this._setPlane(oe.Top,s,r,-1),this._setPlane(oe.Back,s,a,-1),this._setPlane(oe.Front,s,a,1)}sphereInFrustum(e,t,i,n){for(let r=0;r<6;++r){const a=4*r;if(this._frustum[a+0]*e+this._frustum[a+1]*t+this._frustum[a+2]*i+this._frustum[a+3]<=-n)return!1}return!0}pointInFrustum(e,t,i){return this.sphereInFrustum(e,t,i,0)}cubeInFrustumVec3(e,t){return this.cubeInFrustum(e[0],e[1],e[2],t)}cubeInFrustum(e,t,i,n){const r=.5*n,a=e-r,s=t-r,o=i-r,h=e+r,d=t+r,c=i+r;for(let e=0;e<6;++e){const t=4*e,i=this._frustum[t+0],n=this._frustum[t+1],r=this._frustum[t+2],l=this._frustum[t+3];if(!(i*a+n*s+r*o+l>0||i*h+n*s+r*o+l>0||i*a+n*d+r*o+l>0||i*h+n*d+r*o+l>0||i*a+n*s+r*c+l>0||i*h+n*s+r*c+l>0||i*a+n*d+r*c+l>0||i*h+n*d+r*c+l>0))return!1}return!0}},sceneToScreenCoordinates:(e,t,i,n)=>{const r=S();return R(r,i,t),he(e,r,n)},sceneToScreenCoordsFromComposed:he,screenToSceneCoordinates:(e,t,i,n)=>{const r=R(S(),i,t);return de(e,r,n)},screenToSceneCoordinatesFromComposed:de,screenToSceneCoordinatesFromInvComposed:ce});let fe=class e{static initialize(t){if(e._gl=t.getContext("webgl2",{alpha:!1,antialias:!1,depth:!0,failIfMajorPerformanceCaveat:!1,powerPreference:"high-performance",premultipliedAlpha:!0,preserveDrawingBuffer:!0,stencil:!1,desynchronized:!1}),!e._gl)throw new Error("could not create webgl context");e._extensionLoseContext=e._gl.getExtension("WEBGL_lose_context"),e._gl.getExtension("EXT_color_buffer_float"),e._gl.getExtension("EXT_float_blend")}static setContext(t){return e._gl=t}static getContext(){if(!e._gl)throw new Error("webgl context not initialized");return e._gl}static getExtensionLoseContext(){return e._extensionLoseContext}static getExtensionLoseContextStrict(){if(!e._extensionLoseContext)throw new Error("lose context extension not available");return e._extensionLoseContext}};var ue;fe._gl=null,fe._extensionLoseContext=null,function(e){e[e.positiveX=0]="positiveX",e[e.negativeX=1]="negativeX",e[e.positiveY=2]="positiveY",e[e.negativeY=3]="negativeY",e[e.positiveZ=4]="positiveZ",e[e.negativeZ=5]="negativeZ"}(ue||(ue={}));const _e=e=>{const t=fe.getContext();switch(e){case ue.positiveX:return t.TEXTURE_CUBE_MAP_POSITIVE_X;case ue.negativeX:return t.TEXTURE_CUBE_MAP_NEGATIVE_X;case ue.positiveY:return t.TEXTURE_CUBE_MAP_POSITIVE_Y;case ue.negativeY:return t.TEXTURE_CUBE_MAP_NEGATIVE_Y;case ue.positiveZ:return t.TEXTURE_CUBE_MAP_POSITIVE_Z;case ue.negativeZ:return t.TEXTURE_CUBE_MAP_NEGATIVE_Z}};class ge{constructor(){this._width=0,this._height=0,this._minBufferSize=0,this._texture=null}initialize(e,t){if(e<1)throw new Error(`cube map: width is < 1, input: ${e}`);if(t<1)throw new Error(`cube map: height is < 1, input: ${t}`);const i=fe.getContext();this._texture=i.createTexture(),this._width=e,this._height=t,this._minBufferSize=this._width*this._height*4}dispose(){fe.getContext().deleteTexture(this._texture)}rawBind(){if(!this._texture)throw new Error("cube map: not initialized");const e=fe.getContext();e.bindTexture(e.TEXTURE_CUBE_MAP,this._texture)}bind(e){this.rawBind(),e(this),ge.unbind()}static unbind(){const e=fe.getContext();e.bindTexture(e.TEXTURE_CUBE_MAP,null)}loadFromMemory(e,t){if(!this._texture)throw new Error("cube map: not initialized");if(t.length<this._minBufferSize)throw new Error(`cube map: miss-matching pixels buffer size, input: ${t.length}`);const i=fe.getContext(),n=i.RGBA,r=i.RGBA,a=i.UNSIGNED_BYTE;i.texImage2D(_e(e),0,n,this._width,this._height,0,r,a,t)}allocate(){const e=fe.getContext(),t=e.RGBA,i=e.RGBA,n=e.UNSIGNED_BYTE,r=new Uint8Array(this._width*this._height*4);[ue.negativeX,ue.negativeY,ue.negativeZ,ue.positiveX,ue.positiveY,ue.positiveZ].forEach((a=>{e.texImage2D(_e(a),0,t,this._width,this._height,0,i,n,r)}))}complete(){const e=fe.getContext();e.generateMipmap(e.TEXTURE_CUBE_MAP),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR)}getWidth(){if(!this._texture)throw new Error("cube map: not initialized");return this._width}getHeight(){if(!this._texture)throw new Error("cube map: not initialized");return this._height}getRawObject(){if(!this._texture)throw new Error("texture not initialized");return this._texture}}class pe{constructor(){this._texture=null}initialize(e){if(this._texture)throw new Error("data texture already initialized");const t=fe.getContext();if(this._texture=t.createTexture(),!this._texture)throw new Error("data texture failed to be created");t.bindTexture(t.TEXTURE_2D,this._texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),this.allocate(e)}dispose(){fe.getContext().deleteTexture(this._texture)}allocate(e){if(!this._texture)throw new Error("data texture not initialized");const t=Array.isArray(e)?e.length:e;if(t<=0)throw new Error("texture: width must be positive");if(t>2048)throw new Error(`data texture max size is 2048 (input was ${t})`);const i=fe.getContext();i.bindTexture(i.TEXTURE_2D,this._texture),Array.isArray(e),this._buffer=new Float32Array(e);const n=i.R32F,r=t,a=i.RED,s=i.FLOAT;i.texImage2D(i.TEXTURE_2D,0,n,r,1,0,a,s,this._buffer)}update(e,t){if(!this._texture)throw new Error("data texture not initialized");if(!this._buffer)throw new Error("data texture update but not previously allocated");if(e+t.length>this._buffer.length)throw new Error(`data texture update but size is larger (start: ${e}, length: ${t.length}, max: ${this._buffer.length})`);const i=fe.getContext();i.bindTexture(i.TEXTURE_2D,this._texture);for(let e=0;e<t.length;++e)this._buffer[e]=t[e];const n=t.length,r=i.RED,a=i.FLOAT,s=e;i.texSubImage2D(i.TEXTURE_2D,0,s,0,n,1,r,a,this._buffer,0)}rawBind(){if(!this._texture)throw new Error("data texture not initialized");const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,this._texture)}preBind(e){this.rawBind(),e(this)}bind(e){this.preBind(e),pe.unbind()}static unbind(){const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,null)}}class me{constructor(){this._internalData=null}initialize(e,t){if(this._internalData)throw new Error("data texture already initialized");const i=fe.getContext(),n=i.createTexture();if(!n)throw new Error("data texture failed to be created");i.bindTexture(i.TEXTURE_2D,n),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),this._internalData={texture:n,width:1,height:1},this.allocate(e,t)}dispose(){if(!this._internalData)throw new Error("data texture not initialized");fe.getContext().deleteTexture(this._internalData.texture)}allocate(e,t){if(!this._internalData)throw new Error("data texture not initialized");if(e<=0)throw new Error("texture: width must be positive");if(e>2048)throw new Error(`data texture max width is 2048 (input was ${e})`);if(t<=0)throw new Error("texture: height must be positive");if(t>2048)throw new Error(`data texture max height is 2048 (input was ${t})`);this._internalData.width=e,this._internalData.height=t;const i=fe.getContext();i.bindTexture(i.TEXTURE_2D,this._internalData.texture);const n=i.RGBA32F,r=i.RGBA,a=i.FLOAT;i.texImage2D(i.TEXTURE_2D,0,n,this._internalData.width,this._internalData.height,0,r,a,null)}updateFromBuffer(e,t,i,n,r){if(!this._internalData)throw new Error("data texture not initialized");if(e<0)throw new Error(`data texture update but texelX is negative (texelX: ${e})`);if(t<0)throw new Error(`data texture update but texelY is negative (texelY: ${e})`);if(i<0)throw new Error(`data texture update but width is negative (width: ${e})`);if(n<0)throw new Error(`data texture update but height is negative (height: ${e})`);if(e+i>this._internalData.width)throw new Error(`data texture update but width is larger (texelX: ${e}, width: ${i}, internal.width: ${this._internalData.width}`);if(t+n>this._internalData.height)throw new Error(`data texture update but height is larger (texelX: ${e}, width: ${i}, internal.width: ${this._internalData.width}`);if(i*n>r.length)throw new Error(`data texture update but size is too large (size: ${i*n}, input.buffer.length: ${r.length}`);const a=fe.getContext();a.bindTexture(a.TEXTURE_2D,this._internalData.texture);const s=a.RGBA,o=a.FLOAT,h=e,d=t;a.texSubImage2D(a.TEXTURE_2D,0,h,d,i,n,s,o,r,0)}rawBind(){if(!this._internalData)throw new Error("data texture not initialized");const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,this._internalData.texture)}preBind(e){this.rawBind(),e(this)}bind(e){this.preBind(e),me.unbind()}static unbind(){const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,null)}}class xe{constructor(){this._texture=null}initialize(e=0){if(this._texture)throw new Error("data texture already initialized");const t=fe.getContext();if(this._texture=t.createTexture(),!this._texture)throw new Error("data texture failed to be created");t.bindTexture(t.TEXTURE_2D,this._texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),this.allocate(e)}dispose(){fe.getContext().deleteTexture(this._texture)}allocate(e){if(!this._texture)throw new Error("data texture not initialized");const t=Array.isArray(e)?e.length:Math.ceil(e/4);if(t<=0)throw new Error("texture: width must be positive");if(t>2048)throw new Error(`data texture max size is 2048 (input was ${t})`);const i=fe.getContext();if(i.bindTexture(i.TEXTURE_2D,this._texture),Array.isArray(e))this._buffer=new Float32Array(e.flat());else{if(e%4!=0)throw new Error(`data texture update buffer length is not a multiple of 4, length: ${e}.`);this._buffer=new Float32Array(e)}const n=i.RGBA32F,r=t,a=i.RGBA,s=i.FLOAT;i.texImage2D(i.TEXTURE_2D,0,n,r,1,0,a,s,this._buffer)}update(e,t){if(!this._texture)throw new Error("data texture not initialized");if(!this._buffer)throw new Error("data texture update but not previously allocated");if(e+t.length>this._buffer.length)throw new Error(`data texture update but size is larger (start: ${e}, length: ${t.length}, max: ${this._buffer.length})`);const i=fe.getContext();i.bindTexture(i.TEXTURE_2D,this._texture);for(let e=0;e<t.length;++e)this._buffer[4*e+0]=t[e][0],this._buffer[4*e+1]=t[e][1],this._buffer[4*e+2]=t[e][2],this._buffer[4*e+3]=t[e][3];this.updateFromBuffer(e,this._buffer)}updateFromBuffer(e,t){if(!this._texture)throw new Error("data texture not initialized");if(!this._buffer)throw new Error("data texture update but not previously allocated");if(e+t.length>this._buffer.length)throw new Error(`data texture update but size is larger (start: ${e}, length: ${t.length}, max: ${this._buffer.length})`);if(t.length%4!=0)throw new Error(`data texture update buffer length is not a multiple of 4, length: ${t.length}.`);const i=fe.getContext();i.bindTexture(i.TEXTURE_2D,this._texture);const n=t.length/4,r=i.RGBA,a=i.FLOAT,s=e;i.texSubImage2D(i.TEXTURE_2D,0,s,0,n,1,r,a,t,0)}rawBind(){if(!this._texture)throw new Error("data texture not initialized");const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,this._texture)}preBind(e){this.rawBind(),e(this)}bind(e){this.preBind(e),xe.unbind()}static unbind(){const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,null)}}class be{constructor(){this._texture=null}initialize(e=[]){if(this._texture)throw new Error("data texture already initialized");const t=fe.getContext();if(this._texture=t.createTexture(),!this._texture)throw new Error("data texture failed to be created");t.bindTexture(t.TEXTURE_2D,this._texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),this.allocate(e)}dispose(){fe.getContext().deleteTexture(this._texture)}allocate(e){if(!this._texture)throw new Error("data texture not initialized");if(e.length<=0)throw new Error("texture: width must be positive");const t=fe.getContext();t.bindTexture(t.TEXTURE_2D,this._texture),this._buffer=new Uint8Array(e.flat());const i=t.RGBA,n=e.length,r=t.RGBA,a=t.UNSIGNED_BYTE;t.texImage2D(t.TEXTURE_2D,0,i,n,1,0,r,a,this._buffer)}update(e,t){if(!this._texture)throw new Error("data texture not initialized");if(!this._buffer)throw new Error("data texture update but not previously allocated");if(e+t.length>this._buffer.length)throw new Error(`data texture update but size is larger (start: ${e}, length: ${t.length}, max: ${this._buffer.length})`);const i=fe.getContext();i.bindTexture(i.TEXTURE_2D,this._texture);for(let e=0;e<t.length;++e)this._buffer[4*e+0]=t[e][0],this._buffer[4*e+1]=t[e][1],this._buffer[4*e+2]=t[e][2],this._buffer[4*e+3]=t[e][3];const n=t.length,r=i.RGBA,a=i.UNSIGNED_BYTE,s=e;i.texSubImage2D(i.TEXTURE_2D,0,s,0,n,1,r,a,this._buffer,0)}rawBind(){if(!this._texture)throw new Error("data texture not initialized");const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,this._texture)}preBind(e){this.rawBind(),e(this)}bind(e){this.preBind(e),be.unbind()}static unbind(){const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,null)}}let ve=class e{constructor(){const e=fe.getContext().createFramebuffer();if(null===e)throw new Error("null frame buffer object");this._frameBuffer=e}dispose(){fe.getContext().deleteFramebuffer(this._frameBuffer)}rawBind(){const e=fe.getContext();e.bindFramebuffer(e.FRAMEBUFFER,this._frameBuffer)}bind(t){this.rawBind(),t(this),e.unbind()}static unbind(){const e=fe.getContext();e.bindFramebuffer(e.FRAMEBUFFER,null)}attachTexture(e){const t=fe.getContext();t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e.getRawObject(),0)}attachDepthTexture(e){const t=fe.getContext();t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,e.getRawObject(),0)}attachRenderBuffer(e){const t=fe.getContext();t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,e.getRawObject())}attachCubeMap(e,t){const i=fe.getContext();i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,_e(t),e.getRawObject(),0)}getPixels(e,t,i,n,r){const a=fe.getContext();a.readPixels(e,t,i,n,a.RGBA,a.UNSIGNED_BYTE,r)}};var ye;!function(e){e[e.float=0]="float",e[e.vec2f=1]="vec2f",e[e.vec3f=2]="vec3f",e[e.vec4f=3]="vec4f",e[e.mat3f=4]="mat3f",e[e.mat4f=5]="mat4f"}(ye||(ye={}));const we=e=>{switch(e){case ye.float:return 1;case ye.vec2f:return 2;case ye.vec3f:return 3;case ye.vec4f:return 4;case ye.mat3f:return 9;case ye.mat4f:return 16}};var Se;!function(e){e[e.lines=0]="lines",e[e.lineStrip=1]="lineStrip",e[e.lineLoop=2]="lineLoop",e[e.triangles=3]="triangles",e[e.triangleStrip=4]="triangleStrip",e[e.triangleFan=5]="triangleFan"}(Se||(Se={}));const Te=e=>e instanceof Float32Array?e:new Float32Array(e),Ee=e=>{const t=fe.getContext();return"dynamic"===e?t.DYNAMIC_DRAW:"streaming"===e?t.STREAM_DRAW:t.STATIC_DRAW};class Re{constructor(e,t){this._primitiveStart=0,this._primitiveCount=0,this._instanceCount=0,this._isInstanced=!1;const i=fe.getContext();if(0===t.vbos.length)throw new Error("empty vbo definition");for(const i of t.vbos){if(0===i.attrs.length)throw new Error("empty vbo attribute definition");for(const t of i.attrs)if(!e.hasAttribute(t.name))throw new Error(`attribute not found, name="${t.name}"`)}switch(this._def=t,t.primitiveType){case Se.lines:this._primitiveType=i.LINES;break;case Se.lineStrip:this._primitiveType=i.LINE_STRIP;break;case Se.lineLoop:this._primitiveType=i.LINE_LOOP;break;case Se.triangles:this._primitiveType=i.TRIANGLES;break;case Se.triangleStrip:this._primitiveType=i.TRIANGLE_STRIP;break;case Se.triangleFan:this._primitiveType=i.TRIANGLE_FAN;break;default:throw new Error("primitive type not found")}const n=i.createVertexArray();if(!n)throw new Error("fail o create a vao unit");this._vao=n,i.bindVertexArray(this._vao),this._vbos=[];for(const t of this._def.vbos){const n=i.createBuffer();if(!n)throw new Error("fail o create a vbo unit");this._vbos.push({object:n,maxSize:0,mode:t.mode||"static"}),i.bindBuffer(i.ARRAY_BUFFER,n);let r=t.stride||0;if(!r){for(const e of t.attrs)switch(e.type){case ye.float:r+=1;break;case ye.vec2f:r+=2;break;case ye.vec3f:r+=3;break;case ye.vec4f:r+=4;break;case ye.mat3f:r+=9;break;case ye.mat4f:r+=16}r*=4}for(const n of t.attrs){let a=1,s=1;switch(n.type){case ye.float:a=1,s=1;break;case ye.vec2f:a=2,s=1;break;case ye.vec3f:a=3,s=1;break;case ye.vec4f:a=4,s=1;break;case ye.mat3f:a=3,s=3;break;case ye.mat4f:a=4,s=4}const o=e.getAttribute(n.name);for(let e=0;e<s;++e){const s=o+e,h=4*(n.index+e*a);i.enableVertexAttribArray(s),i.vertexAttribPointer(s,a,i.FLOAT,!1,r,h),!0===t.instanced&&(i.vertexAttribDivisor(s,1),this._isInstanced=!0)}}}i.bindVertexArray(null)}dispose(){const e=fe.getContext();for(const t of this._vbos)e.deleteBuffer(t.object);this._vbos.length=0,e.deleteVertexArray(this._vao)}setBufferSize(e,t){if(e<0||e>=this._vbos.length)throw new Error(`no vbo available to that index (input: ${e})`);if(t<=0)throw new Error(`vbo must be > 0 (input: ${t})`);const i=this._vbos[e];if(t<i.maxSize)return;i.maxSize=t;const n=fe.getContext();n.bindBuffer(n.ARRAY_BUFFER,i.object),n.bufferData(n.ARRAY_BUFFER,t,Ee(i.mode)),n.bindBuffer(n.ARRAY_BUFFER,null)}setFloatBufferSize(e,t){this.setBufferSize(e,4*t)}allocateBuffer(e,t,i){if(e<0||e>=this._vbos.length)throw new Error(`no vbo available to that index (input: ${e}, total vbos: ${this._vbos.length})`);if(i<=0)throw new Error(`size must be > 0 (input: ${i})`);const n=this._vbos[e];if(i<=0)throw new Error(`vbo must be > 0 (input: ${i})`);n.maxSize=i;const r=Te(t),a=fe.getContext();a.bindBuffer(a.ARRAY_BUFFER,n.object),a.bufferData(a.ARRAY_BUFFER,r,Ee(n.mode),0,i),a.bindBuffer(a.ARRAY_BUFFER,null)}updateBuffer(e,t,i,n){if(e<0||e>=this._vbos.length)throw new Error(`no vbo available to that index (input: ${e}, total vbos: ${this._vbos.length})`);if(i<=0)throw new Error(`size must be > 0 (input: ${i})`);const r=this._vbos[e];if(void 0!==n){if(n<0)throw new Error(`offset must be >= 0 (input: ${n})`);const e=n+i;if(e>r.maxSize)throw new Error(`offset + size > to vbo max size (input: ${e}, max size: ${r.maxSize})`)}else if(i>r.maxSize)throw new Error(`size must be < to vbo max size (input: ${i}, max size: ${r.maxSize})`);const a=Te(t),s=fe.getContext();s.bindBuffer(s.ARRAY_BUFFER,r.object),s.bufferSubData(s.ARRAY_BUFFER,null!=n?n:0,a.slice(0,i),0,i),s.bindBuffer(s.ARRAY_BUFFER,null)}render(){if(0==this._primitiveCount)return;if(this._isInstanced&&0==this._instanceCount)return;const e=fe.getContext();e.bindVertexArray(this._vao),!0===this._isInstanced?e.drawArraysInstanced(this._primitiveType,this._primitiveStart,this._primitiveCount,this._instanceCount):e.drawArrays(this._primitiveType,this._primitiveStart,this._primitiveCount),e.bindVertexArray(null)}setPrimitiveStart(e){this._primitiveStart=e}setPrimitiveCount(e){this._primitiveCount=e}setInstancedCount(e){this._instanceCount=e}}class Ae{constructor(){this._def={vbos:[],primitiveType:Se.lines}}reset(){return this._def={vbos:[],primitiveType:Se.lines},this}getDef(){return this._def}setPrimitiveType(e){return this._def.primitiveType=Se[e],this}addVbo(){return this._def.vbos.push({attrs:[],instanced:!1}),this}setVboAsInstanced(){return this._getLastVbo().instanced=!0,this}setVboAsDynamic(){return this._getLastVbo().mode="dynamic",this}setVboAsStreaming(){return this._getLastVbo().mode="streaming",this}setStride(e){return this._getLastVbo().stride=e,this}addVboAttribute(e,t){const i=this._getLastVbo(),n=i.attrs.length>0?i.attrs[i.attrs.length-1]:null;return i.attrs.push({name:e,type:ye[t],index:n?n.index+we(n.type):0}),this}_getLastVbo(){if(0===this._def.vbos.length)throw new Error("no VBO setup");return this._def.vbos[this._def.vbos.length-1]}}var Me=Object.freeze({__proto__:null,get AttributeType(){return ye},BytesPerPixel:4,Geometry:Re,GeometryBuilder:Ae,get PrimitiveType(){return Se}});class Ce{constructor(){const e=fe.getContext().createRenderbuffer();if(null===e)throw new Error("null render buffer object");this._buffer=e}dispose(){fe.getContext().deleteRenderbuffer(this._buffer)}rawBind(){const e=fe.getContext();e.bindRenderbuffer(e.RENDERBUFFER,this._buffer)}preBind(e){this.rawBind(),e(this)}bind(e){this.preBind(e),Ce.unbind()}static unbind(){const e=fe.getContext();e.bindRenderbuffer(e.RENDERBUFFER,null)}setSize(e,t,i){const n=fe.getContext();let r=n.DEPTH_COMPONENT32F;switch(e){case"depth16":case"depth24":r=n.DEPTH_COMPONENT16}n.renderbufferStorage(n.RENDERBUFFER,r,t,i)}getRawObject(){return this._buffer}}let De=class e{constructor(e,t){this._attributes=new Map,this._uniforms=new Map,this._name=e;const i=fe.getContext(),n=this._getShader(t.vertexSrc,i.VERTEX_SHADER),r=this._getShader(t.fragmentSrc,i.FRAGMENT_SHADER),a=i.createProgram();if(!a)throw new Error("could not create a shader program");if(i.attachShader(a,n),i.attachShader(a,r),i.linkProgram(a),i.deleteShader(n),i.deleteShader(r),!i.getProgramParameter(a,i.LINK_STATUS)){const e=i.getProgramInfoLog(a);throw new Error("Failed to initialized shaders, Error linking:"+e)}this._program=a,this.bind((()=>{this._getAttributes(t.attributes),this._getUniforms(t.uniforms)}))}dispose(){fe.getContext().deleteProgram(this._program)}bind(t){if(null!==e._isBound)throw new Error(`Double shader binding (bound: ${e._isBound._name}, binding: ${this._name})`);e._isBound=this,fe.getContext().useProgram(this._program),t(this),e.unbind()}static unbind(){fe.getContext().useProgram(null),e._isBound=null}isBound(){return e._isBound===this}hasAttribute(e){return this._attributes.has(e)}getAttribute(e){const t=this._attributes.get(e);if(void 0===t)throw new Error(`attribute not found: ${e}`);return t}getUniform(e){const t=this._uniforms.get(e);if(void 0===t)throw new Error(`uniform not found: ${e}`);return t}setTextureUniform(e,t,i){const n=fe.getContext();n.activeTexture(n.TEXTURE0+i),n.uniform1i(this.getUniform(e),i),t.rawBind()}setInteger1Uniform(e,t){fe.getContext().uniform1i(this.getUniform(e),t)}setInteger2Uniform(e,t,i){fe.getContext().uniform2i(this.getUniform(e),t,i)}setInteger3Uniform(e,t,i,n){fe.getContext().uniform3i(this.getUniform(e),t,i,n)}setFloat1Uniform(e,t){fe.getContext().uniform1f(this.getUniform(e),t)}setFloat2Uniform(e,t,i){fe.getContext().uniform2f(this.getUniform(e),t,i)}setFloat3Uniform(e,t,i,n){fe.getContext().uniform3f(this.getUniform(e),t,i,n)}setMatrix3Uniform(e,t){fe.getContext().uniformMatrix3fv(this.getUniform(e),!1,t)}setMatrix4Uniform(e,t){fe.getContext().uniformMatrix4fv(this.getUniform(e),!1,t)}_getAttributes(e){const t=fe.getContext();for(let i=0;i<e.length;++i){const n=t.getAttribLocation(this._program,e[i]);if(n<0)throw new Error(`attribute not found => ${e[i]}`);this._attributes.set(e[i],n)}}_getUniforms(e){const t=fe.getContext();for(let i=0;i<e.length;++i){const n=t.getUniformLocation(this._program,e[i]);if(null===n)throw new Error(`uniform not found => ${e[i]}`);this._uniforms.set(e[i],n)}}_getShader(e,t){const i=fe.getContext(),n=i.createShader(t);if(!n)throw new Error("could not create a shader");if(i.shaderSource(n,e),i.compileShader(n),!i.getShaderParameter(n,i.COMPILE_STATUS)){let e=i.getShaderInfoLog(n);throw e||(e="failed to compile a shader"),new Error(e)}return n}};var Pe,Ie;De._isBound=null,function(e){e[e.pixelated=0]="pixelated",e[e.linear=1]="linear",e[e.mipmap=2]="mipmap"}(Pe||(Pe={})),function(e){e[e.noRepeat=0]="noRepeat",e[e.repeat=1]="repeat"}(Ie||(Ie={}));let Be=class e{constructor(){this._width=0,this._height=0,this._texture=null}initialize(){if(this._texture)throw new Error("texture: already initialized");const e=fe.getContext();this._texture=e.createTexture()}rawBind(){if(!this._texture)throw new Error("texture: not initialized");const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,this._texture)}preBind(e){this.rawBind(),e(this)}bind(t){this.preBind(t),e.unbind()}static unbind(){const e=fe.getContext();e.bindTexture(e.TEXTURE_2D,null)}loadFromImage(e,t=Pe.pixelated,i=Ie.noRepeat){this._allocate(e.width,e.height,e,t,i)}loadFromMemory(e,t,i,n=Pe.pixelated,r=Ie.noRepeat){this._allocate(e,t,i,n,r)}allocate(e,t,i=Pe.pixelated,n=Ie.noRepeat){this._allocate(e,t,null,i,n)}allocateDepth(e,t,i=Pe.pixelated,n=Ie.noRepeat){this._allocate(e,t,null,i,n,!0)}resize(e,t,i=Pe.pixelated,n=Ie.noRepeat){this._allocate(e,t,null,i,n)}_allocate(e,t,i=null,n=Pe.pixelated,r=Ie.noRepeat,a=!1){if(!this._texture)throw new Error("texture: not initialized");if(e<=0)throw new Error("texture: width must be positive");if(t<=0)throw new Error("texture: height must be positive");const s=fe.getContext();this._width=e,this._height=t;const o=a?s.DEPTH_COMPONENT32F:s.RGBA,h=a?s.DEPTH_COMPONENT:s.RGBA,d=a?s.FLOAT:s.UNSIGNED_BYTE;i instanceof HTMLImageElement?s.texImage2D(s.TEXTURE_2D,0,o,h,d,i):s.texImage2D(s.TEXTURE_2D,0,o,e,t,0,h,d,i),r===Ie.noRepeat?(s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE)):r===Ie.repeat&&(s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.REPEAT),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.REPEAT)),n===Pe.pixelated?(s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.NEAREST)):n===Pe.linear?(s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.LINEAR),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.LINEAR)):n===Pe.mipmap&&(s.generateMipmap(s.TEXTURE_2D),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.LINEAR_MIPMAP_LINEAR))}getWidth(){if(!this._texture)throw new Error("texture not initialized");return this._width}getHeight(){if(!this._texture)throw new Error("texture not initialized");return this._height}getRawObject(){if(!this._texture)throw new Error("texture not initialized");return this._texture}};class ke{constructor(){this._width=0,this._height=0,this._texture=null}initialize(){if(this._texture)throw new Error("texture: already initialized");const e=fe.getContext();this._texture=e.createTexture()}dispose(){fe.getContext().deleteTexture(this._texture)}rawBind(){if(!this._texture)throw new Error("texture: not initialized");const e=fe.getContext();e.bindTexture(e.TEXTURE_2D_ARRAY,this._texture)}preBind(e){this.rawBind(),e(this)}bind(e){this.preBind(e),ke.unbind()}static unbind(){const e=fe.getContext();e.bindTexture(e.TEXTURE_2D_ARRAY,null)}loadFromImage(e,t,i,n,r=Pe.pixelated,a=Ie.noRepeat){this._allocate(e,t,i,n,r,a)}loadFromMemory(e,t,i,n,r=Pe.pixelated,a=Ie.noRepeat){this._allocate(e,t,i,n,r,a)}_allocate(e,t,i,n=null,r=Pe.pixelated,a=Ie.noRepeat){if(!this._texture)throw new Error("texture: not initialized");if(e<=0)throw new Error("texture: width must be positive");if(t<=0)throw new Error("texture: height must be positive");if(i<=0)throw new Error("texture: total layers must be positive");const s=fe.getContext();this._width=e,this._height=t;const o=s.RGBA,h=s.RGBA,d=s.UNSIGNED_BYTE;if(n instanceof HTMLImageElement)s.texImage3D(s.TEXTURE_2D_ARRAY,0,o,e,t,i,0,h,d,n);else{if(n){const r=e*t*i*4;if(n.length!==r)throw new Error(`wrong pixels buffer size for (3d) texture array, got ${n.length}/${r}`)}s.texImage3D(s.TEXTURE_2D_ARRAY,0,o,e,t,i,0,h,d,n)}a===Ie.noRepeat?(s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE)):a===Ie.repeat&&(s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_WRAP_S,s.REPEAT),s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_WRAP_T,s.REPEAT)),r===Pe.pixelated?(s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_MAG_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_MIN_FILTER,s.NEAREST)):r===Pe.linear?(s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_MAG_FILTER,s.LINEAR),s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_MIN_FILTER,s.LINEAR)):r===Pe.mipmap&&(s.generateMipmap(s.TEXTURE_2D_ARRAY),s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_MAG_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D_ARRAY,s.TEXTURE_MIN_FILTER,s.LINEAR_MIPMAP_LINEAR))}getWidth(){if(!this._texture)throw new Error("texture not initialized");return this._width}getHeight(){if(!this._texture)throw new Error("texture not initialized");return this._height}getRawObject(){if(!this._texture)throw new Error("texture not initialized");return this._texture}}var ze=Object.freeze({__proto__:null,CubeMap:ge,get CubeMapType(){return ue},DataTexture:pe,DataTexture2dVec4f32:me,DataTextureVec4f32:xe,DataTextureVec4u8:be,FenceSync:class{constructor(){}dispose(){this._sync&&(fe.getContext().deleteSync(this._sync),this._sync=void 0)}isStarted(){return void 0!==this._sync}start(){this._sync&&this.dispose();const e=fe.getContext(),t=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);if(null===t)throw new Error("could not create a webgl fence");this._sync=t,e.flush(),e.finish()}isSignaled(){if(!this._sync)throw new Error("fence not started");const e=fe.getContext();return e.getSyncParameter(this._sync,e.SYNC_STATUS)===e.SIGNALED}wait(e){if(!this._sync)throw new Error("fence not started");const t=fe.getContext();switch(t.clientWaitSync(this._sync,0,e)){case t.TIMEOUT_EXPIRED:return"timed-out";case t.WAIT_FAILED:return console.warn("fence.wait -> should never get here"),this.dispose(),"done";case t.ALREADY_SIGNALED:case t.CONDITION_SATISFIED:default:return this.dispose(),"done"}}},FrameBuffer:ve,GeometryWrapper:Me,RenderBuffer:Ce,ShaderProgram:De,Texture:Be,TextureArray:ke,get TextureFilter(){return Pe},get TextureRepeat(){return Ie},WebGLContext:fe,checkError:()=>{const e=fe.getContext();switch(e.getError()){case e.INVALID_ENUM:throw new Error("gl.INVALID_ENUM\nAn unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.");case e.INVALID_VALUE:throw new Error("gl.INVALID_VALUE\nA numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.");case e.INVALID_OPERATION:throw new Error("gl.INVALID_OPERATION\nThe specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.");case e.INVALID_FRAMEBUFFER_OPERATION:throw new Error("gl.INVALID_FRAMEBUFFER_OPERATION\nThe framebuffer object is not complete. The offending command is ignored and has no other side effect than to set the error flag.");case e.OUT_OF_MEMORY:throw new Error("gl.OUT_OF_MEMORY\nThere is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.");case e.CONTEXT_LOST_WEBGL:throw new Error("gl.CONTEXT_LOST_WEBGL\n If the WebGL context is lost, this error is returned on the first call to getError. Afterwards and until the context has been restored, it returns gl.NO_ERROR.")}},getCubeMapType:_e}),Fe="\n#version 300 es\n\nprecision highp float;\n\nuniform mat4 u_composedMatrix;\n\nin vec3 a_vertex_position;\nin vec3 a_vertex_normal;\n\nin vec3 a_offset_center;\nin vec4 a_offset_orientation;\nin vec3 a_offset_color;\nin vec3 a_offset_scale;\n\nflat out vec4 v_color;\nout vec3 v_worldSpacePosition;\nout vec3 v_worldSpaceNormal;\n\n\nvec3 apply_quat_to_vec3(vec3 position, vec4 q)\n{\n  vec3 v = position.xyz;\n  return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvoid main(void)\n{\n\tvec3 worldSpacePosition = a_offset_center + apply_quat_to_vec3(a_vertex_position * a_offset_scale, a_offset_orientation);\n\tvec3 worldSpaceNormal = apply_quat_to_vec3(a_vertex_normal, a_offset_orientation);\n\n  gl_Position = u_composedMatrix * vec4(worldSpacePosition, 1.0);\n\n  v_color = vec4(a_offset_color, 1.0);\n  v_worldSpacePosition = worldSpacePosition;\n  v_worldSpaceNormal = worldSpaceNormal;\n}\n".trim(),Le="\n#version 300 es\n\nprecision lowp float;\n\nuniform vec3 u_lightPos;\n\nflat in vec4 v_color;\nin vec3 v_worldSpacePosition;\nin vec3 v_worldSpaceNormal;\n\nout vec4 o_color;\n\n//\n//\n//\n\nconst float k_ambiantCoef = 0.1;\n\nconst vec3 k_specColor = vec3(1.0, 1.0, 1.0);\n\nvec3 _getLightColor(vec4 currentColor)\n{\n  vec3 normal = normalize(v_worldSpaceNormal);\n  vec3 lightDir = normalize(u_lightPos - v_worldSpacePosition);\n\n  float diffuseCoef = max(dot(lightDir, v_worldSpaceNormal.xyz), 0.0);\n  float specularCoef = 0.0;\n\n  // if (diffuseCoef > 0.0 && v_skipSpecular < 0.5)\n  // {\n  //   // specular\n\n  //   vec3 reflectDir = reflect(-lightDir, normal);\n  //   vec3 viewDir = normalize(u_lightPos - v_worldSpacePosition);\n\n  //   float specAngle = max(dot(reflectDir, viewDir), 0.0);\n  //   specularCoef = pow(specAngle, 32.0);\n  // }\n\n  vec3 diffuseColor = currentColor.rgb * (k_ambiantCoef + diffuseCoef);\n  vec3 specularColor = k_specColor * specularCoef * currentColor.a;\n\n  return diffuseColor + specularColor;\n}\n\n//\n//\n//\n\nvoid main(void)\n{\n  o_color = vec4(_getLightColor(v_color), 1.0);\n}\n".trim(),Ne="\n#version 300 es\n\nprecision highp float;\n\nuniform mat4 u_composedMatrix;\n\nin vec3 a_vertex_position;\n\nin vec3 a_offset_center;\nin vec4 a_offset_orientation;\nin vec3 a_offset_color;\nin vec3 a_offset_scale;\n\nflat out vec4 v_color;\n\nvec3 apply_quat_to_vec3(vec3 position, vec4 q)\n{\n  vec3 v = position.xyz;\n  return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvoid main(void)\n{\n\tvec3 worldSpacePosition = a_offset_center + apply_quat_to_vec3(a_vertex_position * a_offset_scale, a_offset_orientation);\n\n  gl_Position = u_composedMatrix * vec4(worldSpacePosition, 1.0);\n\n  v_color = vec4(a_offset_color, 1.0);\n}\n".trim(),Ve="\n#version 300 es\n\nprecision lowp float;\n\nflat in vec4 v_color;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  o_color = vec4(v_color.rbg, 1.0);\n}\n".trim();class Ue{constructor(e,t){this._width=0,this._height=0,this._frameBuffer=new ve,this._renderBuffer=new Ce,this._colorTextures=[],this._currentIndex=0,this._colorTextures.push(new Be),this._colorTextures.push(new Be),this._colorTextures.forEach((e=>e.initialize())),this.resize(e,t)}resize(e,t){this._width=e,this._height=t,this._renderBuffer.bind((e=>{e.setSize("depth32f",this._width,this._height)})),this._colorTextures.forEach((e=>{e.bind((e=>{e.allocate(this._width,this._height)}))})),this._frameBuffer.bind((e=>{this._renderBuffer.bind((t=>{e.attachRenderBuffer(t)}))}))}captureScene(e){this._frameBuffer.bind((t=>{this._colorTextures[this._currentIndex].bind((e=>{t.attachTexture(e)}));const i=fe.getContext();i.viewport(0,0,this._width,this._height),i.clearColor(0,0,0,0),e()})),this._currentIndex=(this._currentIndex+1)%this._colorTextures.length}get colorTexture(){return this._colorTextures[this._currentIndex]}}var Ge="\n#version 300 es\n\nprecision highp float;\n\nuniform mat4 u_composedMatrix;\n\nin vec3  a_vertex_position;\nin vec2  a_vertex_texCoord;\n\nout vec2 v_texCoord;\n\nvoid main(void)\n{\n  v_texCoord = a_vertex_texCoord;\n  gl_Position = u_composedMatrix * vec4(a_vertex_position, 1.0);\n}\n\n".trim(),Xe="\n#version 300 es\n\nprecision highp float;\n\nuniform sampler2D u_texture;\n\nin vec2 v_texCoord;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  o_color = texture(u_texture, v_texCoord);\n}\n".trim();class Oe{constructor(e,t){this._width=0,this._height=0,this._shader=new De("RenderHudTexture",{vertexSrc:Ge,fragmentSrc:Xe,attributes:["a_vertex_position","a_vertex_texCoord"],uniforms:["u_composedMatrix","u_texture"]});const i=new Ae;i.reset().setPrimitiveType("triangleStrip").addVbo().addVboAttribute("a_vertex_position","vec3f").addVboAttribute("a_vertex_texCoord","vec2f"),this._geometry=new Re(this._shader,i.getDef()),this.resize(e,t)}resize(e,t){this._width=e,this._height=t;const i=[{pos:[0*this._width,0*this._height,-1],tex:[0,0]},{pos:[1*this._width,0*this._height,-1],tex:[1,0]},{pos:[0*this._width,1*this._height,-1],tex:[0,1]},{pos:[1*this._width,1*this._height,-1],tex:[1,1]}].map((e=>[e.pos[0],e.pos[1],e.pos[2],e.tex[0],e.tex[1]])).flat();this._geometry.allocateBuffer(0,i,i.length),this._geometry.setPrimitiveCount(i.length/5)}flush(e,t){this._shader.bind((i=>{i.setMatrix4Uniform("u_composedMatrix",e),i.setTextureUniform("u_texture",t,0),this._geometry.render()}))}}class We{constructor(e,t){this._sceneCapturer=new Ue(e,t),this._renderHudTexture=new Oe(e,t)}resize(e,t){this._sceneCapturer.resize(e,t),this._renderHudTexture.resize(e,t)}captureScene(e){this._sceneCapturer.captureScene(e)}renderHud(e){this._renderHudTexture.flush(e,this._sceneCapturer.colorTexture)}}var He="\n#version 300 es\n\nprecision highp float;\n\nuniform mat4 u_composedMatrix;\n\nin vec3 a_vertex_position;\nin vec4 a_vertex_color;\n\nflat out vec4 v_color;\n\nvoid main(void)\n{\n  gl_Position = u_composedMatrix * vec4(a_vertex_position, 1.0);\n\n  v_color = a_vertex_color;\n}\n".trim(),Ye="\n#version 300 es\n\nprecision lowp float;\n\nflat in vec4 v_color;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  o_color = v_color;\n}\n".trim();class $e{constructor(e,t){this._buffer=new Float32Array(1048576),this._currentSize=0,this._shader=e;const i=Object.assign(Object.assign({},t),{primitiveType:Se.lines});this._geometry=new Re(e,i)}pushLine(e,t,i){if(this._currentSize+14>=this._buffer.length){if(!this._shader.isBound())return;this.flush()}const n=4==i.length?i[3]:1;this._buffer[this._currentSize+0]=e[0],this._buffer[this._currentSize+1]=e[1],this._buffer[this._currentSize+2]=e[2],this._buffer[this._currentSize+3]=i[0],this._buffer[this._currentSize+4]=i[1],this._buffer[this._currentSize+5]=i[2],this._buffer[this._currentSize+6]=n,this._currentSize+=7,this._buffer[this._currentSize+0]=t[0],this._buffer[this._currentSize+1]=t[1],this._buffer[this._currentSize+2]=t[2],this._buffer[this._currentSize+3]=i[0],this._buffer[this._currentSize+4]=i[1],this._buffer[this._currentSize+5]=i[2],this._buffer[this._currentSize+6]=n,this._currentSize+=7}canRender(){return this._currentSize>0}flush(){this.canRender()&&(this._geometry.allocateBuffer(0,this._buffer,this._currentSize),this._geometry.setPrimitiveCount(this._currentSize/7),this._geometry.render(),this.clear())}clear(){this._currentSize=0}}class qe{constructor(e,t){this._buffer=new Float32Array(1048576),this._currentSize=0,this._shader=e;const i=Object.assign(Object.assign({},t),{primitiveType:Se.triangles});this._geometry=new Re(e,i)}pushRawTriangle(e,t,i,n,r,a){if(this._currentSize+42>=this._buffer.length){if(!this._shader.isBound())return;this.flush()}const s=4==n.length?n[3]:1,o=4==n.length?n[3]:1,h=4==n.length?n[3]:1;this._buffer[this._currentSize+0]=e[0],this._buffer[this._currentSize+1]=e[1],this._buffer[this._currentSize+2]=e[2],this._buffer[this._currentSize+3]=n[0],this._buffer[this._currentSize+4]=n[1],this._buffer[this._currentSize+5]=n[2],this._buffer[this._currentSize+6]=s,this._currentSize+=7,this._buffer[this._currentSize+0]=t[0],this._buffer[this._currentSize+1]=t[1],this._buffer[this._currentSize+2]=t[2],this._buffer[this._currentSize+3]=r[0],this._buffer[this._currentSize+4]=r[1],this._buffer[this._currentSize+5]=r[2],this._buffer[this._currentSize+6]=o,this._currentSize+=7,this._buffer[this._currentSize+0]=i[0],this._buffer[this._currentSize+1]=i[1],this._buffer[this._currentSize+2]=i[2],this._buffer[this._currentSize+3]=a[0],this._buffer[this._currentSize+4]=a[1],this._buffer[this._currentSize+5]=a[2],this._buffer[this._currentSize+6]=h,this._currentSize+=7}pushTriangle(e,t,i,n){if(this._currentSize+42>=this._buffer.length){if(!this._shader.isBound())return;this.flush()}this.pushRawTriangle(e,t,i,n,n,n)}pushLine(e,t,i,n){if(this._currentSize+42>=this._buffer.length)return;const r=t[0]-e[0],a=t[1]-e[1],s=Math.atan2(a,r)+.5*Math.PI,o=Math.cos(s)*i*.5,h=Math.sin(s)*i*.5;this.pushTriangle([e[0]-o,e[1]-h,e[2]],[t[0]-o,t[1]-h,t[2]],[t[0]+o,t[1]+h,t[2]],n),this.pushTriangle([e[0]-o,e[1]-h,e[2]],[t[0]+o,t[1]+h,t[2]],[e[0]+o,e[1]+h,e[2]],n)}push3dLine(e,t,i,n,r,a){if(this._currentSize+42>=this._buffer.length)return;const s=t[0]-e[0],o=t[1]-e[1],h=t[2]-e[2],d=Math.atan2(o,s),c=Math.atan2(h,(l=s,f=o,Math.sqrt(l*l+f*f)));var l,f;const u=E(S());!function(e,t,i){var n=Math.sin(i),r=Math.cos(i),a=t[0],s=t[1],o=t[2],h=t[3],d=t[4],c=t[5],l=t[6],f=t[7];t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*r+d*n,e[1]=s*r+c*n,e[2]=o*r+l*n,e[3]=h*r+f*n,e[4]=d*r-a*n,e[5]=c*r-s*n,e[6]=l*r-o*n,e[7]=f*r-h*n}(u,u,d),M(u,u,-c);const _=(g=e,m=(p=t)[0]-g[0],x=p[1]-g[1],b=p[2]-g[2],Math.hypot(m,x,b));var g,p,m,x,b;const v=[[0*_,.5*+i,.5*+i],[0*_,.5*-i,.5*+i],[0*_,.5*-i,.5*-i],[0*_,.5*+i,.5*-i]],y=[[1*_,.5*+n,.5*+n],[1*_,.5*-n,.5*+n],[1*_,.5*-n,.5*-n],[1*_,.5*+n,.5*-n]];for(const t of v)X(t,t,u),z(t,t,e);for(const t of y)X(t,t,u),z(t,t,e);const w=[[{pos:v[0],color:r},{pos:v[1],color:r},{pos:y[0],color:a},{pos:y[1],color:a}],[{pos:v[1],color:r},{pos:v[2],color:r},{pos:y[1],color:a},{pos:y[2],color:a}],[{pos:v[2],color:r},{pos:v[3],color:r},{pos:y[2],color:a},{pos:y[3],color:a}],[{pos:v[3],color:r},{pos:v[0],color:r},{pos:y[3],color:a},{pos:y[0],color:a}]],T=[[0,3,2],[0,1,3]];for(const e of w)for(const t of T)this.pushRawTriangle(e[t[0]].pos,e[t[1]].pos,e[t[2]].pos,e[t[0]].color,e[t[1]].color,e[t[2]].color)}pushRotatedLine(e,t,i,n,r){this.pushLine([e[0]-i*Math.cos(t),e[1]-i*Math.sin(t),e[2]],[e[0]+i*Math.cos(t),e[1]+i*Math.sin(t),e[2]],n,r)}pushOriginBoundRectangle(e,t,i){if(this._currentSize+42>=this._buffer.length)return;const n=[e[0]+t[0],e[1]+t[1]];this.pushTriangle([e[0],e[1],e[2]],[n[0],n[1],e[2]],[e[0],n[1],e[2]],i),this.pushTriangle([e[0],e[1],e[2]],[n[0],e[1],e[2]],[n[0],n[1],e[2]],i)}pushCenteredRectangle(e,t,i){const n=[e[0]-.5*t[0],e[1]-.5*t[1],e[2]];this.pushOriginBoundRectangle(n,t,i)}canRender(){return this._currentSize>0}flush(){this.canRender()&&(this._geometry.allocateBuffer(0,this._buffer,this._currentSize),this._geometry.setPrimitiveCount(this._currentSize/7),this._geometry.render(),this.clear())}clear(){this._currentSize=0}}var je="\n#version 300 es\n\nprecision highp float;\n\nuniform mat4 u_composedMatrix;\n\nin vec2 a_vertex_position;\nin vec2 a_vertex_texCoord;\nin vec3 a_offset_position;\nin vec2 a_offset_texCoord;\nin vec3 a_offset_color;\nin float a_offset_scale;\n\nout vec2 v_texCoord;\nflat out vec3 v_color;\n\nvoid main(void)\n{\n  vec3 position = vec3(a_vertex_position, 0.0) * a_offset_scale + a_offset_position;\n\n  gl_Position = u_composedMatrix * vec4(position, 1.0);\n\n  v_texCoord = a_vertex_texCoord + a_offset_texCoord;\n  v_color = a_offset_color;\n}\n".trim(),Ke="\n#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D u_texture;\n\nin vec2 v_texCoord;\nflat in vec3 v_color;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  vec4 textureColor = texture(u_texture, v_texCoord);\n  if (textureColor.a < 0.5)\n  {\n    discard;\n  }\n  else\n  {\n    o_color = vec4(v_color, textureColor.a);\n  }\n}\n".trim();const Ze=[16,6],Qe=[1/Ze[0],1/Ze[1]],Je=[.2,.2,.2],et=[.2,.6,.2],tt=(e,t,i)=>{const{center:n}=e;t.pushCenteredRectangle(I(n[0],n[1],-.3),e.size,[0,0,0]),t.pushCenteredRectangle(I(n[0],n[1],-.2),[e.size[0]-2,e.size[1]-2],e.color),e.text&&i.setTextScale(16).setTextAlign("centered","centered").pushText(e.text,n).setTextAlign("left","top"),e.lines&&e.lines.forEach((e=>{t.pushThickLine([n[0]+e.a[0],n[1]+e.a[1],0],[n[0]+e.b[0],n[1]+e.b[1],0],e.thickness,e.color)}))},it=(e,t,i)=>{tt({center:[e[0],e[1]],size:[40,40],text:"A\nQ",color:o.isPressed("A","Q")?et:Je},t,i),tt({center:[e[0]+45,e[1]],size:[40,40],text:"S",color:o.isPressed("S")?et:Je},t,i),tt({center:[e[0]+45,e[1]+45],size:[40,40],text:"W\nZ",color:o.isPressed("W","Z")?et:Je},t,i),tt({center:[e[0]+90,e[1]],size:[40,40],text:"D",color:o.isPressed("D")?et:Je},t,i)},nt=(e,t,i)=>{tt({center:[e[0],e[1]],size:[40,40],lines:[{a:[15,0],b:[-8,0],thickness:6,color:[1,1,1]},{a:[0,10],b:[-12,-2],thickness:6,color:[1,1,1]},{a:[0,-10],b:[-12,2],thickness:6,color:[1,1,1]}],color:o.isPressed("ArrowLeft")?et:Je},t,i),tt({center:[e[0]+45,e[1]],size:[40,40],lines:[{a:[0,15],b:[0,-8],thickness:6,color:[1,1,1]},{a:[10,0],b:[-2,-12],thickness:6,color:[1,1,1]},{a:[-10,0],b:[2,-12],thickness:6,color:[1,1,1]}],color:o.isPressed("ArrowDown")?et:Je},t,i),tt({center:[e[0]+45,e[1]+45],size:[40,40],lines:[{a:[0,-15],b:[0,8],thickness:6,color:[1,1,1]},{a:[10,0],b:[-2,12],thickness:6,color:[1,1,1]},{a:[-10,0],b:[2,12],thickness:6,color:[1,1,1]}],color:o.isPressed("ArrowUp")?et:Je},t,i),tt({center:[e[0]+90,e[1]],size:[40,40],lines:[{a:[-15,0],b:[8,0],thickness:6,color:[1,1,1]},{a:[0,10],b:[12,-2],thickness:6,color:[1,1,1]},{a:[0,-10],b:[12,2],thickness:6,color:[1,1,1]}],color:o.isPressed("ArrowRight")?et:Je},t,i)},rt=(e,t,i,n)=>{m.isSupported(e)?tt({center:[t[0]+115,t[1]],size:[230,60],text:"Touch Events\nSupported\n(double tap)",color:[0,.5,0]},i,n):tt({center:[t[0]+115,t[1]],size:[230,60],text:"Touch Events\nNot Supported",color:[.5,0,0]},i,n),g.canBePointerLocked(e)?tt({center:[t[0]+105,t[1]+70],size:[210,60],text:"Mouse\nSupported",color:[0,.5,0]},i,n):tt({center:[t[0]+105,t[1]+70],size:[210,60],text:"Mouse Events\nNot Supported",color:[.5,0,0]},i,n)},at=(e,t,i,n,r,a=!1)=>{const s=5*Math.ceil(i.maxDelta/5);{n.pushOriginBoundRectangle(e,t,[0,0,0,.5]);const i=[[e[0]+0*t[0],e[1]+0*t[1],0],[e[0]+1*t[0],e[1]+0*t[1],0],[e[0]+1*t[0],e[1]+1*t[1],0],[e[0]+0*t[0],e[1]+1*t[1],0]];n.pushLine(i[0],i[1],[1,1,1]),n.pushLine(i[1],i[2],[1,1,1]),n.pushLine(i[2],i[3],[1,1,1]),n.pushLine(i[3],i[0],[1,1,1])}for(let i=5;i<s;i+=5){const r=i/s,a=[e[0]+0,e[1]+t[1]*r,0],o=[e[0]+t[0],e[1]+t[1]*r,0];n.pushLine(a,o,[.5,.5,.5])}if(i.framesDelta.length>=2){const r=t[0]/i.framesDelta.length;let a=i.framesDelta[0],o=0,h=t[1]*a/s;for(let d=1;d<i.framesDelta.length;++d){const c=i.framesDelta[d],l=d*r,f=t[1]*c/s,u=[e[0]+o,e[1]+h,0],_=[e[0]+l,e[1]+f,0];n.pushLine(u,_,[1,1,1]),a=c,o=l,h=f}}{const n=14,s=.5*n,o=i.averageDelta,h=i.maxDelta,d=i.minDelta;let c=`~${o.toFixed(0)}ms`,l=`<${h}ms`,f=`>${d}ms`;if(!0===a){const e=e=>e<999?e.toFixed(0):"???";c+=`\n~${e(1e3/o)}fps`,l+=`\n<${e(1e3/h)}fps`,f+=`\n>${e(1e3/d)}fps`}r.setTextScale(n).setTextAlign("left","top").setTextColor(1,1,.75).pushText(c,[e[0]+7,e[1]-8]).setTextAlign("left","centered").setTextColor(1,.75,.75).pushText(l,[e[0]+t[0]+s,e[1]+t[1]-1*s]).setTextColor(.75,1,.75).pushText(f,[e[0]+t[0]+s,e[1]+1*s]).setTextColor(1,1,1)}};var st=Object.freeze({__proto__:null,addArrowStrokesWidgets:nt,addKeyStrokesWidgets:it,addKeysTouchesWidgets:rt,renderFpsMeter:at}),ot=Object.freeze({__proto__:null,GeometryRenderer:class{constructor(){this._buffer=new Float32Array(14336),this._currentSize=0,this._shader=new De("GeometryRenderer",{vertexSrc:Fe,fragmentSrc:Le,attributes:["a_vertex_position","a_vertex_normal","a_offset_center","a_offset_orientation","a_offset_color","a_offset_scale"],uniforms:["u_composedMatrix","u_lightPos"]});const e=new Ae;e.reset().setPrimitiveType("triangles").addVbo().addVboAttribute("a_vertex_position","vec3f").addVboAttribute("a_vertex_normal","vec3f").addVbo().setVboAsStreaming().setVboAsInstanced().addVboAttribute("a_offset_center","vec3f").addVboAttribute("a_offset_orientation","vec4f").addVboAttribute("a_offset_color","vec3f").addVboAttribute("a_offset_scale","vec3f"),this._geometry=new Re(this._shader,e.getDef()),this._geometry.setFloatBufferSize(1,14336)}setGeometryVertices(e){const t=new Float32Array([...e.map((e=>[...e.pos,...e.normal])).flat()]);this._geometry.allocateBuffer(0,t,t.length),this._geometry.setPrimitiveCount(t.length/6)}push(e,t,i,n){if(this._currentSize+13>=this._buffer.length){if(!this._shader.isBound())return;this._flush()}this._buffer[this._currentSize++]=e[0],this._buffer[this._currentSize++]=e[1],this._buffer[this._currentSize++]=e[2],this._buffer[this._currentSize++]=t[0],this._buffer[this._currentSize++]=t[1],this._buffer[this._currentSize++]=t[2],this._buffer[this._currentSize++]=t[3],this._buffer[this._currentSize++]=i[0],this._buffer[this._currentSize++]=i[1],this._buffer[this._currentSize++]=i[2],this._buffer[this._currentSize++]=n[0],this._buffer[this._currentSize++]=n[1],this._buffer[this._currentSize++]=n[2]}flush(e){this.canRender()&&this._shader.bind((t=>{t.setMatrix4Uniform("u_composedMatrix",e.getComposedMatrix());const i=e.getEye();t.setFloat3Uniform("u_lightPos",i[0],i[1],i[2]),this._flush()}))}safeRender(e,t){this._shader.bind((i=>{i.setMatrix4Uniform("u_composedMatrix",e.getComposedMatrix());const n=e.getEye();i.setFloat3Uniform("u_lightPos",n[0],n[1],n[2]),t(),this._flush()}))}_flush(){this._geometry.updateBuffer(1,this._buffer,this._currentSize,0),this._geometry.setInstancedCount(this._currentSize/13),this._geometry.render(),this.clear()}canRender(){return this._currentSize>0}clear(){this._currentSize=0}},GeometryRendererFlat:class{constructor(){this._buffer=new Float32Array(14336),this._currentSize=0,this._shader=new De("GeometryRendererFlat",{vertexSrc:Ne,fragmentSrc:Ve,attributes:["a_vertex_position","a_offset_center","a_offset_orientation","a_offset_color","a_offset_scale"],uniforms:["u_composedMatrix"]});const e=new Ae;e.reset().setPrimitiveType("triangles").addVbo().addVboAttribute("a_vertex_position","vec3f").addVbo().setVboAsStreaming().setVboAsInstanced().addVboAttribute("a_offset_center","vec3f").addVboAttribute("a_offset_orientation","vec4f").addVboAttribute("a_offset_color","vec3f").addVboAttribute("a_offset_scale","vec3f"),this._geometry=new Re(this._shader,e.getDef()),this._geometry.setFloatBufferSize(1,14336)}setGeometryVertices(e){const t=new Float32Array([...e.map((e=>[...e.pos])).flat()]);this._geometry.allocateBuffer(0,t,t.length),this._geometry.setPrimitiveCount(t.length/3)}push(e,t,i,n){if(this._currentSize+13>=this._buffer.length){if(!this._shader.isBound())return;this._flush()}this._buffer[this._currentSize++]=e[0],this._buffer[this._currentSize++]=e[1],this._buffer[this._currentSize++]=e[2],this._buffer[this._currentSize++]=t[0],this._buffer[this._currentSize++]=t[1],this._buffer[this._currentSize++]=t[2],this._buffer[this._currentSize++]=t[3],this._buffer[this._currentSize++]=i[0],this._buffer[this._currentSize++]=i[1],this._buffer[this._currentSize++]=i[2],this._buffer[this._currentSize++]=n[0],this._buffer[this._currentSize++]=n[1],this._buffer[this._currentSize++]=n[2]}flush(e){this.canRender()&&this._shader.bind((t=>{t.setMatrix4Uniform("u_composedMatrix",e.getComposedMatrix()),this._flush()}))}safeRender(e,t){this._shader.bind((i=>{i.setMatrix4Uniform("u_composedMatrix",e.getComposedMatrix()),t(),this._flush()}))}_flush(){this._geometry.updateBuffer(1,this._buffer,this._currentSize,0),this._geometry.setInstancedCount(this._currentSize/13),this._geometry.render(),this.clear()}canRender(){return this._currentSize>0}clear(){this._currentSize=0}},MultiBuffersRendering:We,StackRenderers:class{constructor(){this._shader=new De("StackRenderers",{vertexSrc:He,fragmentSrc:Ye,attributes:["a_vertex_position","a_vertex_color"],uniforms:["u_composedMatrix"]});const e=new Ae;e.reset().setPrimitiveType("lines").addVbo().setVboAsDynamic().addVboAttribute("a_vertex_position","vec3f").addVboAttribute("a_vertex_color","vec4f"),this._wireFramesStackRenderer=new $e(this._shader,e.getDef()),this._trianglesStackRenderer=new qe(this._shader,e.getDef())}pushLine(e,t,i){this._wireFramesStackRenderer.pushLine(e,t,i)}pushCross(e,t,i){const n=[[e[0]-t,e[1],e[2]],[e[0]+t,e[1],e[2]],[e[0],e[1]-t,e[2]],[e[0],e[1]+t,e[2]],[e[0],e[1],e[2]-t],[e[0],e[1],e[2]+t]],r=[0,1,2,3,4,5];for(let e=0;e<r.length;e+=2){const t=n[e+0],r=n[e+1];this._wireFramesStackRenderer.pushLine(t,r,i)}}pushThickLine(e,t,i,n){this._trianglesStackRenderer.push3dLine(e,t,i,i,n,n)}push3dLine(e,t,i,n,r,a){this._trianglesStackRenderer.push3dLine(e,t,i,n,r,a)}pushRotatedLine(e,t,i,n,r){this._trianglesStackRenderer.pushRotatedLine(e,t,i,n,r)}pushOriginBoundRectangle(e,t,i){this._trianglesStackRenderer.pushOriginBoundRectangle(e,t,i)}pushCenteredRectangle(e,t,i){this._trianglesStackRenderer.pushCenteredRectangle(e,t,i)}pushTriangle(e,t,i,n){this._trianglesStackRenderer.pushTriangle(e,t,i,n)}pushQuad(e,t,i){this.pushTriangle([e[0]+0*t[0],e[1]+0*t[1],e[2]],[e[0]+1*t[0],e[1]+1*t[1],e[2]],[e[0]+1*t[0],e[1]+0*t[1],e[2]],i),this.pushTriangle([e[0]+0*t[0],e[1]+0*t[1],e[2]],[e[0]+1*t[0],e[1]+1*t[1],e[2]],[e[0]+0*t[0],e[1]+1*t[1],e[2]],i)}flush(e){(this._wireFramesStackRenderer.canRender()||this._trianglesStackRenderer.canRender())&&this._shader.bind((t=>{t.setMatrix4Uniform("u_composedMatrix",e),this._wireFramesStackRenderer.flush(),this._trianglesStackRenderer.flush()}))}safeRender(e,t){this._shader.bind((i=>{i.setMatrix4Uniform("u_composedMatrix",e),t(),this._wireFramesStackRenderer.flush(),this._trianglesStackRenderer.flush()}))}clear(){this._wireFramesStackRenderer.clear(),this._trianglesStackRenderer.clear()}},TextRenderer:class{constructor(){this._texture=new Be,this._buffer=new Float32Array(36864),this._currentSize=0,this._textScale=14,this._textColor=[1,1,1],this._horizontalTextAlign="left",this._verticalTextAlign="top",this._shader=new De("TextRenderer",{vertexSrc:je,fragmentSrc:Ke,attributes:["a_vertex_position","a_vertex_texCoord","a_offset_position","a_offset_texCoord","a_offset_color","a_offset_scale"],uniforms:["u_composedMatrix","u_texture"]});const e=new Ae;e.reset().setPrimitiveType("triangles").addVbo().addVboAttribute("a_vertex_position","vec2f").addVboAttribute("a_vertex_texCoord","vec2f").setStride(16).addVbo().setVboAsDynamic().setVboAsInstanced().addVboAttribute("a_offset_position","vec3f").addVboAttribute("a_offset_texCoord","vec2f").addVboAttribute("a_offset_color","vec3f").addVboAttribute("a_offset_scale","float").setStride(36),this._geometry=new Re(this._shader,e.getDef());const t=[{position:[.5,-.5],texCoord:[1*Qe[0],1*Qe[1]]},{position:[-.5,-.5],texCoord:[0*Qe[0],1*Qe[1]]},{position:[.5,.5],texCoord:[1*Qe[0],0*Qe[1]]},{position:[-.5,.5],texCoord:[0*Qe[0],0*Qe[1]]}],i=[1,0,2,1,2,3],n=[];for(const e of i){const i=t[e];n.push(i.position[0],i.position[1],i.texCoord[0],i.texCoord[1])}this._geometry.allocateBuffer(0,n,n.length),this._geometry.setPrimitiveCount(n.length/4),this._texCoordMap=new Map([[" ",[0*Qe[0],0*Qe[1]]],["!",[1*Qe[0],0*Qe[1]]],['"',[2*Qe[0],0*Qe[1]]],["#",[3*Qe[0],0*Qe[1]]],["$",[4*Qe[0],0*Qe[1]]],["%",[5*Qe[0],0*Qe[1]]],["&",[6*Qe[0],0*Qe[1]]],["'",[7*Qe[0],0*Qe[1]]],["(",[8*Qe[0],0*Qe[1]]],[")",[9*Qe[0],0*Qe[1]]],["*",[10*Qe[0],0*Qe[1]]],["+",[11*Qe[0],0*Qe[1]]],[",",[12*Qe[0],0*Qe[1]]],["-",[13*Qe[0],0*Qe[1]]],[".",[14*Qe[0],0*Qe[1]]],["/",[15*Qe[0],0*Qe[1]]],["0",[0*Qe[0],1*Qe[1]]],["1",[1*Qe[0],1*Qe[1]]],["2",[2*Qe[0],1*Qe[1]]],["3",[3*Qe[0],1*Qe[1]]],["4",[4*Qe[0],1*Qe[1]]],["5",[5*Qe[0],1*Qe[1]]],["6",[6*Qe[0],1*Qe[1]]],["7",[7*Qe[0],1*Qe[1]]],["8",[8*Qe[0],1*Qe[1]]],["9",[9*Qe[0],1*Qe[1]]],[":",[10*Qe[0],1*Qe[1]]],[";",[11*Qe[0],1*Qe[1]]],["<",[12*Qe[0],1*Qe[1]]],["=",[13*Qe[0],1*Qe[1]]],[">",[14*Qe[0],1*Qe[1]]],["?",[15*Qe[0],1*Qe[1]]],["@",[0*Qe[0],2*Qe[1]]],["A",[1*Qe[0],2*Qe[1]]],["B",[2*Qe[0],2*Qe[1]]],["C",[3*Qe[0],2*Qe[1]]],["D",[4*Qe[0],2*Qe[1]]],["E",[5*Qe[0],2*Qe[1]]],["F",[6*Qe[0],2*Qe[1]]],["G",[7*Qe[0],2*Qe[1]]],["H",[8*Qe[0],2*Qe[1]]],["I",[9*Qe[0],2*Qe[1]]],["J",[10*Qe[0],2*Qe[1]]],["K",[11*Qe[0],2*Qe[1]]],["L",[12*Qe[0],2*Qe[1]]],["M",[13*Qe[0],2*Qe[1]]],["N",[14*Qe[0],2*Qe[1]]],["O",[15*Qe[0],2*Qe[1]]],["P",[0*Qe[0],3*Qe[1]]],["Q",[1*Qe[0],3*Qe[1]]],["R",[2*Qe[0],3*Qe[1]]],["S",[3*Qe[0],3*Qe[1]]],["T",[4*Qe[0],3*Qe[1]]],["U",[5*Qe[0],3*Qe[1]]],["V",[6*Qe[0],3*Qe[1]]],["W",[7*Qe[0],3*Qe[1]]],["X",[8*Qe[0],3*Qe[1]]],["Y",[9*Qe[0],3*Qe[1]]],["Z",[10*Qe[0],3*Qe[1]]],["[",[11*Qe[0],3*Qe[1]]],["\\",[12*Qe[0],3*Qe[1]]],["]",[13*Qe[0],3*Qe[1]]],["^",[14*Qe[0],3*Qe[1]]],["_",[15*Qe[0],3*Qe[1]]],["`",[0*Qe[0],4*Qe[1]]],["a",[1*Qe[0],4*Qe[1]]],["b",[2*Qe[0],4*Qe[1]]],["c",[3*Qe[0],4*Qe[1]]],["d",[4*Qe[0],4*Qe[1]]],["e",[5*Qe[0],4*Qe[1]]],["f",[6*Qe[0],4*Qe[1]]],["g",[7*Qe[0],4*Qe[1]]],["h",[8*Qe[0],4*Qe[1]]],["i",[9*Qe[0],4*Qe[1]]],["j",[10*Qe[0],4*Qe[1]]],["k",[11*Qe[0],4*Qe[1]]],["l",[12*Qe[0],4*Qe[1]]],["m",[13*Qe[0],4*Qe[1]]],["n",[14*Qe[0],4*Qe[1]]],["o",[15*Qe[0],4*Qe[1]]],["p",[0*Qe[0],5*Qe[1]]],["q",[1*Qe[0],5*Qe[1]]],["r",[2*Qe[0],5*Qe[1]]],["s",[3*Qe[0],5*Qe[1]]],["t",[4*Qe[0],5*Qe[1]]],["u",[5*Qe[0],5*Qe[1]]],["v",[6*Qe[0],5*Qe[1]]],["w",[7*Qe[0],5*Qe[1]]],["x",[8*Qe[0],5*Qe[1]]],["y",[9*Qe[0],5*Qe[1]]],["z",[10*Qe[0],5*Qe[1]]],["{",[11*Qe[0],5*Qe[1]]],["|",[12*Qe[0],5*Qe[1]]],["}",[13*Qe[0],5*Qe[1]]],["~",[14*Qe[0],5*Qe[1]]]]);const r=new Uint8Array(98304);{let e=0;for(let t=0;t<5818;t+=2){let i=parseInt(`${"7e7e28fd03fd07fe04fe0aff02ff7e4dfd0cfd03fd07fe04fe0aff02ff1afc0dfd10fc08fc0ffe55ff15fb0bfd03fd07fe04fe08f707fd04ff07fe02fe0cfd0ffd0cfd0aff03fe03ff0afe44fe15fb0bfd03fd04f204f607fd03fe07fe02fe0cfd0efd0efd0aff02fe02ff0bfe43fd15fb0cfe03fe05f204fe01ff02ff0afd02fd07fe02fe0bfd0efd10fd0afa0cfe42fd16fb1bfe04fe07fe01ff02ff0efd09fc1cfd12fd09fa0cfe41fd17fb1bfe04fe07f70bfd0afc04ff17fd12fd06f405f616f61cfd19fd1cfe04fe08f709fd0bfb02fe17fd12fd06f405f616f61bfd1afd1cfe04fe0aff02ff01fe08fd0bfe02fa17fd12fd09fa0cfe3efd37f207ff02ff01fe07fd02fd07fe03fc19fd10fd0afa0cfe3dfd38f204f607fe03fd07fe03fd1bfd0efd0aff02fe02ff0bfe0cfd1dfd0dfd1dfd1cfe04fe07f708ff04fd07fe02fb1bfd0cfd0aff03fe03ff0afe0cfd1dfd0cfd1efd1cfe04fe0aff02ff1afb02fe1bfc08fc0ffe1cfd1dfd0bfd1ffd1cfe04fe0aff02ff7afd7e7e7e7e7e7e0efd17fd10fc0af80bfe0bf909f90dfd08f609fb08f506f808f82cfd19fd0df807fd04fd0afe0afd03fd07fd03fd0bfc08fd0ffd0bfd05fd05fd04fd06fd04fd2afd1bfd0bfc02fc06fd03fc09fd0afd04fd06fd04fd09fb08fd0efd0cfd05fd05fd04fd06fd04fd09fd0cfd0efd1dfd0afe05fd06fd02fb06fa11fd0dfd08fe01fd08fd0dfd0dfd05fd05fd04fd06fd04fd09fd0cfd0dfd0af409fd10fd06fd02fb06fa10fd0dfd08fe02fd08fd0dfd15fd05fb02fd06fd04fd09fd0cfd0cfd0bf40afd0efd07fd01fe01fd09fd0ffd0bfb08fe03fd08f808f70efd08fa08f626fd23fd0cfd08fd01fe01fd09fd0efd0cfb08f606f707f60cfd09fa09f726fd23fd0bfd09fb02fd09fd0dfd10fd07f60cfc06fd04fd0bfd08fd02fb0dfd09fd0cfd0cfd0bf40afd0cfd09fb02fd09fd0cfd12fd0bfd0ffd06fd04fd0afd09fd04fd0dfd09fd0cfd0dfd0af409fd19fc03fd09fd0bfd03fd06fd04fd0bfd08fd04fd06fd04fd09fd0afd04fd0cfd0afd0cfd0efd1dfd1afd04fd09fd0afd04fd06fd03fd0cfd08fd03fd07fd04fd09fd0afd04fd0bfd19fd10fd1bfd0ffd0af807f707f607f90bf907f909f80afd0bf809fb2efd19fd10fd7e51fd17fd11fd7e7e7e7e13f87e78fd05fd08fc09f709f907f808f606f608f907fd03fd07f90df905fc03fd06fb0bfd05fd05fd05fd08fb08fd05fd07fa09fd03fd07fd03fd07fd02fd08fd04fe07fd04fe07fd03fd06fd03fd09fd11fd08fd03fd07fd0cfc03fc05fd05fd07fd01fd07fd05fd06fd02fd08fd03fd06fd04fd07fd03fd07fd05ff07fd05ff06fd04fd06fd03fd09fd11fd08fd02fd08fd0cfb01fb05fc04fd06fd03fd06fd05fd05fd04fd07fd03fd06fd0efd03fd07fd0dfd0cfd04fd06fd03fd09fd11fd08fd01fd09fd0cf505fb03fd05fd05fd05fd02fa05fd04fd07fd03fd06fd0efd03fd07fd03fe08fd03fe07fd0dfd03fd09fd11fd08fa0afd0cf505fa02fd05fd05fd05fd02fa05fd04fd07f807fd0efd03fd07f808f807fd0df709fd11fd08fb0bfd0cfd01fd01fd05fd01fd01fd05fd05fd05fd02fa05fd04fd07f807fd0efd03fd07f808f807fd0df709fd11fd08fb0bfd0cfd02ff02fd05fd02fa05fd05fd05fd02fa05f607fd03fd06fd0efd03fd07fd03fe08fd03fe07fd02fb06fd03fd09fd0bfd03fd08fa0afd0cfd05fd05fd03fb05fd05fd05fd0dfd04fd07fd03fd06fd0efd03fd07fd0dfd0cfd04fd06fd03fd09fd0bfd03fd08fd01fd09fd05ff06fd05fd05fd04fc05fd05fd05fd0dfd04fd07fd03fd06fd04fd07fd03fd07fd05ff07fd0cfd04fd06fd03fd09fd0bfd03fd08fd02fd08fd04fe06fd05fd05fd05fd06fd03fd06fd0dfd04fd07fd03fd07fd03fd07fd02fd08fd04fe07fd0dfd03fd06fd03fd09fd0bfd03fd08fd03fd07fd03fd06fd05fd05fd05fd07fd01fd07fd0dfd04fd06f709f907f808f606fb0df806fd03fd07f90af908fc03fd06f606fd05fd05fd05fd08fb0af87e7e7e7e7e7e7e68fe1af70afb08f708f807f505fd03fd07fd03fd07fd05fd05fd03fd07fd03fd07f608f907ff11f90afc1afd03fd07fc01fc07fd03fd06fd04fd06fe02fd02fe05fd03fd07fd03fd07fd05fd05fd03fd07fd03fd07fd04fd08fd0bfe14fd09fa19fd03fd07fd03fd07fd03fd06fd04fd06ff03fd03ff05fd03fd07fd03fd07fd05fd05fd03fd07fd03fd07fe05fd08fd0bfd13fd08fd02fd18fd03fd06fd05fd06fd03fd06fd04fd0afd09fd03fd07fd03fd07fd05fd06fd01fd08fd03fd07ff05fd09fd0cfd12fd07fd04fd17fd03fd06fd05fd06fd03fd06fd11fd09fd03fd07fd03fd07fd05fd07fb09fd03fd0cfd0afd0dfd11fd28f807fd05fd06f808f90cfd09fd03fd07fd03fd07fd02ff02fd08fd0bfd01fd0cfd0bfd0efd10fd28f807fd05fd06f809f90bfd09fd03fd07fd03fd07fd02ff02fd08fd0cfb0cfd0cfd0ffd0ffd28fd0cfd03fb06fd02fd0efd0afd09fd03fd07fd03fd07fd02ff02fd07fb0cfd0cfd0dfd10fd0efd28fd0cfd02fa06fd03fd06fd04fd0afd09fd03fd07fd03fd08f707fd01fd0bfd0bfd05ff08fd11fd0dfd28fd0df707fd03fd06fd04fd0afd09fd03fd08fd01fd09fc01fc06fd03fd0afd0afd05fe08fd12fd0cfd28fd0df707fd03fd06fd04fd0afd09fd03fd09fb0bfd01fd07fd03fd0afd0afd04fd08fd13fd0bfd27fb12fd06fc03fd07f809f908f90bfd0cfd01fd07fd03fd08f908f608f910fd06f93cfa7e54f07e72f07e7e7e7e0bfd1dfc21fb19fb18fc10fd0ffd07fc0dfa39fd1efd22fd19fd01fd18fd10fd0ffd08fd10fd3bfd1cfd22fd19fd01fd18fd10fd0ffd08fd10fd3bfd1cfd22fd19fd1cfd2dfd10fd4af909f808f909f808f90afd0cfb02fe07fd01fc08fa0cfa08fd03fd0afd09f606f809f91efd08fd03fd06fd03fd07fd03fd07fd03fd07f808fd03fd08fc02fd0afd0ffd08fd02fd0bfd09fd02ff02fd05fd03fd07fd03fd1dfd08fd03fd06fd03fd07fd03fd07fd03fd07f808fd03fd08fc02fd0afd0ffd08fd01fd0cfd09fd02ff02fd05fd03fd07fd03fd18f808fd03fd06fd0dfd03fd07f709fd0bfd03fd08fd03fd0afd0ffd08fa0dfd09fd02ff02fd05fd03fd07fd03fd17fd03fd08fd03fd06fd0dfd03fd07fd0ffd0bfd03fd08fd03fd0afd0ffd08fd01fd0cfd09fd02ff02fd05fd03fd07fd03fd17fd03fd08fd03fd06fd03fd07fd03fd07fd03fd09fd0cf808fd03fd0afd0ffd08fd02fd0bfd09fd02ff02fd05fd03fd07fd03fd17fd03fd08fd03fd06fd03fd07fd03fd07fd03fd09fd0df908fd03fd0afd0ffd08fd03fd0afd09fd02ff02fd05fd03fd07fd03fd18fb02fe06fe02fb08f909fb02fe07f908f90ffd07fc03fd07f706fd03fd07fc03fd07f706fd05fd05fd03fd08f978fd03fd27fd03fd7e4af92afa7e7e7e7e7e7e18fa09fc09fa1efe4eff6efd0dfc0dfd1cfc4cfe6efd0dfc0dfd1bfa4afd6efd0dfc0dfd1afd02fd07fe02fb07fb02fe07fc02fd08f908f707fd03fd07fd03fd07fd05fd05fd02fd09fd03fd06f80afd0efc0efd08fb03fd05fd04fd07fd03fd05fd03fd09f706fd04fe09fd0bfd03fd07fd03fd07fd05fd05fd02fd09fd03fd06fe03fd08fd24fd05fd01fd02fd05fe06fe07fd03fd05fd03fd09fc02fd06fd04fe09fd0bfd03fd07fd03fd07fd05fd06fa0afd03fd06ff03fd09fd24fd05fd02fd01fd05fe06fe07fd03fd05fd03fd09fd0dfb0cfd0bfd03fd07fd03fd07fd02ff02fd07fc0bfd03fd09fd0cfd0efc0efd07fd03fb06fe06fe07fd03fd05fd03fd09fd0ffb0afd0bfd03fd07fd03fd07fd02ff02fd07fc0bfd03fd08fd0efd0dfc0dfd19fe06fe07fd03fd05fd03fd09fd0cfe04fd09fd01fd07fd03fd08fd01fd09fc01fc07fa0bf908fd03ff0bfd0dfc0dfd19fe06fe07f807f809fd0cfe04fd09fd01fd07fd03fd09fb0bfd01fd07fd02fd0bfb08fd03fe0bfd0dfc0dfd19f607fd11fd08fb0cf90bfb09fb02fe09fd0cfd01fd07fd02fd0dfd08f80cfa09fc09fa1af607fd11fd7cfd69fb0ffb77fa".substring(t,t+2)}000000`,16)>>24,n=0;i<0&&(i=-i,n=255);for(let t=0;t<i;++t)r[4*e+0]=n,r[4*e+1]=n,r[4*e+2]=n,r[4*e+3]=n,++e}}this._texture.initialize(),this._texture.bind((e=>{e.loadFromMemory(256,96,r)}))}setTextAlign(e,t){return this._horizontalTextAlign=e,this._verticalTextAlign=t,this}setTextScale(e){return this._textScale=e,this}setTextColor(e,t,i){return this._textColor[0]=e,this._textColor[1]=t,this._textColor[2]=i,this}pushText(e,t){if(0===e.length)return this;if(this._textScale<=0)return this;const i=[0];for(let t=0;t<e.length;++t)"\n"==e[t]?i.push(0):i[i.length-1]+=1;if(0===i.length)return this;let n=0;const r=[0,0],a=.5*this._textScale;switch(this._horizontalTextAlign){case"left":r[0]=t[0];break;case"centered":r[0]=t[0]-i[n]*a+a;break;case"right":r[0]=t[0]-i[n]*this._textScale+this._textScale}switch(this._verticalTextAlign){case"top":r[1]=t[1];break;case"centered":r[1]=t[1]+i.length*a-a;break;case"bottom":r[1]=t[1]-(i.length-1)*this._textScale}for(let s=0;s<e.length;++s){const o=e[s];if("\n"==o){switch(n+=1,this._horizontalTextAlign){case"left":r[0]=t[0];break;case"centered":r[0]=t[0]-i[n]*a+a;break;case"right":r[0]=t[0]-i[n]*this._textScale+this._textScale}r[1]-=this._textScale}else this._pushLetter(o,r),r[0]+=this._textScale}return this}_pushLetter(e,t){if(this._currentSize+90>=this._buffer.length)return;const i=this._texCoordMap.get(e);if(!i)throw new Error(`fail to find a letter, letter=${e}`);for(let e=-1;e<=1;++e)for(let n=-1;n<=1;++n)this._buffer[this._currentSize++]=t[0]+2*n,this._buffer[this._currentSize++]=t[1]+2*e,this._buffer[this._currentSize++]=-.1,this._buffer[this._currentSize++]=i[0],this._buffer[this._currentSize++]=i[1],this._buffer[this._currentSize++]=0,this._buffer[this._currentSize++]=0,this._buffer[this._currentSize++]=0,this._buffer[this._currentSize++]=this._textScale;this._buffer[this._currentSize++]=t[0],this._buffer[this._currentSize++]=t[1],this._buffer[this._currentSize++]=0,this._buffer[this._currentSize++]=i[0],this._buffer[this._currentSize++]=i[1],this._buffer[this._currentSize++]=this._textColor[0],this._buffer[this._currentSize++]=this._textColor[1],this._buffer[this._currentSize++]=this._textColor[2],this._buffer[this._currentSize++]=this._textScale}flush(e){return 0===this._currentSize||(this._shader.bind((t=>{t.setMatrix4Uniform("u_composedMatrix",e),t.setTextureUniform("u_texture",this._texture,0),this._geometry.allocateBuffer(1,this._buffer,this._currentSize),this._geometry.setInstancedCount(this._currentSize/9),this._geometry.render()})),Be.unbind(),this.clear()),this}clear(){return this._currentSize=0,this}},widgets:st});const ht=(e,t,i,n,r,a)=>{if(t<=0)e.push({pos:N(D(),n,i),normal:B(D(),n)}),e.push({pos:N(D(),a,i),normal:B(D(),a)}),e.push({pos:N(D(),r,i),normal:B(D(),r)});else{const s=V(D(),G(D(),n,r,.5)),o=V(D(),G(D(),r,a,.5)),h=V(D(),G(D(),a,n,.5));ht(e,t-=1,i,n,s,h),ht(e,t,i,s,r,o),ht(e,t,i,h,o,a),ht(e,t,i,s,o,h)}};class dt{constructor(e){if(this._lines=[],this._maxLines=30,this._textAreaElement=document.getElementById(e),!this._textAreaElement)throw new Error(`DOM elements not found, id=${e}`);this._textAreaElement.value=""}log(...e){if(0===e.length)return;const t=Array.prototype.slice.call(e).join(" ");console.log(t),this._pushText(t)}error(...e){if(0===e.length)return;const t=Array.prototype.slice.call(e).join(" ");console.error(t),this._pushText(`[ERR] - ${t}`)}_pushText(e){this._lines.push(e),this._lines.length>this._maxLines&&this._lines.splice(0,this._lines.length-this._maxLines),this._textAreaElement.value=`${this._lines.join("\n")}\n`,this._textAreaElement.scrollTop=this._textAreaElement.scrollHeight}peekLast(){if(this._lines.length>0)return this._lines[this._lines.length-1]}popLast(){this._lines.length>0&&this._lines.splice(this._lines.length-1,1)}}function ct(e,t,i,n){return new(i||(i=Promise))((function(r,a){function s(e){try{h(n.next(e))}catch(e){a(e)}}function o(e){try{h(n.throw(e))}catch(e){a(e)}}function h(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,o)}h((n=n.apply(e,t||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;class lt{static load(e){return ct(this,void 0,void 0,(function*(){yield lt.loadJsPart(e.jsUrl),yield lt.loadWasmPart(e.wasmUrl)}))}static loadJsPart(e){return ct(this,void 0,void 0,(function*(){var t;yield(t=e,new Promise(((e,i)=>{const n=document.createElement("script");n.src=t,n.addEventListener("load",e),n.addEventListener("error",i),document.head.appendChild(n)})))}))}static loadWasmPart(e){return ct(this,void 0,void 0,(function*(){lt._wasmModule=yield FrankenPhysLoader({locateFile:t=>`${e}/${t}`})}))}static get(){if(!this._wasmModule)throw new Error("FrankenPhys wasm module not loaded");return this._wasmModule}}class ft{constructor(){this._listenersMap=new Map}isEventListenedTo(e){const t=this._listenersMap.get(e);return!!t&&t.length>0}addEventListener(e,t){let i=this._listenersMap.get(e);if(i||(i=[],this._listenersMap.set(e,i)),-1!==i.indexOf(t))throw new Error(`duplicated event listener, type=${e}`);i.push(t)}on(e,t){this.addEventListener(e,t)}hasEventListener(e,t){const i=this._listenersMap.get(e);return void 0!==i&&-1!==i.indexOf(t)}removeEventListener(e,t){const i=this._listenersMap.get(e);if(void 0===i)return;const n=i.indexOf(t);if(-1===n)throw new Error(`unknown event listener, type=${e}`);i.splice(n,1)}dispatchEvent(e){const t=this._listenersMap.get(e.type);if(void 0===t)return;const i=t.slice(0);for(let t=0;t<i.length;++t)i[t].call(this,e)}}class ut{static set(e){return ct(this,void 0,void 0,(function*(){ut._wasmModule=e}))}static get(){if(!this._wasmModule)throw new Error("FrankenPhys wasm module not loaded");return this._wasmModule}}var _t="undefined"!=typeof Float32Array?Float32Array:Array;function gt(){var e=new _t(3);return _t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function pt(e,t,i){var n=new _t(3);return n[0]=e,n[1]=t,n[2]=i,n}function mt(e,t,i,n){var r=new _t(4);return r[0]=e,r[1]=t,r[2]=i,r[3]=n,r}function xt(){var e=new _t(4);return _t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),gt(),function(){var e=new _t(4);_t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0)}(),gt(),pt(1,0,0),pt(0,1,0),xt(),xt(),function(){var e=new _t(9);_t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1}(),function(){var e=new _t(2);_t!=Float32Array&&(e[0]=0,e[1]=0)}();const bt=(e,t)=>{const i=ut.get(),n=new i.btVector3(t.from[0],t.from[1],t.from[2]),r=new i.btVector3(t.to[0],t.to[1],t.to[2]),a=new i.btTransform;a.setIdentity(),a.setOrigin(n);const s=new i.btTransform;s.setIdentity(),s.setOrigin(r);const o=new i.ClosestConvexResultCallback(n,r);o.set_m_collisionFilterGroup(t.collisionFilterGroup),o.set_m_collisionFilterMask(t.collisionFilterMask);const h=new i.btSphereShape(t.radius);if(e.convexSweepTest(h,a,s,o,0),!o.hasHit())return i.destroy(n),i.destroy(r),i.destroy(o),i.destroy(h),i.destroy(a),void i.destroy(s);const d=o.get_m_hitPointWorld(),c=o.get_m_hitNormalWorld(),l=o.get_m_closestHitFraction(),f=pt(d.x(),d.y(),d.z()),u=pt(c.x(),c.y(),c.z());return i.destroy(c),i.destroy(d),i.destroy(n),i.destroy(r),i.destroy(o),i.destroy(h),i.destroy(a),i.destroy(s),{fraction:l,impact:f,normal:u}};class vt extends ft{constructor(e,t){super(),this._isAlive=!0;const i=ut.get();this._customShape=t;const n=new i.btVector3;this._customShape.shape.calculateLocalInertia(e.mass,n);const r=new i.btRigidBodyConstructionInfo(e.mass,null,this._customShape.shape,n);this._rawRigidBody=new i.btRigidBody(r),this.setPositionAndRotation(e.position,e.orientation),i.destroy(n),i.destroy(r)}dispose(){ut.get().destroy(this._rawRigidBody),this._customShape.cleanup(),this._rawRigidBody=null,this._isAlive=!1}isAlive(){return this._isAlive}setPositionAndRotation(e,t){const i=ut.get(),n=new i.btVector3(e[0],e[1],e[2]),r=new i.btQuaternion(t[0],t[1],t[2],t[3]),a=new i.btTransform(r,n);this._rawRigidBody.setWorldTransform(a),i.destroy(a),i.destroy(n),i.destroy(r)}setPosition(e,t,i){const n=ut.get(),r=this.getRotation(),a=new n.btVector3(e,t,i),s=new n.btQuaternion(r[0],r[1],r[2],r[3]),o=new n.btTransform(s,a);this._rawRigidBody.setWorldTransform(o),n.destroy(o),n.destroy(a),n.destroy(s)}setRotation(e,t,i,n){const r=ut.get(),a=this.getPosition(),s=new r.btVector3(a[0],a[1],a[2]),o=new r.btQuaternion(e,t,i,n),h=new r.btTransform(o,s);this._rawRigidBody.setWorldTransform(h),r.destroy(h),r.destroy(s),r.destroy(o)}getPositionAndRotation(e,t){const i=ut.get(),n=this._rawRigidBody.getWorldTransform(),r=n.getOrigin(),a=n.getRotation();e[0]=r.x(),e[1]=r.y(),e[2]=r.z(),t[0]=a.x(),t[1]=a.y(),t[2]=a.z(),t[3]=a.w(),i.destroy(a),i.destroy(r),i.destroy(n)}getPosition(){const e=ut.get(),t=this._rawRigidBody.getWorldTransform(),i=t.getOrigin(),n=pt(i.x(),i.y(),i.z());return e.destroy(i),e.destroy(t),n}getRotation(){const e=ut.get(),t=this._rawRigidBody.getWorldTransform(),i=t.getRotation(),n=mt(i.x(),i.y(),i.z(),i.w());return e.destroy(i),e.destroy(t),n}getLinearVelocity(){const e=ut.get(),t=this._rawRigidBody.getLinearVelocity(),i=pt(t.x(),t.y(),t.z());return e.destroy(t),i}getAngularVelocity(){const e=ut.get(),t=this._rawRigidBody.getAngularVelocity(),i=pt(t.x(),t.y(),t.z());return e.destroy(t),i}setLinearVelocity(e,t,i){const n=ut.get(),r=new n.btVector3(e,t,i);this._rawRigidBody.setLinearVelocity(r),n.destroy(r)}setAngularVelocity(e,t,i){const n=ut.get(),r=new n.btVector3(e,t,i);this._rawRigidBody.setAngularVelocity(r),n.destroy(r)}setLinearFactor(e,t,i){const n=ut.get(),r=new n.btVector3(e,t,i);this._rawRigidBody.setLinearFactor(r),n.destroy(r)}setAngularFactor(e,t,i){const n=ut.get(),r=new n.btVector3(e,t,i);this._rawRigidBody.setAngularFactor(r),n.destroy(r)}applyCentralForce(e,t,i){const n=ut.get(),r=new n.btVector3(e,t,i);this._rawRigidBody.applyCentralForce(r),n.destroy(r)}applyCentralImpulse(e,t,i){const n=ut.get(),r=new n.btVector3(e,t,i);this._rawRigidBody.applyCentralImpulse(r),n.destroy(r)}setDamping(e,t=0){this._rawRigidBody.setDamping(e,t)}setCcdMotionThreshold(e){this._rawRigidBody.setCcdMotionThreshold(e)}setCcdSweptSphereRadius(e){this._rawRigidBody.setCcdSweptSphereRadius(e)}setRestitution(e){this._rawRigidBody.setRestitution(e)}setFriction(e){this._rawRigidBody.setFriction(e)}setRollingFriction(e){this._rawRigidBody.setRollingFriction(e)}setGravity(e,t,i){const n=ut.get(),r=new n.btVector3(e,t,i);this._rawRigidBody.setGravity(r),n.destroy(r)}isStaticObject(){return this._rawRigidBody.isStaticObject()}isKinematicObject(){return this._rawRigidBody.isKinematicObject()}isStaticOrKinematicObject(){return this._rawRigidBody.isStaticOrKinematicObject()}isActive(){return this.isStaticOrKinematicObject()||this._rawRigidBody.isActive()}enableDeactivation(){this._rawRigidBody.activate(!0)}disableDeactivation(){this._rawRigidBody.setActivationState(4)}cannotDeactivate(){return this.isStaticOrKinematicObject()||4==this._rawRigidBody.getActivationState()}canDeactivate(){return!this.cannotDeactivate()}}class yt{constructor(e,t,i){const n=ut.get();this._chassisBody=t,this._vehicleTuning=new n.btVehicleTuning,this._defaultVehicleRaycaster=new n.btDefaultVehicleRaycaster(e),this._rawVehicle=new n.btRaycastVehicle(this._vehicleTuning,t._rawRigidBody,this._defaultVehicleRaycaster),this._rawVehicle.setCoordinateSystem(i.coordinateSystem[0],i.coordinateSystem[1],i.coordinateSystem[2]);const r=new n.btVector3(i.groundDirection[0],i.groundDirection[1],i.groundDirection[2]),a=new n.btVector3(i.rotationAxis[0],i.rotationAxis[1],i.rotationAxis[2]),s=new n.btVector3;for(let e=0;e<i.wheels.length;++e){const t=i.wheels[e];s.setValue(t.connectionPoint[0],t.connectionPoint[1],t.connectionPoint[2]);const n=this._rawVehicle.addWheel(s,r,a,i.suspensionRestLength,i.wheelRadius,this._vehicleTuning,t.isFrontWheel);n.set_m_suspensionStiffness(i.suspensionStiffness),n.set_m_wheelsDampingRelaxation(i.wheelsDampingRelaxation),n.set_m_wheelsDampingCompression(i.wheelsDampingCompression),n.set_m_frictionSlip(i.wheelFriction),n.set_m_rollInfluence(i.rollInfluence)}n.destroy(s),n.destroy(r),n.destroy(a)}dispose(){const e=ut.get();e.destroy(this._rawVehicle),e.destroy(this._defaultVehicleRaycaster),e.destroy(this._vehicleTuning)}getChassisBody(){return this._chassisBody}setSteeringValue(e,t){this._rawVehicle.setSteeringValue(t,e)}applyEngineForce(e,t){this._rawVehicle.applyEngineForce(t,e)}setBrake(e,t){this._rawVehicle.setBrake(t,e)}getWheeTransforms(){const e=ut.get(),t=[],i=this._rawVehicle.getNumWheels();for(let n=0;n<i;++n){this._rawVehicle.updateWheelTransform(n,!0);const i=this._rawVehicle.getWheelTransformWS(n),r=i.getOrigin(),a=i.getRotation();t.push({position:pt(r.x(),r.y(),r.z()),rotation:mt(a.x(),a.y(),a.z(),a.w())}),e.destroy(a),e.destroy(r),e.destroy(i)}return t}}class wt{constructor(e){this._bodyA=e.bodyA,this._bodyB=e.bodyB;const t=ut.get(),i=e.bodyA._rawRigidBody,n=e.bodyB._rawRigidBody,r=new t.btQuaternion(0,0,1,0),a=new t.btVector3(e.frameA[0],e.frameA[1],e.frameA[2]),s=new t.btTransform(r,a),o=new t.btVector3(e.frameB[0],e.frameB[1],e.frameB[2]),h=new t.btTransform(r,o);this._rawConstraint=new t.btGeneric6DofSpringConstraint(i,n,s,h,e.useReferenceFrameA),this._rawConstraint.enableSpring(0,!1),this._rawConstraint.enableSpring(1,!1),this._rawConstraint.enableSpring(2,!1),this._rawConstraint.setStiffness(0,1),this._rawConstraint.setStiffness(1,1),this._rawConstraint.setStiffness(2,1),this._rawConstraint.setDamping(0,1),this._rawConstraint.setDamping(1,1),this._rawConstraint.setDamping(2,1),t.destroy(s),t.destroy(h),t.destroy(a),t.destroy(o),t.destroy(r)}dispose(){ut.get().destroy(this._rawConstraint)}setLinearLowerLimit(e){const t=ut.get(),i=new t.btVector3(e[0],e[1],e[2]);this._rawConstraint.setLinearLowerLimit(i),t.destroy(i)}setLinearUpperLimit(e){const t=ut.get(),i=new t.btVector3(e[0],e[1],e[2]);this._rawConstraint.setLinearUpperLimit(i),t.destroy(i)}setAngularLowerLimit(e){const t=ut.get(),i=new t.btVector3(e[0],e[1],e[2]);this._rawConstraint.setAngularLowerLimit(i),t.destroy(i)}setAngularUpperLimit(e){const t=ut.get(),i=new t.btVector3(e[0],e[1],e[2]);this._rawConstraint.setAngularUpperLimit(i),t.destroy(i)}}class St{constructor(e){this._bodyA=e.bodyA,this._bodyB=e.bodyB;const t=ut.get(),i=e.bodyA._rawRigidBody,n=e.bodyB._rawRigidBody,r=new t.btVector3(e.pivotInA[0],e.pivotInA[1],e.pivotInA[2]),a=new t.btVector3(e.pivotInB[0],e.pivotInB[1],e.pivotInB[2]),s=new t.btVector3(e.axisInA[0],e.axisInA[1],e.axisInA[2]),o=new t.btVector3(e.axisInB[0],e.axisInB[1],e.axisInB[2]);this._rawConstraint=new t.btHingeConstraint(i,n,r,a,s,o,e.useReferenceFrameA),t.destroy(r),t.destroy(a),t.destroy(s),t.destroy(o)}dispose(){ut.get().destroy(this._rawConstraint)}setLimit(e,t,i,n,r){this._rawConstraint.setLimit(e,t,i,n,r)}enableAngularMotor(e,t,i){this._rawConstraint.enableAngularMotor(e,t,i)}enableMotor(e){this._rawConstraint.enableMotor(e)}setMaxMotorImpulse(e){this._rawConstraint.setMaxMotorImpulse(e)}setMotorTarget(e,t){this._rawConstraint.setMotorTarget(e,t)}}const Tt=(e,t,i)=>{const n=ut.get(),r=new n.btVector3(i.from[0],i.from[1],i.from[2]),a=new n.btVector3(i.to[0],i.to[1],i.to[2]),s=new n.ClosestRayResultCallback(r,a);if(s.set_m_collisionFilterGroup(i.collisionFilterGroup),s.set_m_collisionFilterMask(i.collisionFilterMask),e.rayTest(r,a,s),!s.hasHit())return n.destroy(r),n.destroy(a),void n.destroy(s);const o=t.get(s.get_m_collisionObject().ptr);if(!o)return n.destroy(r),n.destroy(a),void n.destroy(s);const h=s.get_m_hitNormalWorld(),d=s.get_m_hitPointWorld(),c=pt(d.x(),d.y(),d.z()),l=pt(h.x(),h.y(),h.z());return n.destroy(h),n.destroy(d),n.destroy(r),n.destroy(a),n.destroy(s),{object:o,fraction:s.get_m_closestHitFraction(),impact:c,normal:l}};var Et;!function(e){e[e.DBG_NoDebug=0]="DBG_NoDebug",e[e.DBG_DrawWireframe=1]="DBG_DrawWireframe",e[e.DBG_DrawAabb=2]="DBG_DrawAabb",e[e.DBG_DrawFeaturesText=4]="DBG_DrawFeaturesText",e[e.DBG_DrawContactPoints=8]="DBG_DrawContactPoints",e[e.DBG_NoDeactivation=16]="DBG_NoDeactivation",e[e.DBG_NoHelpText=32]="DBG_NoHelpText",e[e.DBG_DrawText=64]="DBG_DrawText",e[e.DBG_ProfileTimings=128]="DBG_ProfileTimings",e[e.DBG_EnableSatComparison=256]="DBG_EnableSatComparison",e[e.DBG_DisableBulletLCP=512]="DBG_DisableBulletLCP",e[e.DBG_EnableCCD=1024]="DBG_EnableCCD",e[e.DBG_DrawConstraints=2048]="DBG_DrawConstraints",e[e.DBG_DrawConstraintLimits=4096]="DBG_DrawConstraintLimits",e[e.DBG_FastWireframe=8192]="DBG_FastWireframe",e[e.DBG_DrawNormals=16384]="DBG_DrawNormals",e[e.DBG_DrawFrames=32768]="DBG_DrawFrames"}(Et||(Et={}));var Rt=lt,At=Object.freeze({__proto__:null,ConcretePhysicBody:vt,ConcretePhysicVehicle:yt,ContactEventHandler:ft,get DebugDrawFlags(){return Et},PhysicWorld:class extends ft{constructor(){super(),this._bodyMap=new Map,this._vehicleMap=new Map,this._constraintMap=new Map,this._allConstraints=[],this._constraintMap2=new Map,this._allConstraints2=[];const e=ut.get();this._collisionConf=new e.btDefaultCollisionConfiguration,this._dispatcher=new e.btCollisionDispatcher(this._collisionConf),this._broadPhase=new e.btDbvtBroadphase,this._solver=new e.btSequentialImpulseConstraintSolver,this._rawDynamicsWorld=new e.btjsDynamicsWorld(this._dispatcher,this._broadPhase,this._solver,this._collisionConf),this._rawDynamicsWorld.setGravity(new e.btVector3(0,0,-10)),this._initCollisionEvents()}dispose(){const e=ut.get();this._allConstraints.forEach((e=>e.dispose())),this._allConstraints.length=0,this._constraintMap.clear(),this._allConstraints2.forEach((e=>e.dispose())),this._allConstraints2.length=0,this._constraintMap2.clear(),[...this._vehicleMap.values()].forEach((e=>e.dispose())),this._vehicleMap.clear(),[...this._bodyMap.values()].forEach((e=>e.dispose())),this._bodyMap.clear(),e.destroy(this._rawDynamicsWorld),e.destroy(this._solver),e.destroy(this._broadPhase),e.destroy(this._dispatcher),e.destroy(this._collisionConf)}createRigidBody(e){const t=this._getShape(e.shape,e.mass>0),i=new vt(e,t);return this._rawDynamicsWorld.addRigidBody(i._rawRigidBody,-1,-1),this._bodyMap.set(i._rawRigidBody.ptr,i),i}_getShape(e,t){const i=ut.get();switch(e.type){case"box":{const t=new i.btVector3;t.setValue(.5*e.size[0],.5*e.size[1],.5*e.size[2]);const n=new i.btBoxShape(t);return i.destroy(t),{shape:n,cleanup:()=>i.destroy(n)}}case"sphere":{const t=new i.btSphereShape(e.radius);return{shape:t,cleanup:()=>i.destroy(t)}}case"cylinder":{const t=new i.btVector3(e.radius,e.radius,e.length),n=new i.btCylinderShape(t);return{shape:n,cleanup:()=>{i.destroy(n),i.destroy(t)}}}case"capsule":{const t=new i.btCapsuleShape(e.radius,e.length);return{shape:t,cleanup:()=>i.destroy(t)}}case"mesh":{const n=new i.btTriangleMesh,r=new i.btVector3,a=new i.btVector3,s=new i.btVector3;if(e.triangles.forEach((([e,t,i])=>{r.setValue(e[0],e[1],e[2]),a.setValue(t[0],t[1],t[2]),s.setValue(i[0],i[1],i[2]),n.addTriangle(r,a,s)})),i.destroy(r),i.destroy(a),i.destroy(s),t){const e=new i.btGImpactMeshShape(n),t=this._rawDynamicsWorld.createCompoundFromGimpactShape(e,0);return{shape:t,cleanup:()=>{i.destroy(t),i.destroy(e),i.destroy(n)}}}const o=new i.btBvhTriangleMeshShape(n,!0);return{shape:o,cleanup:()=>{i.destroy(o),i.destroy(n)}}}case"compound":{const n=new i.btCompoundShape,r=[],a=new i.btVector3,s=new i.btQuaternion(0,0,1,0),o=new i.btTransform;for(const{shape:i,position:h,orientation:d}of e.shapes){const e=this._getShape(i,t);r.push(e),a.setValue(h[0],h[1],h[2]),s.setValue(d[0],d[1],d[2],d[3]),o.setOrigin(a),o.setRotation(s),n.addChildShape(o,e.shape)}return i.destroy(a),i.destroy(s),i.destroy(o),{shape:n,cleanup:()=>{i.destroy(n);for(const e of r)i.destroy(e)}}}}}destroyRigidBody(e){const t=e._rawRigidBody,i=t.ptr;this._rawDynamicsWorld.removeRigidBody(t),this._bodyMap.delete(i),e.dispose();const n=this._constraintMap.get(i);if(n)for(const e of n)this.destroyGeneric6DofConstraint(e);const r=this._constraintMap2.get(i);if(r)for(const e of r)this.destroyHingeConstraint(e)}createVehicle(e){const t=this.createRigidBody(e.chassisDef),i=new yt(this._rawDynamicsWorld,t,e);return this._rawDynamicsWorld.addAction(i._rawVehicle),this._vehicleMap.set(i.ptr,i),i}destroyVehicle(e){this.destroyRigidBody(e._chassisBody),this._rawDynamicsWorld.removeAction(e._rawVehicle),this._vehicleMap.delete(e.ptr),e.dispose()}createGeneric6DofConstraint(e){const t=new wt(e),i=e.bodyA._rawRigidBody.ptr;let n=this._constraintMap.get(i);n||(n=[],this._constraintMap.set(i,n)),n.push(t);const r=e.bodyB._rawRigidBody.ptr;let a=this._constraintMap.get(r);return a||(a=[],this._constraintMap.set(i,a)),a.push(t),this._allConstraints.push(t),this._rawDynamicsWorld.addConstraint(t._rawConstraint,!0),t}destroyGeneric6DofConstraint(e){const t=e;this._rawDynamicsWorld.removeConstraint(t._rawConstraint);const i=this._constraintMap.get(t._bodyA._rawRigidBody.ptr);if(i){const e=i.indexOf(t);e>=0&&i.splice(e,0)}const n=this._constraintMap.get(t._bodyB._rawRigidBody.ptr);if(n){const e=n.indexOf(t);e>=0&&n.splice(e,0)}const r=this._allConstraints.indexOf(t);r>=0&&this._allConstraints.splice(r,0),t.dispose()}createHingeConstraint(e){const t=new St(e),i=e.bodyA._rawRigidBody.ptr;let n=this._constraintMap2.get(i);n||(n=[],this._constraintMap2.set(i,n)),n.push(t);const r=e.bodyB._rawRigidBody.ptr;let a=this._constraintMap2.get(r);return a||(a=[],this._constraintMap2.set(i,a)),a.push(t),this._allConstraints2.push(t),this._rawDynamicsWorld.addConstraint(t._rawConstraint,!0),t}destroyHingeConstraint(e){const t=e;this._rawDynamicsWorld.removeConstraint(t._rawConstraint);const i=this._constraintMap2.get(t._bodyA._rawRigidBody.ptr);if(i){const e=i.indexOf(t);e>=0&&i.splice(e,0)}const n=this._constraintMap2.get(t._bodyB._rawRigidBody.ptr);if(n){const e=n.indexOf(t);e>=0&&n.splice(e,0)}const r=this._allConstraints2.indexOf(t);r>=0&&this._allConstraints2.splice(r,0),t.dispose()}rayCast(e,t){return Tt(this._rawDynamicsWorld,this._bodyMap,{from:e,to:t,collisionFilterGroup:-1,collisionFilterMask:-1})}convexSweep(e,t,i){return bt(this._rawDynamicsWorld,{from:e,to:t,collisionFilterGroup:-1,collisionFilterMask:-1,radius:i})}_initCollisionEvents(){const e=e=>{const t=e.data.getBodyA(),i=e.data.getBodyB(),n=this._bodyMap.get(t.ptr),r=this._bodyMap.get(i.ptr);if(!n||!r)return;const a=e.type,s=(this.isEventListenedTo(a)?1:0)|(n.isEventListenedTo(a)?2:0)|(r.isEventListenedTo(a)?4:0);if(0==s)return;const o=e.data.getId(),h=e.data.getPosition(),d=e.data.getNormalB(),c={x:h.x(),y:h.y(),z:h.z()},l={x:d.x(),y:d.y(),z:d.z()};1&s&&this.dispatchEvent({type:a,data:{contactId:o,rigidBodyA:n,rigidBodyB:r,position:pt(c.x,c.y,c.z),normalB:pt(l.x,l.y,l.z)}}),2&s&&n.dispatchEvent({type:a,data:{contactId:o,other:r,position:pt(c.x,c.y,c.z),normalB:pt(-l.x,-l.y,-l.z)}}),4&s&&r.dispatchEvent({type:a,data:{contactId:o,other:n,position:pt(c.x,c.y,c.z),normalB:pt(l.x,l.y,l.z)}})},t=ut.get();t.on("beginContact",e),t.on("updateContact",e),t.on("endContact",e),t.on("ccdContact",e),t.listenToContactCallbacks()}stepSimulation(e,t=3,i=1/60){this._rawDynamicsWorld.stepSimulation(e,t,i)}setGravity(e,t,i){const n=ut.get(),r=new n.btVector3(e,t,i);this._rawDynamicsWorld.setGravity(r),n.destroy(r)}setDebugWireframeCallback(e){const t=ut.get().addFunction(e,"vfffffffff");this._rawDynamicsWorld.setDebugWireframeCallback(t)}setDebugWireframeFeaturesFlag(e){this._rawDynamicsWorld.setDebugWireframeFeaturesFlag(e)}debugDrawWorld(){this._rawDynamicsWorld.debugDrawWorld()}},WasmModuleHolder:ut,convexSweep:bt,rayCast:Tt}),Mt="\n#version 300 es\n\nprecision highp float;\n\nin vec2 a_vertexPosition;\nin vec3 a_plotPosition;\n\nout vec3 v_position;\n\nvoid main(void)\n{\n  gl_Position = vec4(a_vertexPosition, 1.0, 1.0);\n\n  v_position = a_plotPosition;\n}\n".trim(),Ct='\n#version 300 es\n\nprecision highp int;\nprecision highp float;\n\n//\n//\n//\n\n// Indices of refractionFactor\nconst float Air = 1.0;\nconst float Glass = 1.51714;\n\n// Air to glass ratio of the indices of refractionFactor (Eta)\nconst float Eta = Air / Glass;\n\n// see https://en.wikipedia.org/wiki/Refractive_index\n// const float R0 = ((Air - Glass) * (Air - Glass)) / ((Air + Glass) * (Air + Glass));\n\n//\n//\n//\n\nuniform vec3              u_cameraEye;\n\n//\n\nuniform highp sampler2D   u_dataTexture;\n// uniform int               u_sceneTextureSize;\nuniform int               u_lightsTextureSize;\n\n//\n//\n//\n\nin vec3  v_position;\n\nout vec4 o_color;\n\n//\n\nconst float     g_ambientLightIntensity = 0.05;\n\nconst vec3      g_backgroundColor = vec3(0.1);\n\n\n\nconst int       g_maxBvhStack = 16;\nint             g_bvhStack[g_maxBvhStack];\n\nconst int       MATERIALS_ROW_INDEX = 0;\nconst int       SPHERE_SHAPES_ROW_INDEX = 1;\nconst int       BOX_SHAPES_ROW_INDEX = 2;\nconst int       TRIANGLE_SHAPES_ROW_INDEX = 3;\nconst int       LIGHTS_ROW_INDEX = 4;\nconst int       BVH_ROW_INDEX = 5;\n\n//\n//\n//\n//\n//\n\n\nstruct RayValues\n{\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct RayResult\n{\n  bool hasHit;\n  float distance;\n  vec3 position;\n  vec3 normal;\n  float reflectionFactor;\n  float refractionFactor;\n  vec3 txPos;\n  int shapeIndex;\n  int materialIndex;\n};\n\nstruct LightResult {\n  float intensity;\n  vec3 color;\n};\n\n\nstruct StackData\n{\n  bool used;\n  RayValues ray;\n  RayResult result;\n  vec4 color;\n  int reflectionIndex;\n  int refractionIndex;\n};\n\nstruct LightStackData\n{\n  bool used;\n  RayValues ray;\n  RayResult result;\n  LightResult lightResult;\n};\n\n\n//\n//\n//\n//\n//\n\n// ideal scene stack size is >=7 for reflective AND refractive shapes\nconst int       g_maxSceneStackSize = 7;\nStackData       g_sceneStack[g_maxSceneStackSize];\n\n// ideal light stack size is >=5 to handle multiple transparent shapes\nconst int       g_maxLightStackSize = 5;\nLightStackData  g_lightStack[g_maxLightStackSize];\n\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\nvec3 apply_quat_to_vec3(vec3 position, vec4 q)\n{\n  vec3 v = position.xyz;\n  return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nmat3 quat_to_mat3(vec4 q)\n{\n\n  // multiply by sqrt(2) to get rid of all the 2.0 factors in the matrix\n  q *= 1.414214;\n\n  float xx = q.x * q.x;\n  float xy = q.x * q.y;\n  float xz = q.x * q.z;\n  float xw = q.x * q.w;\n\n  float yy = q.y * q.y;\n  float yz = q.y * q.z;\n  float yw = q.y * q.w;\n\n  float zz = q.z * q.z;\n  float zw = q.z * q.w;\n\n  return mat3(\n    1.0 - yy - zz,\n    xy + zw,\n    xz - yw,\n\n    xy - zw,\n    1.0 - xx - zz,\n    yz + xw,\n\n    xz + yw,\n    yz - xw,\n    1.0 - xx - yy\n  );\n}\n\n\n\n//\n//\n//\n//\n//\n\nbool intersectSphere(RayValues ray, float radius, out float outDistance, out vec3 normal)\n{\n  float nearValue = 0.001; // TODO: hardcoded\n  float farValue = 100.0; // TODO: hardcoded\n\n  float b = dot(ray.origin, ray.direction);\n  float c = dot(ray.origin, ray.origin) - radius * radius;\n  float h = b * b - c;\n  if (h < 0.0) {\n    return false;\n  }\n\n  h = sqrt(h);\n\n  float d1 = -b - h;\n  if (d1 >= nearValue && d1 <= farValue)\n  {\n    normal = normalize(ray.origin + ray.direction * d1);\n    outDistance = d1;\n    return true;\n  }\n\n  float d2 = -b + h;\n  if (d2 >= nearValue && d2 <= farValue)\n  {\n    normal = normalize(ray.origin + ray.direction * d2);\n    outDistance = d2;\n    return true;\n  }\n\n  return false;\n}\n\nbool intersectBox(RayValues ray, vec3 boxSize, out float outDistance, out vec3 normal)\n{\n  float nearValue = 0.001; // TODO: hardcoded\n  float farValue = 100.0; // TODO: hardcoded\n\n  //\n  //\n  // sad hack: fix a shadow related bug\n\n  // if (ray.origin.x == 0.0) ray.origin.x = -1e-8;\n  // if (ray.origin.y == 0.0) ray.origin.y = -1e-8;\n  // if (ray.origin.z == 0.0) ray.origin.z = -1e-8;\n\n  if (ray.direction.x == 0.0) ray.direction.x = -1e-8;\n  if (ray.direction.y == 0.0) ray.direction.y = -1e-8;\n  if (ray.direction.z == 0.0) ray.direction.z = -1e-8;\n\n  // sad hack: fix a shadow related bug\n  //\n  //\n\n  vec3 m = sign(ray.direction) / max(abs(ray.direction), 1e-8);\n  vec3 n = m * ray.origin;\n  vec3 k = abs(m) * boxSize;\n\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n\n  float tN = max(max(t1.x, t1.y), t1.z);\n  float tF = min(min(t2.x, t2.y), t2.z);\n\n  if (tN > tF || tF <= 0.0) {\n    return false;\n  }\n\n  if (tN >= nearValue && tN <= farValue)\n  {\n    normal = normalize(-sign(ray.direction) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz));\n    outDistance = tN;\n    return true;\n  }\n\n  if (tF >= nearValue && tF <= farValue)\n  {\n    normal = normalize(-sign(ray.direction) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz));\n    outDistance = tF;\n    return true;\n  }\n\n  return false;\n}\n\nbool intersectTriangle(RayValues ray, vec3 v0, vec3 v1, vec3 v2, out float outDistance, out vec3 normal)\n{\n  float nearValue = 0.001; // TODO: hardcoded\n  float farValue = 100.0; // TODO: hardcoded\n\n  vec3 v1v0 = v1 - v0;\n  vec3 v2v0 = v2 - v0;\n  vec3 rov0 = ray.origin - v0;\n\n  vec3 n = cross(v1v0, v2v0);\n  vec3 q = cross(rov0, ray.direction);\n  float d = 1.0 / dot(ray.direction, n);\n  float u = d * dot(-q, v2v0);\n  float v = d * dot(q, v1v0);\n  float t = d * dot(-n, rov0);\n\n  if (u < 0.0 || v < 0.0 || (u + v) > 1.0 || t < nearValue || t > farValue) {\n    return false;\n  }\n\n  normal = normalize(-n);\n  outDistance = t;\n  return true;\n}\n\n// float intersectPlane(RayValues ray, vec3 normal, float offset)\n// {\n//     return -(dot(ray.origin, normal) + offset) / dot(ray.direction, normal);\n// }\n\n// float intersectPlane2(RayValues ray, vec3 normal, float offset)\n// {\n//     float nearValue = 0.001; // TODO: hardcoded\n//     float farValue = 1000.0; // TODO: hardcoded\n\n//     float a = dot(ray.direction, normal);\n//     float d = -(dot(ray.origin, normal) + offset) / a;\n\n//     if (a > 0.0 || d < nearValue || d > farValue)\n//         return -1.0;\n\n//     return d;\n// }\n\n// float diskIntersect(RayValues ray, vec3 center, vec3 normal, float radius)\n// {\n//     vec3  o = ray.origin - center;\n//     float t = -dot(normal, o) / dot(ray.direction, normal);\n//     vec3  q = o + ray.direction * t;\n//     return (dot(q, q) < radius * radius) ? t : -1.0;\n// }\n\n//\n//\n//\n//\n//\n\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\nvoid _intersectSphereShape(\n  int rawShapeIndex,\n  RayValues ray,\n  inout RayResult outBestResult,\n  bool shadowCastingMode\n) {\n\n  //\n  // Sphere shape\n  //\n\n  // start at index 0\n  int shapeIndex = rawShapeIndex;\n\n  // sphere-shape-texel[0]:R: can cast shadow\n  // sphere-shape-texel[0]:G: material index\n  // sphere-shape-texel[0]:B: center.x\n  // sphere-shape-texel[0]:A: center.y\n  // sphere-shape-texel[1]:R: center.z\n  // sphere-shape-texel[1]:G: quat.x\n  // sphere-shape-texel[1]:B: quat.y\n  // sphere-shape-texel[1]:A: quat.z\n  // sphere-shape-texel[2]:R: quat.w\n  // sphere-shape-texel[2]:G: radius\n  // sphere-shape-texel[2]:B: <unused>\n  // sphere-shape-texel[2]:A: <unused>\n\n  vec4 shTexel0 = texelFetch(u_dataTexture, ivec2(shapeIndex * 3 + 0, SPHERE_SHAPES_ROW_INDEX), 0);\n\n  if (\n    shadowCastingMode == true &&\n    (int(shTexel0.r) == 0) // canCastShadows is false\n  ) {\n    // not casting shadow while in shadow casting mode? -> skip the shape\n    return;\n  }\n\n  vec4 shTexel1 = texelFetch(u_dataTexture, ivec2(shapeIndex * 3 + 1, SPHERE_SHAPES_ROW_INDEX), 0);\n  vec4 shTexel2 = texelFetch(u_dataTexture, ivec2(shapeIndex * 3 + 2, SPHERE_SHAPES_ROW_INDEX), 0);\n\n  vec3 center = vec3(shTexel0.b, shTexel0.a, shTexel1.r);\n  float radius = shTexel2.g;\n\n  vec4 orientation = vec4(\n    shTexel1.g,\n    shTexel1.b,\n    shTexel1.a,\n    shTexel2.r\n  );\n  mat3 normalMatrix = quat_to_mat3(orientation);\n  mat3 inverseNormalMatrix = inverse(normalMatrix);\n\n  // convert ray from world space to sphere space\n  RayValues sphereSpaceRay;\n  sphereSpaceRay.origin = (inverseNormalMatrix * (ray.origin - center));\n  sphereSpaceRay.direction = (inverseNormalMatrix * ray.direction);\n\n  vec3 normal;\n  float currDistance = 0.0;\n\n  if (\n    // false if not hit\n    !intersectSphere(sphereSpaceRay, radius, currDistance, normal) ||\n    // false if hit but not the closest shape\n    (outBestResult.distance > 0.0 && currDistance > outBestResult.distance)\n  ) {\n    return;\n  }\n\n  // convert normal from box space to world space\n  normal = normalMatrix * normal;\n\n  outBestResult.position = ray.origin + currDistance * ray.direction;\n\n  // the multiplication by 0.999 will remove graphic artifact\n  // vec3 txPos = (inverseNormalMatrix * 0.999) * (center - outBestResult.position);\n  vec3 txPos = inverseNormalMatrix * (center - outBestResult.position);\n  outBestResult.txPos = txPos;\n\n  outBestResult.hasHit = true;\n\n  // used here to tell if the intersected shape is any closer than any previous one\n  // -> also used to tell if a shadow ray from a light is "too far" behind the spot light\n  outBestResult.distance = currDistance;\n\n  outBestResult.normal = normal;\n\n  // this is used by the spot lights to handle the transparency/refraction\n\n  // outBestResult.shapeIndex = shapeIndex;\n  outBestResult.shapeIndex = rawShapeIndex;\n\n  // this is used by the spot lights to handle the transparency/refraction\n  outBestResult.materialIndex = int(shTexel0.g);\n}\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\nvoid _intersectBoxShape(\n  int rawShapeIndex,\n  RayValues ray,\n  inout RayResult outBestResult,\n  bool shadowCastingMode\n) {\n\n  //\n  // Box shape\n  //\n\n  // start at index 1000\n  int shapeIndex = rawShapeIndex - 1000;\n\n  // box-shape-texel[0]:R: can cast shadow\n  // box-shape-texel[0]:G: material index\n  // box-shape-texel[0]:B: center.x\n  // box-shape-texel[0]:A: center.y\n  // box-shape-texel[1]:R: center.z\n  // box-shape-texel[1]:G: quat.x\n  // box-shape-texel[1]:B: quat.y\n  // box-shape-texel[1]:A: quat.z\n  // box-shape-texel[2]:R: quat.w\n  // box-shape-texel[2]:G: boxSize.x\n  // box-shape-texel[2]:B: boxSize.y\n  // box-shape-texel[2]:A: boxSize.z\n  vec4 shTexel0 = texelFetch(u_dataTexture, ivec2(shapeIndex * 3 + 0, BOX_SHAPES_ROW_INDEX), 0);\n\n  if (\n    shadowCastingMode == true &&\n    (int(shTexel0.r) == 0) // canCastShadows is false\n  ) {\n    // not casting shadow while in shadow casting mode? -> skip the shape\n    return;\n  }\n\n  vec4 shTexel1 = texelFetch(u_dataTexture, ivec2(shapeIndex * 3 + 1, BOX_SHAPES_ROW_INDEX), 0);\n  vec4 shTexel2 = texelFetch(u_dataTexture, ivec2(shapeIndex * 3 + 2, BOX_SHAPES_ROW_INDEX), 0);\n\n\n  vec3 center = vec3(shTexel0.b, shTexel0.a, shTexel1.r);\n  vec3 boxSize = shTexel2.gba;\n\n  vec4 orientation = vec4(\n    shTexel1.g,\n    shTexel1.b,\n    shTexel1.a,\n    shTexel2.r\n  );\n  mat3 normalMatrix = quat_to_mat3(orientation);\n  mat3 inverseNormalMatrix = inverse(normalMatrix);\n\n  // convert ray from world space to box space\n  RayValues boxSpaceRay;\n  boxSpaceRay.origin = (inverseNormalMatrix * (ray.origin - center));\n  boxSpaceRay.direction = (inverseNormalMatrix * ray.direction);\n\n  vec3 normal;\n  float currDistance = 0.0;\n\n  if (\n    // false if not hit\n    !intersectBox(boxSpaceRay, boxSize, currDistance, normal) ||\n    // false if hit but not the closest shape\n    (outBestResult.distance > 0.0 && currDistance > outBestResult.distance)\n  ) {\n    return;\n  }\n\n  // convert normal from box space to world space\n  normal = normalMatrix * normal;\n\n  outBestResult.position = ray.origin + currDistance * ray.direction;\n\n  // the multiplication by 0.999 will remove unwanted graphic artifact\n  vec3 txPos = (inverseNormalMatrix * 0.999) * (center - outBestResult.position);\n  outBestResult.txPos = txPos;\n\n  outBestResult.hasHit = true;\n\n  // used here to tell if the intersected shape is any closer than any previous one\n  // -> also used to tell if a shadow ray from a light is "too far" behind the spot light\n  outBestResult.distance = currDistance;\n\n  outBestResult.normal = normal;\n\n  // this is used by the spot lights to handle the transparency/refraction\n\n  // outBestResult.shapeIndex = shapeIndex;\n  outBestResult.shapeIndex = rawShapeIndex;\n\n  // this is used by the spot lights to handle the transparency/refraction\n  outBestResult.materialIndex = int(shTexel0.g);\n}\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\nvoid _intersectTriangleShape(\n  int rawShapeIndex,\n  RayValues ray,\n  inout RayResult outBestResult,\n  bool shadowCastingMode\n) {\n  //\n  // Triangle shape\n  //\n\n  // start at index 2000\n  int shapeIndex = rawShapeIndex - 2000;\n\n  // triangle-shape-texel[0]:R: can cast shadow\n  // triangle-shape-texel[0]:G: material index\n  // triangle-shape-texel[0]:B: triangle0.x\n  // triangle-shape-texel[0]:A: triangle0.y\n  // triangle-shape-texel[1]:R: triangle0.z\n  // triangle-shape-texel[1]:G: triangle1.x\n  // triangle-shape-texel[1]:B: triangle1.y\n  // triangle-shape-texel[1]:A: triangle1.z\n  // triangle-shape-texel[2]:R: triangle2.x\n  // triangle-shape-texel[2]:G: triangle2.y\n  // triangle-shape-texel[2]:B: triangle2.z\n  // triangle-shape-texel[2]:A: <unused>\n  vec4 shTexel0 = texelFetch(u_dataTexture, ivec2(shapeIndex * 3 + 0, TRIANGLE_SHAPES_ROW_INDEX), 0);\n\n  if (\n    shadowCastingMode == true &&\n    (int(shTexel0.r) == 0) // canCastShadows is false\n  ) {\n    // not casting shadow while in shadow casting mode? -> skip the shape\n    return;\n  }\n\n  vec4 shTexel1 = texelFetch(u_dataTexture, ivec2(shapeIndex * 3 + 1, TRIANGLE_SHAPES_ROW_INDEX), 0);\n  vec4 shTexel2 = texelFetch(u_dataTexture, ivec2(shapeIndex * 3 + 2, TRIANGLE_SHAPES_ROW_INDEX), 0);\n\n  vec3 v0 = vec3(shTexel0.b, shTexel0.a, shTexel1.r);\n  vec3 v1 = shTexel1.gba;\n  vec3 v2 = shTexel2.rgb;\n\n  vec3 normal;\n  float currDistance = 0.0;\n\n  if (\n    // false if not hit\n    !intersectTriangle(ray, v0, v1, v2, currDistance, normal) ||\n    // false if hit but not the closest shape\n    (outBestResult.distance > 0.0 && currDistance > outBestResult.distance)\n  ) {\n    return;\n  }\n\n  outBestResult.position = ray.origin + currDistance * ray.direction;\n\n  // outBestResult.txPos = vec3(0.0); // TODO?\n\n  outBestResult.hasHit = true;\n\n  // used here to tell if the intersected shape is any closer than any previous one\n  // -> also used to tell if a shadow ray from a light is "too far" behind the spot light\n  outBestResult.distance = currDistance;\n\n  outBestResult.normal = normal;\n\n  // this is used by the spot lights to handle the transparency/refraction\n\n  // outBestResult.shapeIndex = shapeIndex;\n  outBestResult.shapeIndex = rawShapeIndex;\n\n  // this is used by the spot lights to handle the transparency/refraction\n  outBestResult.materialIndex = int(shTexel0.g);\n}\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\nvoid intersectSceneOneShape(\n  int rawShapeIndex,\n  RayValues ray,\n  inout RayResult outBestResult,\n  bool shadowCastingMode\n) {\n\n  if (rawShapeIndex < 1000)\n  {\n    _intersectSphereShape(\n      rawShapeIndex,\n      ray,\n      outBestResult,\n      shadowCastingMode\n    );\n  }\n  else if (rawShapeIndex < 2000)\n  {\n    _intersectBoxShape(\n      rawShapeIndex,\n      ray,\n      outBestResult,\n      shadowCastingMode\n    );\n  }\n  else if (rawShapeIndex < 3000)\n  {\n    _intersectTriangleShape(\n      rawShapeIndex,\n      ray,\n      outBestResult,\n      shadowCastingMode\n    );\n  }\n  else {\n    return;\n  }\n}\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\nbool rayIntersectBvhAABB(RayValues ray, vec3 bvhMin, vec3 bvhMax)\n{\n  vec3 valA = (bvhMin - ray.origin) / ray.direction;\n  vec3 valB = (bvhMax - ray.origin) / ray.direction;\n  vec3 minVal = min(valA, valB);\n  vec3 maxVal = max(valA, valB);\n\n  float max_minVal = max(minVal.x, max(minVal.y, minVal.z));\n  float min_maxVal = min(maxVal.x, min(maxVal.y, maxVal.z));\n\n  return max_minVal < min_maxVal;\n}\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\n//\n//\n//\n//\n//\n\nbool intersectScene(\n  RayValues ray,\n  out RayResult outBestResult,\n  bool shadowCastingMode,\n  int toIgnoreShapeIndex\n) {\n\n  // use BVH optimization -> traverse the nodes and their associated AABB\n  // -> this should reduce the total number intersections executed\n\n  g_bvhStack[0] = 0; // start with the root BVH node index\n  int bvhStackTopIndex = 0;\n\n  while (bvhStackTopIndex >= 0)\n  {\n\n    // pop bvh stack\n    int nodeIndex = g_bvhStack[bvhStackTopIndex];\n    bvhStackTopIndex -= 1;\n\n    // BVH-node-texel[0]:R: min.x\n    // BVH-node-texel[0]:G: min.y\n    // BVH-node-texel[0]:B: min.z\n    // BVH-node-texel[0]:A: max.x\n    // BVH-node-texel[1]:R: max.y\n    // BVH-node-texel[1]:G: max.z\n    // BVH-node-texel[1]:B: left bvh node index\n    // BVH-node-texel[1]:A: right bvh node index\n    // BVH-node-texel[2]:R: left leaf shape index\n    // BVH-node-texel[2]:G: right leaf shape index\n    // BVH-node-texel[2]:B: <unused>\n    // BVH-node-texel[2]:A: <unused>\n\n    vec4 rootNodeTexel0 = texelFetch(u_dataTexture, ivec2(nodeIndex * 3 + 0, BVH_ROW_INDEX), 0);\n    vec4 rootNodeTexel1 = texelFetch(u_dataTexture, ivec2(nodeIndex * 3 + 1, BVH_ROW_INDEX), 0);\n\n    vec3 aabbMin = rootNodeTexel0.rgb;\n    vec3 aabbMax = vec3(rootNodeTexel0.a, rootNodeTexel1.r, rootNodeTexel1.g);\n\n    if (!rayIntersectBvhAABB(ray, aabbMin, aabbMax)) {\n      continue;\n    }\n\n    //\n\n    int leftNodeIndex = int(rootNodeTexel1.b);\n    if (leftNodeIndex >= 0 && bvhStackTopIndex + 1 < g_maxBvhStack) {\n      // push left bvh node index on to the stack\n      bvhStackTopIndex += 1;\n      g_bvhStack[bvhStackTopIndex] = leftNodeIndex;\n    }\n\n    int rightNodeIndex = int(rootNodeTexel1.a);\n    if (rightNodeIndex >= 0 && bvhStackTopIndex + 1 < g_maxBvhStack) {\n      // push right bvh node index on to the stack\n      bvhStackTopIndex += 1;\n      g_bvhStack[bvhStackTopIndex] = rightNodeIndex;\n    }\n\n    //\n\n    vec4 rootNodeTexel2 = texelFetch(u_dataTexture, ivec2(nodeIndex * 3 + 2, BVH_ROW_INDEX), 0);\n\n    int leftLeafShapeIndex = int(rootNodeTexel2.r);\n    if (\n      // has shape\n      leftLeafShapeIndex >= 0 &&\n      leftLeafShapeIndex != toIgnoreShapeIndex\n    ) {\n      intersectSceneOneShape(leftLeafShapeIndex, ray, outBestResult, shadowCastingMode);\n    }\n\n    int rightLeafShapeIndex = int(rootNodeTexel2.g);\n    if (\n      // has shape\n      rightLeafShapeIndex >= 0 &&\n      rightLeafShapeIndex != toIgnoreShapeIndex\n    ) {\n      intersectSceneOneShape(rightLeafShapeIndex, ray, outBestResult, shadowCastingMode);\n    }\n\n    //\n\n  }\n\n  return outBestResult.hasHit;\n}\n\n\n\n\n\n\n\nvoid lightAt(\n  vec3 impactPosition,\n  vec3 impactNormal,\n  vec3 viewer,\n  out LightResult lightResult\n) {\n\n  lightResult.intensity = g_ambientLightIntensity;\n  lightResult.color = vec3(1.0);\n\n  //\n  // handle spot lights\n  //\n\n  vec3 lightDir = vec3(1.0);\n  float currLightIntensity = 1.0;\n  vec3 currLightColor = vec3(1.0);\n\n  for (int lightIndex = 0; lightIndex < u_lightsTextureSize; lightIndex += 2)\n  {\n\n    // spot-light-texel[0]:R: spot light position.x\n    // spot-light-texel[0]:G: spot light position.y\n    // spot-light-texel[0]:B: spot light position.z\n    // spot-light-texel[0]:A: spot light radius\n    // spot-light-texel[1]:R: spot light intensity\n    // spot-light-texel[1]:G: <unused>\n    // spot-light-texel[1]:B: <unused>\n    // spot-light-texel[1]:A: <unused>\n\n    vec4 lightTexel0 = texelFetch(u_dataTexture, ivec2(lightIndex + 0, LIGHTS_ROW_INDEX), 0);\n    vec3 lightPos = lightTexel0.rgb;\n    float lightRadius = lightTexel0.a;\n\n    vec3 lightToImpactVec3 = lightPos - impactPosition;\n\n    // is it out of the spot light effect radius?\n    float lightToImpactDistance = length(lightToImpactVec3);\n    if (lightToImpactDistance > lightRadius)\n    {\n      // out of range, do not apply this light\n      continue;\n    }\n\n    // normalize lightDir\n    lightDir = lightToImpactVec3 / lightToImpactDistance;\n\n    vec4 lightTexel1 = texelFetch(u_dataTexture, ivec2(lightIndex + 1, LIGHTS_ROW_INDEX), 0);\n    float localIntensity = lightTexel1.r;\n\n    currLightIntensity = localIntensity * (1.0 - lightToImpactDistance / lightRadius);\n\n    // initialize stack\n    for (int ii = 0; ii < g_maxLightStackSize; ++ii)\n    {\n      g_lightStack[ii].used = false;\n      g_lightStack[ii].ray.direction = lightDir;\n      g_lightStack[ii].result.reflectionFactor = 1.0;\n      g_lightStack[ii].result.refractionFactor = 1.0;\n      g_lightStack[ii].result.materialIndex = -1;\n      g_lightStack[ii].lightResult.intensity = 1.0;\n      g_lightStack[ii].lightResult.color = vec3(1.0);\n    }\n\n    // initialize first stack element\n    g_lightStack[0].used = true;\n    g_lightStack[0].ray.origin = impactPosition;\n\n    // this variable allow us the skip the collision with the previously hit shape\n    // -> this will avoid a "double hit" of the same shape while we loop\n    int previousShapeIndex = -1;\n\n    // start with assumption the light is not blocked\n    bool lightIsBlocked = false;\n\n    int lightStackWriteIndex = 0;\n\n    //\n    // Accumulating this shape\'s light stack\n    //\n\n    int lightStackReadIndex = 0;\n    for (; lightStackReadIndex < g_maxLightStackSize; ++lightStackReadIndex)\n    {\n      // intersect object\n      // if reflection/refraction push to stack\n      // repeat\n\n      if (!g_lightStack[lightStackReadIndex].used)\n      {\n        // nothing to process anymore\n        break;\n      }\n\n      const bool shadowCastingMode = true;\n\n      bool hasHit = intersectScene(\n        g_lightStack[lightStackReadIndex].ray,\n        g_lightStack[lightStackReadIndex].result,\n        shadowCastingMode,\n        previousShapeIndex\n      );\n\n      if (\n        // if we got no collision -> light not blocked -> continue\n        hasHit == false ||\n        // if we\'re here: we got a collision\n        // -> now we must check if the impact is "behind" the light\n        // ---\x3e basically, was the impact "too far" in the direction of the light?\n        // -----\x3e if no -> light not blocked -> continue\n        g_lightStack[lightStackReadIndex].result.distance > distance(g_lightStack[lightStackReadIndex].ray.origin, lightPos)\n      ) {\n        // ignore the light\n        lightIsBlocked = false;\n        break;\n      }\n\n      // if we\'re here, the "shadow ray" has hit a shape, and normally this spot light should be skipped\n      // -> but we actually need to check for any refractive/transparent material associated to the shape hit\n\n      // save it now, in case we must loop again\n      previousShapeIndex = g_lightStack[lightStackReadIndex].result.shapeIndex;\n\n      // now we\'re going to need the shape\'s material\n      int materialIndex = g_lightStack[lightStackReadIndex].result.materialIndex;\n\n      // material-texel[0]:R: material type (0=basic or 1=chessboard)\n      // material-texel[0]:G: can cast shadows (0 or 1)\n      // material-texel[0]:B: ??? (per material type)\n      // material-texel[0]:A: ??? (per material type)\n      // material-texel[1]:R: ??? (per material type)\n      // material-texel[1]:G: ??? (per material type)\n      // material-texel[1]:B: ??? (per material type)\n      // material-texel[1]:A: ??? (per material type)\n      vec4 matTexel0 = texelFetch(u_dataTexture, ivec2(materialIndex * 2 + 0, MATERIALS_ROW_INDEX), 0);\n      vec4 matTexel1 = texelFetch(u_dataTexture, ivec2(materialIndex * 2 + 1, MATERIALS_ROW_INDEX), 0);\n\n      int materialType = int(matTexel0.r);\n\n      // chessboard alternative material\n      if (materialType == 1)\n      {\n        // as a chessboard material\n\n        // chessboard-material-texel[0]:R: material type (0=basic or 1=chessboard)\n        // chessboard-material-texel[0]:G: can cast shadows (0 or 1)\n        // chessboard-material-texel[0]:B: sub material index A\n        // chessboard-material-texel[0]:A: sub material index B\n        // chessboard-material-texel[1]:R: chessboard-fraction.x\n        // chessboard-material-texel[1]:G: chessboard-fraction.y\n        // chessboard-material-texel[1]:B: chessboard-fraction.z\n        // chessboard-material-texel[1]:A: <unused>\n\n        int subMaterialIndex = 0;\n\n        vec3 txPos = g_lightStack[lightStackReadIndex].result.txPos;\n        if (\n          (fract(txPos.x * matTexel1.r) > 0.5)\n          != (fract(txPos.y * matTexel1.g) > 0.5)\n          != (fract(txPos.z * matTexel1.b) > 0.5)\n        ) {\n          subMaterialIndex = int(matTexel0.a);\n        } else {\n          subMaterialIndex = int(matTexel0.b);\n        }\n\n        // as a basic material\n\n        // basic-material-texel[0]:R: material type (0=basic or 1=chessboard)\n        // basic-material-texel[0]:G: can cast shadows (0 or 1)\n        // basic-material-texel[0]:B: reflection index [0..1]\n        // basic-material-texel[0]:A: refraction index [0..1]\n        // basic-material-texel[1]:R: can receive light\n        // basic-material-texel[1]:G: color.r\n        // basic-material-texel[1]:B: color.g\n        // basic-material-texel[1]:A: color.b\n        matTexel0 = texelFetch(u_dataTexture, ivec2(subMaterialIndex * 2 + 0, MATERIALS_ROW_INDEX), 0);\n        matTexel1 = texelFetch(u_dataTexture, ivec2(subMaterialIndex * 2 + 1, MATERIALS_ROW_INDEX), 0);\n      }\n\n      float refractionFactor = matTexel0.a;\n\n      // is the shape "solid enough"?\n      if (refractionFactor <= 0.01)\n      {\n        // no refraction/transparency -> light ray is blocked -> ignore the light\n        lightIsBlocked = true;\n        break;\n      }\n\n      vec3 shapeColor = matTexel1.gba;\n\n      g_lightStack[lightStackReadIndex].lightResult.intensity = refractionFactor;\n      g_lightStack[lightStackReadIndex].lightResult.color = shapeColor.xyz;\n\n      //\n      // handle refraction/transparency\n      //\n\n      if (lightStackWriteIndex + 1 >= g_maxLightStackSize)\n      {\n        // no more stack writing space left -> stop now\n        break;\n      }\n\n      lightStackWriteIndex += 1;\n\n      g_lightStack[lightStackWriteIndex].used = true;\n      g_lightStack[lightStackWriteIndex].ray.origin = g_lightStack[lightStackReadIndex].result.position;\n\n    } // for (int ii = 0; ii < g_maxLightStackSize; ++ii)\n\n    if (lightIsBlocked)\n    {\n      // light ray is blocked by a (solid enough) shape -> ignore the light\n      continue;\n    }\n\n    //\n    // Unrolling this shape\'s accumulated light stack\n    //\n\n    // combine all light(s) color\n    // -> from last element to first element\n    // -> here we start from where we stopped during the accumulation phase\n    for (lightStackReadIndex = lightStackWriteIndex; lightStackReadIndex >= 0; --lightStackReadIndex)\n    // for (lightStackReadIndex = g_maxLightStackSize - 1; lightStackReadIndex >= 0; --lightStackReadIndex)\n    {\n      // if (g_lightStack[lightStackReadIndex].used == false)\n      // {\n      //   continue;\n      // }\n\n      // used stack element\n      currLightColor *= g_lightStack[lightStackReadIndex].lightResult.color.xyz;\n      currLightIntensity *= g_lightStack[lightStackReadIndex].lightResult.intensity;\n    }\n\n    //\n    //\n    //\n\n    //\n    // the light logic\n    // -> TODO: find the name of this (custom?) method...\n    // ---\x3e Blinn?\n    // ---\x3e Phong?\n    // ---\x3e Blinn-Phong?\n    //\n\n    float finalIntensity = 0.0;\n\n    // diffuse light\n    finalIntensity += dot(lightDir, impactNormal);\n\n    // specular light\n    vec3 reflectionFactor = reflect(-lightDir, impactNormal);\n    finalIntensity += pow(max(dot(reflectionFactor, viewer), 0.0), 20.0);\n\n    finalIntensity *= currLightIntensity;\n\n    //\n    // blend with the current result\n    //\n\n    float maxIntensity = max(lightResult.intensity, finalIntensity);\n    float normalizedRatio = 1.0 / maxIntensity;\n\n    float oldBlendRatio = normalizedRatio * max(lightResult.intensity, g_ambientLightIntensity);\n    float newBlendRatio = normalizedRatio * max(finalIntensity, g_ambientLightIntensity);\n\n    lightResult.color = lightResult.color * oldBlendRatio + currLightColor * newBlendRatio;\n    lightResult.intensity = maxIntensity;\n\n  } // for (int index = 0; index < u_lightsTextureSize; index += 2)\n}\n\n\n\n\n\nvec3 castInitialRay(in vec3 rayDir)\n{\n\n  // initialize stack\n  for (int ii = 0; ii < g_maxSceneStackSize; ++ii)\n  {\n    g_sceneStack[ii].used = false;\n    g_sceneStack[ii].result.reflectionFactor = 0.0;\n    g_sceneStack[ii].result.refractionFactor = 0.0;\n    g_sceneStack[ii].result.materialIndex = -1;\n    g_sceneStack[ii].result.distance = -1.0;\n    g_sceneStack[ii].reflectionIndex = -1;\n    g_sceneStack[ii].refractionIndex = -1;\n  }\n\n  // initialize first stack element\n  g_sceneStack[0].used = true;\n  g_sceneStack[0].ray = RayValues(u_cameraEye, rayDir);\n  g_sceneStack[0].result.position = u_cameraEye;\n  g_sceneStack[0].reflectionIndex = -1;\n  g_sceneStack[0].refractionIndex = -1;\n\n  int sceneStackWriteIndex = 0;\n\n  //\n  // Accumulating this fragment\'s scene stack\n  //\n\n  int sceneStackReadIndex = 0;\n  for (; sceneStackReadIndex < g_maxSceneStackSize; ++sceneStackReadIndex)\n  {\n    // intersect object\n    // if reflection/refraction push to stack & set index\n    // repeat\n\n    if (!g_sceneStack[sceneStackReadIndex].used)\n    {\n      // nothing to process anymore\n      break;\n    }\n\n    const bool shadowCastingMode = false;\n\n    bool hasHit = intersectScene(\n      g_sceneStack[sceneStackReadIndex].ray,\n      g_sceneStack[sceneStackReadIndex].result,\n      shadowCastingMode,\n      -1\n    );\n\n    g_sceneStack[sceneStackReadIndex].result.hasHit = hasHit;\n\n    if (!hasHit)\n    {\n      continue;\n    }\n\n    //\n    // material handling\n    //\n\n    int materialIndex = g_sceneStack[sceneStackReadIndex].result.materialIndex;\n\n    // material-texel[0]:R: material type (0=basic or 1=chessboard)\n    // material-texel[0]:G: can cast shadows (0 or 1)\n    // material-texel[0]:B: ??? (per material type)\n    // material-texel[0]:A: ??? (per material type)\n    // material-texel[1]:R: ??? (per material type)\n    // material-texel[1]:G: ??? (per material type)\n    // material-texel[1]:B: ??? (per material type)\n    // material-texel[1]:A: ??? (per material type)\n    vec4 matTexel0 = texelFetch(u_dataTexture, ivec2(materialIndex * 2 + 0, MATERIALS_ROW_INDEX), 0);\n    vec4 matTexel1 = texelFetch(u_dataTexture, ivec2(materialIndex * 2 + 1, MATERIALS_ROW_INDEX), 0);\n\n    int materialType = int(matTexel0.r);\n\n    if (materialType == 1)\n    {\n      // as a chessboard material\n\n      // chessboard-material-texel[0]:R: material type (0=basic or 1=chessboard)\n      // chessboard-material-texel[0]:G: can cast shadows (0 or 1)\n      // chessboard-material-texel[0]:B: sub material index A\n      // chessboard-material-texel[0]:A: sub material index B\n      // chessboard-material-texel[1]:R: chessboard-fraction.x\n      // chessboard-material-texel[1]:G: chessboard-fraction.y\n      // chessboard-material-texel[1]:B: chessboard-fraction.z\n      // chessboard-material-texel[1]:A: <unused>\n\n      int subMaterialIndex = 0;\n\n      vec3 txPos = g_sceneStack[sceneStackReadIndex].result.txPos;\n      if (\n        (fract(txPos.x * matTexel1.r) > 0.5)\n        == (fract(txPos.y * matTexel1.g) > 0.5)\n        == (fract(txPos.z * matTexel1.b) > 0.5)\n      ) {\n        subMaterialIndex = int(matTexel0.a);\n      } else {\n        subMaterialIndex = int(matTexel0.b);\n      }\n\n      // as a basic material\n\n      // basic-material-texel[0]:R: material type (0=basic or 1=chessboard)\n      // basic-material-texel[0]:G: can cast shadows (0 or 1)\n      // basic-material-texel[0]:B: reflection index [0..1]\n      // basic-material-texel[0]:A: refraction index [0..1]\n      // basic-material-texel[1]:R: can receive light\n      // basic-material-texel[1]:G: color.r\n      // basic-material-texel[1]:B: color.g\n      // basic-material-texel[1]:A: color.b\n      matTexel0 = texelFetch(u_dataTexture, ivec2(subMaterialIndex * 2 + 0, MATERIALS_ROW_INDEX), 0);\n      matTexel1 = texelFetch(u_dataTexture, ivec2(subMaterialIndex * 2 + 1, MATERIALS_ROW_INDEX), 0);\n    }\n\n    vec3 materialColor = matTexel1.gba;\n    float reflectionFactor = matTexel0.b;\n    float refractionFactor = matTexel0.a;\n\n    g_sceneStack[sceneStackReadIndex].color = vec4(materialColor, 0.5);\n    g_sceneStack[sceneStackReadIndex].result.reflectionFactor = reflectionFactor;\n    g_sceneStack[sceneStackReadIndex].result.refractionFactor = refractionFactor;\n\n    bool canReceiveLight = (matTexel1.r != 0.0);\n\n    //\n    // Light handling\n    //\n\n    LightResult lightResult;\n    lightResult.intensity = 1.0;\n    lightResult.color = vec3(1.0);\n\n    if (canReceiveLight)\n    {\n      lightAt(\n        g_sceneStack[sceneStackReadIndex].result.position,\n        g_sceneStack[sceneStackReadIndex].result.normal,\n        -g_sceneStack[sceneStackReadIndex].ray.direction,\n        lightResult\n      );\n    }\n\n    // update the result color\n    // -> this is to handle the refracted/transparent shape\'s shadows\n    // -> this will iterate over multiple potential refracted/transparent shapes\n    // ---\x3e ex1: a yellow then red refracted/transparent shape -> red shadow\n    g_sceneStack[sceneStackReadIndex].color.xyz *= lightResult.color * lightResult.intensity;\n\n    if (canReceiveLight && lightResult.intensity <= 0.0)\n    {\n      // not lit -> skip refraction/reflection\n      continue;\n    }\n\n    //\n    // reflection/refraction here\n    //\n\n    //\n    // refraction here\n    //\n\n    if (\n      // first check if more stack space is left\n      sceneStackWriteIndex + 1 < g_maxSceneStackSize &&\n      // then we check if the refraction factor is positive\n      g_sceneStack[sceneStackReadIndex].result.refractionFactor > 0.0\n    ) {\n      // push new refraction iteration to the stack\n      sceneStackWriteIndex += 1;\n\n      g_sceneStack[sceneStackWriteIndex].used = true;\n      g_sceneStack[sceneStackWriteIndex].ray.origin = g_sceneStack[sceneStackReadIndex].result.position;\n      g_sceneStack[sceneStackWriteIndex].ray.direction = refract(g_sceneStack[sceneStackReadIndex].ray.direction, g_sceneStack[sceneStackReadIndex].result.normal, Eta);\n\n      // here add 0.01 of the normal to the new origin\n      // -> this get properly "inside" the intersected shape\n      // ---\x3e this is to avoid intersecting twice the "same shape" at the "same spot"\n      g_sceneStack[sceneStackWriteIndex].ray.origin += g_sceneStack[sceneStackReadIndex].ray.direction * 0.01;\n\n      // set the new "child stack element" to its "parent stack element"\n      g_sceneStack[sceneStackReadIndex].refractionIndex = sceneStackWriteIndex;\n    }\n\n    //\n    // reflection here\n    //\n\n    if (\n      // first we check if more stack space is left\n      sceneStackWriteIndex + 1 < g_maxSceneStackSize &&\n      // then we check if the reflection factor is positive\n      g_sceneStack[sceneStackReadIndex].result.reflectionFactor > 0.0\n    ) {\n      // push new reflection iteration to the stack\n      sceneStackWriteIndex += 1;\n\n      g_sceneStack[sceneStackWriteIndex].used = true;\n      g_sceneStack[sceneStackWriteIndex].ray.origin = g_sceneStack[sceneStackReadIndex].result.position;\n      g_sceneStack[sceneStackWriteIndex].ray.direction = reflect(g_sceneStack[sceneStackReadIndex].ray.direction, g_sceneStack[sceneStackReadIndex].result.normal);\n\n      // set the new "child stack element" to its "parent stack element"\n      g_sceneStack[sceneStackReadIndex].reflectionIndex = sceneStackWriteIndex;\n    }\n\n  }\n\n  //\n  // Unrolling this fragment\'s accumulated scene stack\n  //\n\n  // combine all colors\n  // -> from last element to first element\n  // -> here we start from where we stopped during the accumulation phase\n  for (sceneStackReadIndex = sceneStackWriteIndex; sceneStackReadIndex >= 0; --sceneStackReadIndex)\n  // for (sceneStackReadIndex = g_maxSceneStackSize - 1; sceneStackReadIndex >= 0; --sceneStackReadIndex)\n  {\n    // if (!g_sceneStack[sceneStackReadIndex].used) {\n    //   continue;\n    // }\n\n    // handle any connected reflection\n    int reflectionIndex = g_sceneStack[sceneStackReadIndex].reflectionIndex;\n    if (reflectionIndex != -1)\n    {\n      float reflectionFactor = g_sceneStack[sceneStackReadIndex].result.reflectionFactor;\n      g_sceneStack[sceneStackReadIndex].color.xyz =\n        g_sceneStack[sceneStackReadIndex].color.xyz * (1.0 - reflectionFactor) +\n        g_sceneStack[reflectionIndex].color.xyz * reflectionFactor;\n    }\n\n    // handle any connected refraction\n    int refractionIndex = g_sceneStack[sceneStackReadIndex].refractionIndex;\n    if (refractionIndex != -1)\n    {\n      float refractionFactor = g_sceneStack[sceneStackReadIndex].result.refractionFactor;\n      g_sceneStack[sceneStackReadIndex].color.xyz =\n        g_sceneStack[sceneStackReadIndex].color.xyz * (1.0 - refractionFactor) +\n        g_sceneStack[refractionIndex].color.xyz * refractionFactor;\n    }\n  }\n\n  return g_sceneStack[0].result.hasHit\n    ? g_sceneStack[0].color.xyz\n    : g_backgroundColor;\n}\n\n\n//\n//\n//\n//\n//\n\nvoid main()\n{\n  //\n  //\n  // initial ray\n\n  vec3 rayDir = normalize(v_position - u_cameraEye); // camera direction\n\n  vec3 finalPixelColor = castInitialRay(rayDir);\n\n  //\n  // Final Output\n  //\n\n  o_color = vec4(finalPixelColor, 1.0);\n\n  // gl_FragDepth = 0.1;\n\n}\n'.trim();class Dt{static buildBvhGraph(e,t){this.s_index=0;const i=I(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),n=I(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);for(const e of t)i[0]=Math.min(i[0],e.min[0]),i[1]=Math.min(i[1],e.min[1]),i[2]=Math.min(i[2],e.min[2]),n[0]=Math.max(n[0],e.max[0]),n[1]=Math.max(n[1],e.max[1]),n[2]=Math.max(n[2],e.max[2]);const r=e.acquire(i,n);return r._subDivide(e,t),r}constructor(e,t){this._index=-1,this.min=D(),this.max=D(),this.init(e,t)}init(e,t){this._index=Dt.s_index,Dt.s_index+=1,B(this.min,e),B(this.max,t),this._leftNode=void 0,this._rightNode=void 0,this._leftLeaf=void 0,this._rightLeaf=void 0}_subDivide(e,t){if(t.length<=2)return this._leftLeaf=t[0],void(this._rightLeaf=t[1]);const i=Math.abs(this.max[0]-this.min[0]),n=Math.abs(this.max[1]-this.min[1]),r=Math.abs(this.max[2]-this.min[2]),a=Math.max(i,n,r);a===i?this._splitAcross(e,0,t):a===n?this._splitAcross(e,1,t):this._splitAcross(e,2,t)}_splitAcross(e,t,i){const n=i.slice().sort(((e,i)=>(e.min[t]+e.max[t])/2-(i.min[t]+i.max[t])/2)),r=Math.floor(n.length/2),a=n.slice(0,r),s=n.slice(r);a.length>0&&(k(Dt.s_min,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),k(Dt.s_max,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER),a.forEach((e=>{Dt.s_min[0]=Math.min(Dt.s_min[0],e.min[0]),Dt.s_min[1]=Math.min(Dt.s_min[1],e.min[1]),Dt.s_min[2]=Math.min(Dt.s_min[2],e.min[2]),Dt.s_max[0]=Math.max(Dt.s_max[0],e.max[0]),Dt.s_max[1]=Math.max(Dt.s_max[1],e.max[1]),Dt.s_max[2]=Math.max(Dt.s_max[2],e.max[2])})),this._leftNode=e.acquire(Dt.s_min,Dt.s_max)),s.length>0&&(k(Dt.s_min,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),k(Dt.s_max,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER),s.forEach((e=>{Dt.s_min[0]=Math.min(Dt.s_min[0],e.min[0]),Dt.s_min[1]=Math.min(Dt.s_min[1],e.min[1]),Dt.s_min[2]=Math.min(Dt.s_min[2],e.min[2]),Dt.s_max[0]=Math.max(Dt.s_max[0],e.max[0]),Dt.s_max[1]=Math.max(Dt.s_max[1],e.max[1]),Dt.s_max[2]=Math.max(Dt.s_max[2],e.max[2])})),this._rightNode=e.acquire(Dt.s_min,Dt.s_max)),this._leftNode&&this._leftNode._subDivide(e,a),this._rightNode&&this._rightNode._subDivide(e,s)}}Dt.s_index=0,Dt.s_min=D(),Dt.s_max=D();class Pt{constructor(e,t){this._poolFree=[],this._poolUsed=[],this._onCreateCallback=e,this._onInitCallback=t}acquire(...e){if(this._poolFree.length>0){const t=this._poolFree.pop();return this._onInitCallback(t,...e),t}const t=this._onCreateCallback(...e);return this._poolUsed.push(t),t}releaseAll(){for(const e of this._poolUsed)this._poolFree.push(e);this._poolUsed.length=0}}class It{constructor(){this._objectPool=new Pt(((e,t)=>new Dt(e,t)),((e,t,i)=>(e.init(t,i),e)))}reset(){this._objectPool.releaseAll(),this._rootNode=void 0}synchronize(e){this.reset(),this._rootNode=Dt.buildBvhGraph(this._objectPool,e)}getRootNode(){return this._rootNode}}const Bt=.01;class kt{constructor(){this._bvhTree=new It,this._boxMat4_a=S(),this._boxMat4_b=S(),this._boxPos=D(),this._boxCorners=[D(),D(),D(),D(),D(),D(),D(),D()]}reset(){this._bvhTree.reset()}synchronize(e,t,i){this.reset();const n=[];let r=0;for(const t of e){const e=I(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),i=I(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);e[0]=Math.min(e[0],t.position[0]-t.radius),e[1]=Math.min(e[1],t.position[1]-t.radius),e[2]=Math.min(e[2],t.position[2]-t.radius),i[0]=Math.max(i[0],t.position[0]+t.radius),i[1]=Math.max(i[1],t.position[1]+t.radius),i[2]=Math.max(i[2],t.position[2]+t.radius),i[0]-e[0]<Bt&&(i[0]+=Bt),i[1]-e[1]<Bt&&(i[1]+=Bt),i[2]-e[2]<Bt&&(i[2]+=Bt),n.push({shapeIndex:r++,type:"sphere",shape:t,min:e,max:i})}r=1e3;for(const e of t){E(this._boxMat4_a),A(this._boxMat4_a,this._boxMat4_a,e.position),C(this._boxMat4_b,e.orientation),R(this._boxMat4_a,this._boxMat4_a,this._boxMat4_b);const t=I(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),i=I(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);[k(this._boxCorners[0],-e.boxSize[0],-e.boxSize[1],-e.boxSize[2]),k(this._boxCorners[1],+e.boxSize[0],-e.boxSize[1],-e.boxSize[2]),k(this._boxCorners[2],-e.boxSize[0],+e.boxSize[1],-e.boxSize[2]),k(this._boxCorners[3],+e.boxSize[0],+e.boxSize[1],-e.boxSize[2]),k(this._boxCorners[4],-e.boxSize[0],-e.boxSize[1],+e.boxSize[2]),k(this._boxCorners[5],+e.boxSize[0],-e.boxSize[1],+e.boxSize[2]),k(this._boxCorners[6],-e.boxSize[0],+e.boxSize[1],+e.boxSize[2]),k(this._boxCorners[7],+e.boxSize[0],+e.boxSize[1],+e.boxSize[2])].forEach((e=>{X(this._boxPos,e,this._boxMat4_a),t[0]=Math.min(t[0],this._boxPos[0]),t[1]=Math.min(t[1],this._boxPos[1]),t[2]=Math.min(t[2],this._boxPos[2]),i[0]=Math.max(i[0],this._boxPos[0]),i[1]=Math.max(i[1],this._boxPos[1]),i[2]=Math.max(i[2],this._boxPos[2])})),i[0]-t[0]<Bt&&(i[0]+=Bt),i[1]-t[1]<Bt&&(i[1]+=Bt),i[2]-t[2]<Bt&&(i[2]+=Bt),n.push({shapeIndex:r++,type:"box",shape:e,min:t,max:i})}r=2e3;for(const e of i){const t=I(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),i=I(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);t[0]=Math.min(t[0],e.v0[0]),t[1]=Math.min(t[1],e.v0[1]),t[2]=Math.min(t[2],e.v0[2]),i[0]=Math.max(i[0],e.v0[0]),i[1]=Math.max(i[1],e.v0[1]),i[2]=Math.max(i[2],e.v0[2]),t[0]=Math.min(t[0],e.v1[0]),t[1]=Math.min(t[1],e.v1[1]),t[2]=Math.min(t[2],e.v1[2]),i[0]=Math.max(i[0],e.v1[0]),i[1]=Math.max(i[1],e.v1[1]),i[2]=Math.max(i[2],e.v1[2]),t[0]=Math.min(t[0],e.v2[0]),t[1]=Math.min(t[1],e.v2[1]),t[2]=Math.min(t[2],e.v2[2]),i[0]=Math.max(i[0],e.v2[0]),i[1]=Math.max(i[1],e.v2[1]),i[2]=Math.max(i[2],e.v2[2]),i[0]-t[0]<Bt&&(i[0]+=Bt),i[1]-t[1]<Bt&&(i[1]+=Bt),i[2]-t[2]<Bt&&(i[2]+=Bt),n.push({shapeIndex:r++,type:"triangle",shape:e,min:t,max:i})}this._bvhTree.synchronize(n)}getRootNode(){return this._bvhTree.getRootNode()}}class zt{static _bvhRenderAABB(e,t,i,n){const r=.05,a=[[t[0]-r,t[1]-r,t[2]-r],[i[0]+r,t[1]-r,t[2]-r],[t[0]-r,i[1]+r,t[2]-r],[i[0]+r,i[1]+r,t[2]-r],[t[0]-r,t[1]-r,i[2]+r],[i[0]+r,t[1]-r,i[2]+r],[t[0]-r,i[1]+r,i[2]+r],[i[0]+r,i[1]+r,i[2]+r]],s=[[0,1],[1,3],[3,2],[2,0],[4,5],[5,7],[7,6],[6,4],[0,4],[1,5],[2,6],[3,7]];for(const t of s)e.push3dLine(a[t[0]],a[t[1]],.025,.025,n,n)}static renderNode(e,t,i){if(this._bvhRenderAABB(t,e.min,e.max,i),e._leftNode){this.renderNode(e._leftNode,t,[0,.5,0]);const i=[e.max[0]+.1,e.max[1]+.1,e.max[2]+.1],n=[e._leftNode.max[0]+.1,e._leftNode.max[1]+.1,e._leftNode.max[2]+.1];t.push3dLine(i,n,.2,0,[1,0,1],[1,0,1])}if(e._rightNode){this.renderNode(e._rightNode,t,[0,0,.5]);const i=[e.max[0]+.1,e.max[1]+.1,e.max[2]+.1],n=[e._rightNode.max[0]+.1,e._rightNode.max[1]+.1,e._rightNode.max[2]+.1];t.push3dLine(i,n,.2,0,[1,0,1],[1,0,1])}if(e._leftLeaf){this._bvhRenderAABB(t,e._leftLeaf.min,e._leftLeaf.max,[.5,.5,0]);const i=[e.max[0]+.1,e.max[1]+.1,e.max[2]+.1],n=[e._leftLeaf.max[0]+.1,e._leftLeaf.max[1]+.1,e._leftLeaf.max[2]+.1];t.push3dLine(i,n,.2,0,[1,0,0],[1,0,0])}if(e._rightLeaf){this._bvhRenderAABB(t,e._rightLeaf.min,e._rightLeaf.max,[.5,.5,0]);const i=[e.max[0]+.1,e.max[1]+.1,e.max[2]+.1],n=[e._rightLeaf.max[0]+.1,e._rightLeaf.max[1]+.1,e._rightLeaf.max[2]+.1];t.push3dLine(i,n,.2,0,[1,0,0],[1,0,0])}}static renderDebugWireframe(e,t){e&&this.renderNode(e,t,[.5,0,0])}}class Ft{constructor(e){this._allNodes=[],this._gpuDataTexture2d=e}syncRootNode(e){if(this._allNodes.length=0,!e)return;const t=e=>{this._allNodes.push(e),e._leftNode&&t(e._leftNode),e._rightNode&&t(e._rightNode)};t(e),this._allNodes.sort(((e,t)=>e._index-t._index))}prepareBuffer(){var e,t,i,n,r,a,s,o;this._gpuDataTexture2d.clear();for(const h of this._allNodes)this._gpuDataTexture2d.push(h.min[0],h.min[1],h.min[2],h.max[0]),this._gpuDataTexture2d.push(h.max[1],h.max[2],(null!==(t=null===(e=h._leftNode)||void 0===e?void 0:e._index)&&void 0!==t?t:-2)+.5,(null!==(n=null===(i=h._rightNode)||void 0===i?void 0:i._index)&&void 0!==n?n:-2)+.5),this._gpuDataTexture2d.push((null!==(a=null===(r=h._leftLeaf)||void 0===r?void 0:r.shapeIndex)&&void 0!==a?a:-2)+.5,(null!==(o=null===(s=h._rightLeaf)||void 0===s?void 0:s.shapeIndex)&&void 0!==o?o:-2)+.5,0,0)}}class Lt{constructor(e){this._basicMaterialsPerAliases=new Map,this._allBasicMaterials=[],this._chessboardMaterialsPerAliases=new Map,this._allChessboardMaterials=[],this._matAliasToIndex=new Map,this._gpuDataTexture2d=e}pushBasicMaterial(e){if(this._basicMaterialsPerAliases.has(e.materialAlias))throw new Error(`duplicated basic material alias -> "${e.materialAlias}"`);if(e.reflectionFactor<0||e.reflectionFactor>1)throw new Error("invalid sphere reflection");if(e.refractionFactor<0||e.refractionFactor>1)throw new Error("invalid sphere refractionFactor");const t=Object.assign(Object.assign({},e),{materialType:0});return this._allBasicMaterials.push(t),this._basicMaterialsPerAliases.set(t.materialAlias,t),t.materialAlias}pushChessboardMaterial(e){if(this._chessboardMaterialsPerAliases.has(e.materialAlias))throw new Error(`duplicated chessboard material alias -> "${e.materialAlias}"`);if(!this._basicMaterialsPerAliases.has(e.materialAliasA))throw new Error(`missing material alias A -> "${e.materialAliasA}"`);if(!this._basicMaterialsPerAliases.has(e.materialAliasB))throw new Error(`missing material alias B -> "${e.materialAliasB}"`);const t=Object.assign(Object.assign({},e),{materialType:0});return this._allChessboardMaterials.push(t),this._chessboardMaterialsPerAliases.set(t.materialAlias,t),t.materialAlias}has(e){return this._basicMaterialsPerAliases.has(e)||this._chessboardMaterialsPerAliases.has(e)}canCastShadow(e){var t,i;return!0===(null===(t=this._basicMaterialsPerAliases.get(e))||void 0===t?void 0:t.castShadowEnabled)||!0===(null===(i=this._chessboardMaterialsPerAliases.get(e))||void 0===i?void 0:i.castShadowEnabled)}clear(){this._chessboardMaterialsPerAliases.clear(),this._allBasicMaterials.length=0,this._basicMaterialsPerAliases.clear(),this._allChessboardMaterials.length=0,this._matAliasToIndex.clear()}prepareBuffer(){this._gpuDataTexture2d.clear();let e=0;this._matAliasToIndex.clear(),this._allBasicMaterials.forEach((t=>{this._matAliasToIndex.set(t.materialAlias,e),e+=1,this._gpuDataTexture2d.push(.5,0,t.reflectionFactor,t.refractionFactor),this._gpuDataTexture2d.push(t.receiveLightEnabled?1:0,t.color[0],t.color[1],t.color[2])})),this._allChessboardMaterials.forEach((t=>{this._matAliasToIndex.set(t.materialAlias,e),e+=1;const i=this._matAliasToIndex.get(t.materialAliasA),n=this._matAliasToIndex.get(t.materialAliasB);if(void 0===i||void 0===n)throw new Error("chessboard material, associated basic material not found");this._gpuDataTexture2d.push(1.5,0,i+.5,n+.5),this._gpuDataTexture2d.push(t.chessboardArgs?t.chessboardArgs[0]:1,t.chessboardArgs?t.chessboardArgs[1]:1,t.chessboardArgs?t.chessboardArgs[2]:1,0)}))}getIndexFromAlias(e){return this._matAliasToIndex.get(e)}}class Nt{constructor(e){this._spotLights=[],this._gpuDataTexture2d=e}pushSpotLight({position:e,intensity:t,radius:i}){if(t<=0)throw new Error("intensity cannot be <= 0");if(i<=0)throw new Error("radius cannot be <= 0");this._spotLights.push({position:P(e),intensity:t,radius:i})}clear(){this._spotLights.length=0}prepareBuffer(){this._gpuDataTexture2d.clear();for(const e of this._spotLights)this._gpuDataTexture2d.push(e.position[0],e.position[1],e.position[2],e.radius),this._gpuDataTexture2d.push(e.intensity,0,0,0)}get spotLights(){return this._spotLights}}class Vt{constructor(e,t){this._spheres=[],this._boxes=[],this._triangles=[],this._gpuDataTexture2d=e,this._materialsManager=t}pushSphere({position:e,orientation:t,radius:i,materialAlias:n}){if(i<=0)throw new Error("invalid sphere radius");if(!this._materialsManager.has(n))throw new Error(`not found material alias -> "${n}"`);this._spheres.push({position:[e[0],e[1],e[2]],orientation:[t[0],t[1],t[2],t[3]],radius:i,materialAlias:n})}pushBox({position:e,orientation:t,boxSize:i,materialAlias:n}){if(i[0]<=0||i[1]<=0||i[2]<=0)throw new Error("invalid box size");if(!this._materialsManager.has(n))throw new Error(`not found material alias -> "${n}"`);this._boxes.push({position:[e[0],e[1],e[2]],orientation:[t[0],t[1],t[2],t[3]],boxSize:P(i),materialAlias:n})}pushTriangle({v0:e,v1:t,v2:i,materialAlias:n}){if(!this._materialsManager.has(n))throw new Error(`not found material alias -> "${n}"`);this._triangles.push({v0:P(e),v1:P(t),v2:P(i),materialAlias:n})}clear(){this._spheres.length=0,this._boxes.length=0,this._triangles.length=0}prepareBufferSpheres(){this._gpuDataTexture2d.clear();for(const e of this._spheres){const t=this._materialsManager.getIndexFromAlias(e.materialAlias);if(void 0===t)throw new Error(`sphere materialAlias not found ${e.materialAlias}`);const i=this._materialsManager.canCastShadow(e.materialAlias);this._gpuDataTexture2d.push(i?1:.5,t+.5,e.position[0],e.position[1]),this._gpuDataTexture2d.push(e.position[2],e.orientation[0],e.orientation[1],e.orientation[2]),this._gpuDataTexture2d.push(e.orientation[3],e.radius,0,0)}}prepareBufferBoxes(){this._gpuDataTexture2d.clear();for(const e of this._boxes){const t=this._materialsManager.getIndexFromAlias(e.materialAlias);if(void 0===t)throw new Error(`box materialAlias not found ${e.materialAlias}`);const i=this._materialsManager.canCastShadow(e.materialAlias);this._gpuDataTexture2d.push(i?1:.5,t+.5,e.position[0],e.position[1]),this._gpuDataTexture2d.push(e.position[2],e.orientation[0],e.orientation[1],e.orientation[2]),this._gpuDataTexture2d.push(e.orientation[3],e.boxSize[0],e.boxSize[1],e.boxSize[2])}}prepareBufferTriangles(){this._gpuDataTexture2d.clear();for(const e of this._triangles){const t=this._materialsManager.getIndexFromAlias(e.materialAlias);if(void 0===t)throw new Error(`triangle materialAlias not found ${e.materialAlias}`);const i=this._materialsManager.canCastShadow(e.materialAlias);this._gpuDataTexture2d.push(i?1:.5,t+.5,e.v0[0],e.v0[1]),this._gpuDataTexture2d.push(e.v0[2],e.v1[0],e.v1[1],e.v1[2]),this._gpuDataTexture2d.push(e.v2[0],e.v2[1],e.v2[2],0)}}get spheres(){return this._spheres}get boxes(){return this._boxes}get triangles(){return this._triangles}}class Ut{constructor(e){this._dataValues=new Float32Array(6144),this._currentIndex=0,this._textureUniformName=e,this._dataTexture=new me,this._dataTexture.initialize(2048,6)}push(e,t,i,n){if(this._currentIndex>=6144)throw new Error("not more space left in the GpuDataTexture2d heap cache, max length is 6144.");this._dataValues[4*this._currentIndex+0]=e,this._dataValues[4*this._currentIndex+1]=t,this._dataValues[4*this._currentIndex+2]=i,this._dataValues[4*this._currentIndex+3]=n,this._currentIndex+=1}clear(){this._currentIndex=0}uploadGpuDataAsRow(e){this._dataTexture.preBind((t=>{t.updateFromBuffer(0,e,this._currentIndex,1,this._dataValues)}))}uploadGpuData(e,t,i,n){this._dataTexture.preBind((r=>{r.updateFromBuffer(e,t,i,n,this._dataValues)}))}getCurrentIndex(){return this._currentIndex}setForShader(e,t){e.setInteger1Uniform(this._textureUniformName,t)}}const{WebGLContext:Gt,ShaderProgram:Xt,GeometryWrapper:Ot}=ze;class Wt{constructor(e){this._bvhTree=new kt,this._gpuDataTexture2d=new Ut("u_dataTexture"),this._cameraFovy=e.fovy,this._renderWidth=e.width,this._renderHeight=e.height,this._rayTracerShaderProgram=new Xt("RayTracerRenderer-1",{vertexSrc:Mt,fragmentSrc:Ct,attributes:["a_vertexPosition","a_plotPosition"],uniforms:["u_cameraEye","u_dataTexture","u_lightsTextureSize"]});const t=new Ot.GeometryBuilder;t.reset().setPrimitiveType("triangleStrip").addVbo().addVboAttribute("a_vertexPosition","vec2f").addVbo().setVboAsDynamic().addVboAttribute("a_plotPosition","vec3f"),this._rayTracerGeometry=new Ot.Geometry(this._rayTracerShaderProgram,t.getDef());const i=[];i.push(1,1),i.push(-1,1),i.push(1,-1),i.push(-1,-1),this._rayTracerGeometry.allocateBuffer(0,i,i.length),this._rayTracerGeometry.setPrimitiveStart(0),this._rayTracerGeometry.setPrimitiveCount(4),this._gpuBvhManager=new Ft(this._gpuDataTexture2d),this._gpuMaterialsManager=new Lt(this._gpuDataTexture2d),this._gpuShapesManager=new Vt(this._gpuDataTexture2d,this._gpuMaterialsManager),this._gpuSpotLightsManager=new Nt(this._gpuDataTexture2d),this._camera={position:I(0,0,0),target:I(1.5,1.5,1.5),up:I(0,1,0)}}lookAt(e,t,i){B(this._camera.position,e);let n=W(D(),t,e);n=V(n,n),n=z(n,e,n),B(this._camera.target,n);const r=V(D(),i);B(this._camera.up,r)}render(){const e=Gt.getContext(),t=this._computeCameraFarCornersBufferGeometry();this._rayTracerGeometry.allocateBuffer(1,t,t.length),this._gpuMaterialsManager.prepareBuffer(),this._gpuDataTexture2d.uploadGpuDataAsRow(0),this._gpuShapesManager.prepareBufferSpheres(),this._gpuDataTexture2d.uploadGpuDataAsRow(1),this._gpuShapesManager.prepareBufferBoxes(),this._gpuDataTexture2d.uploadGpuDataAsRow(2),this._gpuShapesManager.prepareBufferTriangles(),this._gpuDataTexture2d.uploadGpuDataAsRow(3),this._gpuSpotLightsManager.prepareBuffer(),this._gpuDataTexture2d.uploadGpuDataAsRow(4);const i=this._gpuDataTexture2d.getCurrentIndex();this._bvhTree.synchronize(this._gpuShapesManager.spheres,this._gpuShapesManager.boxes,this._gpuShapesManager.triangles),this._gpuBvhManager.syncRootNode(this._bvhTree.getRootNode()),this._gpuBvhManager.prepareBuffer(),this._gpuDataTexture2d.uploadGpuDataAsRow(5),e.viewport(0,0,this._renderWidth,this._renderHeight),e.clear(e.COLOR_BUFFER_BIT),this._rayTracerShaderProgram.bind((t=>{t.setFloat3Uniform("u_cameraEye",this._camera.position[0],this._camera.position[1],this._camera.position[2]),t.setInteger1Uniform("u_lightsTextureSize",i);{const i=0;e.activeTexture(e.TEXTURE0+i),this._gpuDataTexture2d.setForShader(t,i)}this._rayTracerGeometry.render()}))}reset(){this._gpuSpotLightsManager.clear(),this._gpuMaterialsManager.clear(),this._gpuShapesManager.clear()}bvhRenderDebugWireframe(e){zt.renderDebugWireframe(this._bvhTree.getRootNode(),e)}setRenderSize(e,t){e<10||t<10||(this._renderWidth=Math.floor(e),this._renderHeight=Math.floor(t))}getCurrentSize(){return[this._renderWidth,this._renderHeight]}get renderWidth(){return this._renderWidth}get renderHeight(){return this._renderHeight}get camera(){return this._camera}get gpuMaterialsManager(){return this._gpuMaterialsManager}get gpuShapesManager(){return this._gpuShapesManager}get gpuSpotLightsManager(){return this._gpuSpotLightsManager}_computeCameraFarCornersBufferGeometry(){const e=W(D(),this._camera.target,this._camera.position),t=U(D(),e,this._camera.up),i=U(D(),t,e),n=.5*this._cameraFovy*Math.PI/180,r=1*Math.cos(n)/Math.sin(n),a=L(D(),e,I(r,r,r)),s=z(D(),this._camera.position,a),o=this._renderWidth/this._renderHeight,h=L(D(),t,I(o,o,o)),d=z(D(),s,i),c=F(D(),s,i),l=F(D(),d,h),f=F(D(),c,h),u=z(D(),d,h),_=z(D(),c,h);return[u[0],u[1],u[2],l[0],l[1],l[2],_[0],_[1],_[2],f[0],f[1],f[2]]}}var Ht="\n#version 300 es\n\nprecision highp float;\n\nin vec2 a_vertexPosition;\nin vec2 a_vertexTextureCoord;\n\nout vec2 v_textureCoord;\n\nvoid main(void)\n{\n  v_textureCoord = a_vertexTextureCoord;\n\n  gl_Position = vec4(a_vertexPosition, 1.0, 1.0);\n}\n".trim(),Yt="\n#version 300 es\n\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec2 u_renderedSize;\nuniform float u_gridSize;\n\nin vec2 v_textureCoord;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  float total = 0.0;\n  vec4 accumulated = vec4(0.0);\n\n  //\n\n  int gridSize = int(u_gridSize);\n\n  int srcX = int(u_renderedSize.x * v_textureCoord.x);\n  int srcY = int(u_renderedSize.y * v_textureCoord.y);\n\n  int minX = min(max(srcX - gridSize, 0), int(u_renderedSize.x) - 1);\n  int minY = min(max(srcY - gridSize, 0), int(u_renderedSize.y) - 1);\n  int maxX = min(max(srcX + gridSize, 0), int(u_renderedSize.x) - 1);\n  int maxY = min(max(srcY + gridSize, 0), int(u_renderedSize.y) - 1);\n\n  for (int yy = minY; yy <= maxY; ++yy)\n  {\n    for (int xx = minX; xx <= maxX; ++xx)\n    {\n      accumulated += texelFetch(u_texture, ivec2(xx, yy), 0);\n      total += 1.0;\n    }\n  }\n\n  //\n\n  if (total > 0.0) {\n    o_color = accumulated / total;\n  } else {\n    o_color = vec4(1.0, 0.0, 0.0, 1.0); // warning\n  }\n}\n".trim(),$t="\n#version 300 es\n\nprecision highp float;\n\nin vec2 a_vertexPosition;\nin vec2 a_vertexTextureCoord;\n\nout vec2 v_textureCoord;\n\nvoid main(void)\n{\n  v_textureCoord = a_vertexTextureCoord;\n\n  gl_Position = vec4(a_vertexPosition, 1.0, 1.0);\n}\n".trim(),qt="\n#version 300 es\n\nprecision highp float;\n\nuniform sampler2D u_texture;\n\n\n\n// https://www.shadertoy.com/view/4ll3RB\n\n#define r vec2(800, 600)\n// #define t 0\n\n#define zoom 1.\n#define P(id, a, b, c, d, e, f, g, h)   if ( id == int(pos.y) ) {     int pa = a + 2 * (b + 2 * (c + 2 * (d + 2 * (e + 2 * (f + 2 * (g + 2 * (h)))))));     cha = floor(mod(float(pa)/pow(2.0,float(pos.x)-1.0),2.0));   }\n\nfloat gray(vec3 _i)\n{\n  return _i.x*0.299+_i.y*0.587+_i.z*0.114;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(floor(fragCoord.x/8./zoom)*8.*zoom,floor(fragCoord.y/12./zoom)*12.*zoom)/r;\n  ivec2 pos = ivec2(mod(fragCoord.x/zoom,8.),mod(fragCoord.y/zoom,12.));\n  vec4 tex = texture(u_texture,uv);\n  float cha = 0.;\n\n  float g = gray(tex.xyz);\n  if( g < .125 ) // nothing\n  {\n    P(11,0,0,0,0,0,0,0,0);\n    P(10,0,0,0,0,0,0,0,0);\n    P(9,0,0,0,0,0,0,0,0);\n    P(8,0,0,0,0,0,0,0,0);\n    P(7,0,0,0,0,0,0,0,0);\n    P(6,0,0,0,0,0,0,0,0);\n    P(5,0,0,0,0,0,0,0,0);\n    P(4,0,0,0,0,0,0,0,0);\n    P(3,0,0,0,0,0,0,0,0);\n    P(2,0,0,0,0,0,0,0,0);\n    P(1,0,0,0,0,0,0,0,0);\n    P(0,0,0,0,0,0,0,0,0);\n  }\n  else if( g < .25 ) // .\n  {\n    P(11,0,0,0,0,0,0,0,0);\n    P(10,0,0,0,0,0,0,0,0);\n    P(9,0,0,0,0,0,0,0,0);\n    P(8,0,0,0,0,0,0,0,0);\n    P(7,0,0,0,0,0,0,0,0);\n    P(6,0,0,0,0,0,0,0,0);\n    P(5,0,0,0,0,0,0,0,0);\n    P(4,0,0,0,1,1,0,0,0);\n    P(3,0,0,0,1,1,0,0,0);\n    P(2,0,0,0,0,0,0,0,0);\n    P(1,0,0,0,0,0,0,0,0);\n    P(0,0,0,0,0,0,0,0,0);\n  }\n  else if( g < .375 ) // ,\n  {\n    P(11,0,0,0,0,0,0,0,0);\n    P(10,0,0,0,0,0,0,0,0);\n    P(9,0,0,0,0,0,0,0,0);\n    P(8,0,0,0,0,0,0,0,0);\n    P(7,0,0,0,0,0,0,0,0);\n    P(6,0,0,0,0,0,0,0,0);\n    P(5,0,0,0,0,0,0,0,0);\n    P(4,0,0,0,1,1,0,0,0);\n    P(3,0,0,0,1,1,0,0,0);\n    P(2,0,0,0,0,1,0,0,0);\n    P(1,0,0,0,1,0,0,0,0);\n    P(0,0,0,0,0,0,0,0,0);\n  }\n  else if( g < .5 ) // -\n  {\n    P(11,0,0,0,0,0,0,0,0);\n    P(10,0,0,0,0,0,0,0,0);\n    P(9,0,0,0,0,0,0,0,0);\n    P(8,0,0,0,0,0,0,0,0);\n    P(7,0,0,0,0,0,0,0,0);\n    P(6,1,1,1,1,1,1,1,0);\n    P(5,0,0,0,0,0,0,0,0);\n    P(4,0,0,0,0,0,0,0,0);\n    P(3,0,0,0,0,0,0,0,0);\n    P(2,0,0,0,0,0,0,0,0);\n    P(1,0,0,0,0,0,0,0,0);\n    P(0,0,0,0,0,0,0,0,0);\n  }\n  else if(g < .625 ) // +\n  {\n    P(11,0,0,0,0,0,0,0,0);\n    P(10,0,0,0,0,0,0,0,0);\n    P(9,0,0,0,1,0,0,0,0);\n    P(8,0,0,0,1,0,0,0,0);\n    P(7,0,0,0,1,0,0,0,0);\n    P(6,1,1,1,1,1,1,1,0);\n    P(5,0,0,0,1,0,0,0,0);\n    P(4,0,0,0,1,0,0,0,0);\n    P(3,0,0,0,1,0,0,0,0);\n    P(2,0,0,0,0,0,0,0,0);\n    P(1,0,0,0,0,0,0,0,0);\n    P(0,0,0,0,0,0,0,0,0);\n  }\n  else if(g < .75 ) // *\n  {\n    P(11,0,0,0,0,0,0,0,0);\n    P(10,0,0,0,1,0,0,0,0);\n    P(9,1,0,0,1,0,0,1,0);\n    P(8,0,1,0,1,0,1,0,0);\n    P(7,0,0,1,1,1,0,0,0);\n    P(6,0,0,0,1,0,0,0,0);\n    P(5,0,0,1,1,1,0,0,0);\n    P(4,0,1,0,1,0,1,0,0);\n    P(3,1,0,0,1,0,0,1,0);\n    P(2,0,0,0,1,0,0,0,0);\n    P(1,0,0,0,0,0,0,0,0);\n    P(0,0,0,0,0,0,0,0,0);\n  }\n  else if(g < .875 ) // #\n  {\n    P(11,0,0,0,0,0,0,0,0);\n    P(10,0,0,1,0,0,1,0,0);\n    P(9,0,0,1,0,0,1,0,0);\n    P(8,1,1,1,1,1,1,1,0);\n    P(7,0,0,1,0,0,1,0,0);\n    P(6,0,0,1,0,0,1,0,0);\n    P(5,0,1,0,0,1,0,0,0);\n    P(4,0,1,0,0,1,0,0,0);\n    P(3,1,1,1,1,1,1,1,0);\n    P(2,0,1,0,0,1,0,0,0);\n    P(1,0,1,0,0,1,0,0,0);\n    P(0,0,0,0,0,0,0,0,0);\n  }\n  else // @\n  {\n    P(11,0,0,0,0,0,0,0,0);\n    P(10,0,0,1,1,1,1,0,0);\n    P(9,0,1,0,0,0,0,1,0);\n    P(8,1,0,0,0,1,1,1,0);\n    P(7,1,0,0,1,0,0,1,0);\n    P(6,1,0,0,1,0,0,1,0);\n    P(5,1,0,0,1,0,0,1,0);\n    P(4,1,0,0,1,0,0,1,0);\n    P(3,1,0,0,1,1,1,1,0);\n    P(2,0,1,0,0,0,0,0,0);\n    P(1,0,0,1,1,1,1,1,0);\n    P(0,0,0,0,0,0,0,0,0);\n  }\n\n  vec3 col = tex.xyz/max(tex.x,max(tex.y,tex.z));\n  fragColor = vec4(cha*col,1.);\n}\n\nin vec2 v_textureCoord;\n\nout vec4 o_color;\n\nvoid main(void)\n{\n  mainImage(o_color, v_textureCoord * r);\n  // mainImage(o_color, vec2(gl_FragCoord));\n\n}\n".trim();const{WebGLContext:jt,Texture:Kt,FrameBuffer:Zt,ShaderProgram:Qt,GeometryWrapper:Jt}=ze;class ei{constructor(e){this._resolutionCoef=1,this._antiAliasing=!1,this._width=e.width,this._height=e.height,this._textureShaderProgram=new Qt("RayTracerRenderer-1",{vertexSrc:Ht,fragmentSrc:Yt,attributes:["a_vertexPosition","a_vertexTextureCoord"],uniforms:["u_texture","u_renderedSize","u_gridSize"]}),this._asciiArtShaderProgram=new Qt("RayTracerRenderer-ascii-art",{vertexSrc:$t,fragmentSrc:qt,attributes:["a_vertexPosition","a_vertexTextureCoord"],uniforms:["u_texture"]}),this._finalTexture=new Kt,this._frameBuffer=new Zt,this._finalTexture.initialize(),this._finalTexture.preBind((e=>{e.allocate(this._width,this._height),this._frameBuffer.bind((t=>{t.attachTexture(e)}))}));const t=new Jt.GeometryBuilder,i=[];i.push(1,1,1,1),i.push(-1,1,0,1),i.push(1,-1,1,0),i.push(-1,-1,0,0),t.reset().setPrimitiveType("triangleStrip").addVbo().addVboAttribute("a_vertexPosition","vec2f").addVboAttribute("a_vertexTextureCoord","vec2f"),this._screenGeometry=new Jt.Geometry(this._asciiArtShaderProgram,t.getDef()),this._screenGeometry.allocateBuffer(0,i,i.length),this._screenGeometry.setPrimitiveStart(0),this._screenGeometry.setPrimitiveCount(4),this._asciiArtScreenGeometry=new Jt.Geometry(this._asciiArtShaderProgram,t.getDef()),this._asciiArtScreenGeometry.allocateBuffer(0,i,i.length),this._asciiArtScreenGeometry.setPrimitiveStart(0),this._asciiArtScreenGeometry.setPrimitiveCount(4)}render(e,t){const i=jt.getContext();i.viewport(0,0,this._width,this._height),i.clear(i.COLOR_BUFFER_BIT),this._textureShaderProgram.bind((i=>{i.setTextureUniform("u_texture",this._finalTexture,0),i.setFloat2Uniform("u_renderedSize",e,t),this._antiAliasing?i.setFloat1Uniform("u_gridSize",1):i.setFloat1Uniform("u_gridSize",0),this._screenGeometry.render()}))}renderAsciiArt(){const e=jt.getContext();e.viewport(0,0,this._width,this._height),e.clear(e.COLOR_BUFFER_BIT),this._asciiArtShaderProgram.bind((e=>{e.setTextureUniform("u_texture",this._finalTexture,0),this._asciiArtScreenGeometry.render()}))}setRenderSize(e,t){const i=Math.floor(e),n=Math.floor(t);this._finalTexture.preBind((e=>{e.resize(i,n)}))}capture(e){const t=jt.getContext();this._frameBuffer.bind((()=>{e()})),t.viewport(0,0,this._width,this._height)}getResolutionCoef(){return this._resolutionCoef}setAntiAliasing(e){this._antiAliasing=e}getAntiAliasing(){return this._antiAliasing}get canvasWidth(){return this._width}get canvasHeight(){return this._height}}const{WebGLContext:ti}=ze;class ii{constructor(e){this._resolutionCoef=1,this._antiAliasing=!1,this._canvasWidth=e.canvasWidth,this._canvasHeight=e.canvasHeight,this._rayTracerPass=new Wt({width:e.canvasWidth,height:e.canvasHeight,fovy:e.fovy}),this._postProcessPass=new ei({width:e.canvasWidth,height:e.canvasHeight})}renderTexturePass(){const e=ti.getContext();e.viewport(0,0,this._canvasWidth,this._canvasHeight),e.clear(e.COLOR_BUFFER_BIT),this._postProcessPass.setAntiAliasing(this._antiAliasing),this._postProcessPass.render(this._rayTracerPass.renderWidth,this._rayTracerPass.renderHeight)}_renderAsciiArtTexturePass(){const e=ti.getContext();e.viewport(0,0,this._canvasWidth,this._canvasHeight),e.clear(e.COLOR_BUFFER_BIT),this._postProcessPass.renderAsciiArt()}renderRayTracingPass(){this._postProcessPass.capture((()=>{this._rayTracerPass.render()}))}reset(){this._rayTracerPass.reset()}setResolutionCoef(e){if(e===this._resolutionCoef||e<=0||e>1)return;this._resolutionCoef=e;const t=Math.floor(this._canvasWidth*this._resolutionCoef),i=Math.floor(this._canvasHeight*this._resolutionCoef);this._rayTracerPass.setRenderSize(t,i),this._postProcessPass.setRenderSize(t,i)}getResolutionCoef(){return this._resolutionCoef}setAntiAliasing(e){this._antiAliasing=e}getAntiAliasing(){return this._antiAliasing}getCurrentSize(){return this._rayTracerPass.getCurrentSize()}get canvasWidth(){return this._canvasWidth}get canvasHeight(){return this._canvasHeight}get rayTracerPass(){return this._rayTracerPass}}const{WebGLContext:ni}=ze,{Camera:ri}=le,{TextRenderer:ai,StackRenderers:si}=ot;class oi{constructor(e){this._debugSceneCamera=new ri,this._mainHudCamera=new ri,this._def=e,this.resize(this._def.width,this._def.height),this._rayTracerRenderer=new ii({canvasWidth:this._def.width,canvasHeight:this._def.height,fovy:70}),this._textRenderer=new ai,this._stackRenderers=new si,this._multipleBuffering=new We(this._def.width,this._def.height)}initialize(){const e=ni.getContext();e.disable(e.DEPTH_TEST),e.disable(e.BLEND),e.disable(e.CULL_FACE),e.depthFunc(e.NEVER),e.clearColor(0,0,0,1),e.clearDepth(1)}resize(e,t){this._debugSceneCamera.setViewportSize(e,t),this._debugSceneCamera.setAsPerspective({fovy:70,near:1,far:500}),this._mainHudCamera.setViewportSize(e,t);const i=.5*e,n=.5*t;this._mainHudCamera.setAsOrthogonal({left:-i,right:+i,top:-n,bottom:+n,near:-200,far:200}),this._mainHudCamera.setEye([i,n,1]),this._mainHudCamera.setTarget([i,n,0]),this._mainHudCamera.setUpAxis([0,1,0]),this._mainHudCamera.computeMatrices()}_pushWireFrameSphere(e,t){const i=E(S());A(i,i,e.position);const n=C(S(),e.orientation);R(i,i,n);const r=[];((e,t)=>{const i=.5257311121191336,n=.8506508083520399,r=[[-i,0,+n],[+i,0,+n],[-i,0,-n],[+i,0,-n],[0,+n,+i],[0,+n,-i],[0,-n,+i],[0,-n,-i],[+n,+i,0],[-n,+i,0],[+n,-i,0],[-n,-i,0]],a=[[0,4,1],[0,9,4],[9,5,4],[4,5,8],[4,8,1],[8,10,1],[8,3,10],[5,3,8],[5,2,3],[2,7,3],[7,10,3],[7,6,10],[7,11,6],[11,0,6],[0,1,6],[6,1,10],[9,0,11],[9,11,2],[9,2,5],[7,2,11]],s=[];for(const e of a)ht(s,1,t,r[e[0]],r[e[1]],r[e[2]]);return s})(0,e.radius).forEach((e=>{const t=I(0,0,0);X(t,e.pos,i),r.push(t)}));for(let e=0;e<r.length;e+=3){const i=r[e+0],n=r[e+1],a=r[e+2];this._stackRenderers.push3dLine(i,n,.02,.02,t,t),this._stackRenderers.push3dLine(n,a,.02,.02,t,t),this._stackRenderers.push3dLine(a,i,.02,.02,t,t)}}_pushWireFrameBox(e,t){const i=[I(-e.boxSize[0],-e.boxSize[1],-e.boxSize[2]),I(+e.boxSize[0],-e.boxSize[1],-e.boxSize[2]),I(-e.boxSize[0],+e.boxSize[1],-e.boxSize[2]),I(+e.boxSize[0],+e.boxSize[1],-e.boxSize[2]),I(-e.boxSize[0],-e.boxSize[1],+e.boxSize[2]),I(+e.boxSize[0],-e.boxSize[1],+e.boxSize[2]),I(-e.boxSize[0],+e.boxSize[1],+e.boxSize[2]),I(+e.boxSize[0],+e.boxSize[1],+e.boxSize[2])],n=[],r=E(S());A(r,r,e.position);const a=C(S(),e.orientation);R(r,r,a),i.forEach((e=>{const t=I(0,0,0);X(t,e,r),n.push(t)})),[[0,1],[1,3],[3,2],[2,0],[4,5],[5,7],[7,6],[6,4],[0,4],[1,5],[3,7],[2,6]].forEach((e=>{this._stackRenderers.push3dLine(n[e[0]],n[e[1]],.02,.02,t,t)}))}_pushWireFrameTriangle(e,t){this._stackRenderers.push3dLine(e.v0,e.v1,.02,.02,t,t),this._stackRenderers.push3dLine(e.v1,e.v2,.02,.02,t,t),this._stackRenderers.push3dLine(e.v2,e.v0,.02,.02,t,t)}safeSceneWireFrame(e){this._debugSceneCamera.setEye(this._rayTracerRenderer.rayTracerPass.camera.position),this._debugSceneCamera.setTarget(this._rayTracerRenderer.rayTracerPass.camera.target),this._debugSceneCamera.setUpAxis(this._rayTracerRenderer.rayTracerPass.camera.up),this._debugSceneCamera.computeMatrices(),this._stackRenderers.safeRender(this._debugSceneCamera.getComposedMatrix(),e)}flushHudWireFrame(){this._stackRenderers.flush(this._mainHudCamera.getComposedMatrix())}flushHudText(){this._textRenderer.flush(this._mainHudCamera.getComposedMatrix())}bvhRenderDebugWireframe(){this._rayTracerRenderer.rayTracerPass.bvhRenderDebugWireframe(this._stackRenderers);const e=[1,1,1];this._rayTracerRenderer.rayTracerPass.gpuShapesManager.spheres.forEach((t=>{this._pushWireFrameSphere(t,e)})),this._rayTracerRenderer.rayTracerPass.gpuShapesManager.boxes.forEach((t=>{this._pushWireFrameBox(t,e)})),this._rayTracerRenderer.rayTracerPass.gpuShapesManager.triangles.forEach((t=>{this._pushWireFrameTriangle(t,e)}))}get rayTracerRenderer(){return this._rayTracerRenderer}get stackRenderers(){return this._stackRenderers}get textRenderer(){return this._textRenderer}get multipleBuffering(){return this._multipleBuffering}get debugSceneCamera(){return this._debugSceneCamera}get mainHudCamera(){return this._mainHudCamera}}let hi=0;const di=e=>void 0!==e.materialA&&void 0!==e.materialB,ci=[],li=[0,0,20],fi=(e,t)=>{var i,n,r,a;const s=e.createRigidBody({mass:null!==(i=t.mass)&&void 0!==i?i:0,shape:{type:"box",size:[2*t.boxSize[0],2*t.boxSize[1],2*t.boxSize[2]]},position:t.position,orientation:null!==(n=t.orientation)&&void 0!==n?n:j(q())});s.setRestitution(null!==(r=t.restitution)&&void 0!==r?r:0),s.setFriction(null!==(a=t.friction)&&void 0!==a?a:0),s.disableDeactivation(),ci.push({physicBody:s,boxSize:t.boxSize,material:t.material})},ui=(e,t)=>{var i;let n=t.radius;n+=.05;const r=e.createRigidBody({mass:1,shape:{type:"sphere",radius:n},position:t.position,orientation:j(q())});return r.setFriction(1),r.setRestitution(null!==(i=t.restitution)&&void 0!==i?i:0),r.disableDeactivation(),{physicBody:r,radius:t.radius,material:t.material}};let _i,gi;class pi{ensureSceneData(e){fi(e,{position:[-1,-4,0],orientation:K(q(),[0,0,1],1*Math.PI/32),boxSize:[4,1,2],material:{materialA:{color:[1,1,1]},materialB:{color:[.2,.2,.5]}},friction:1,restitution:.7}),fi(e,{position:[-7,-5,0],orientation:K(q(),[1,0,0],1*Math.PI/32),boxSize:[2,1,2],material:{materialA:{color:[1,1,1]},materialB:{color:[.2,.2,.5]}},friction:1,restitution:.7}),fi(e,{position:[-10,-3,2],orientation:K(q(),[1,0,0],1*Math.PI/32),boxSize:[.25,.25,4],material:{color:[.5,1,.5]},friction:1,restitution:.7}),fi(e,{position:[-12,-1,2],orientation:K(q(),[0,1,0],-1*Math.PI/16),boxSize:[.5,5,4],material:{color:[1,1,1]},friction:1,restitution:.7}),fi(e,{position:[-3,-6,4],orientation:K(q(),[0,0,1],-1*Math.PI/32),boxSize:[6,1,2],material:{materialA:{color:[1,1,1]},materialB:{color:[.2,.2,.5]}},friction:1,restitution:.7}),fi(e,{position:[-7.8,-3,5.5],orientation:K(q(),[0,1,0],-.125*Math.PI),boxSize:[1.5,.25,.25],material:{color:[.5,1,.5]},friction:1,restitution:.7}),fi(e,{position:[-3.8,-3.5,6.5],orientation:K(q(),[0,0,1],-1*Math.PI/32),boxSize:[2.5,.25,.25],material:{color:[.5,1,.5]},friction:1,restitution:.7}),fi(e,{position:[-6,-3.5,7],orientation:K(q(),[1,0,0],0*Math.PI),boxSize:[.25,4,.25],material:{color:[.5,1,.5]},mass:0}),fi(e,{position:[-4.5,-3.5,7],orientation:K(q(),[1,0,0],0*Math.PI),boxSize:[.25,4,.25],material:{color:[.5,1,.5]},mass:0}),fi(e,{position:[-3,-3.5,7],orientation:K(q(),[1,0,0],0*Math.PI),boxSize:[.25,4,.25],material:{color:[.5,1,.5]},mass:0}),fi(e,{position:[-4,-6.5,9.5],orientation:K(q(),[1,0,0],0*Math.PI),boxSize:[5,.25,4],material:{color:[.5,1,.5]}}),_i=ui(e,{position:[0,10,0],radius:1,restitution:.7,material:{materialA:{color:[1,1,1]},materialB:{color:[1,1,0],refractionFactor:.9},chessboardArgs:[.95,.95,.95]}}),gi=ui(e,{position:[-2,10,0],radius:1.5,material:{color:[1,1,1],reflectionFactor:.8,refractionFactor:.8},restitution:.4}),fi(e,{position:[-4,10,0],orientation:K(q(),[1,1,1],.25*Math.PI),boxSize:[1,1,1],material:{color:[1,0,0],reflectionFactor:.2,refractionFactor:.8},mass:1,friction:0,restitution:.7})}run(e,t,i){e>0&&(i.stepSimulation(e,4,1/60),hi+=e);{const e=ie(.25*hi)*Math.PI*2;li[0]=2*Math.cos(e)-4,li[1]=2-1*Math.sin(e),li[2]=2+2*Math.sin(e)}ci.forEach((e=>{e.physicBody.getPosition()[1]<-12&&(e.physicBody.setLinearVelocity(0,0,0),e.physicBody.setAngularVelocity(0,0,0),e.physicBody.setPosition(0,10,0))})),_i&&_i.physicBody.getPosition()[1]<-12&&(_i.physicBody.setLinearVelocity(0,0,0),_i.physicBody.setAngularVelocity(0,0,0),_i.physicBody.setPosition(0,10,0)),gi&&gi.physicBody.getPosition()[1]<-12&&(gi.physicBody.setLinearVelocity(0,0,0),gi.physicBody.setAngularVelocity(0,0,0),gi.physicBody.setPosition(0,10,0)),t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:666,color:[1,1,0],reflectionFactor:0,refractionFactor:0,receiveLightEnabled:!1,castShadowEnabled:!1}),t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushSphere({position:li,orientation:j(q()),radius:.06125,materialAlias:666}),t.rayTracerRenderer.rayTracerPass.gpuSpotLightsManager.pushSpotLight({position:li,intensity:1,radius:15});{const e=ie(.125*hi),i=0+1*ne(e),n=[];n.push([0,i+.4,0]),n.push([.3,i-.6,0]),n.push([0,i-.6,.3]),n.push([-.3,i-.6,-0]),n.push([-0,i-.6,-.3]);const r=E(S());A(r,r,li),M(r,r,Math.PI*e*8),n.forEach((e=>{X(e,e,r)}));const a=[];a.push([0,1,2]),a.push([0,2,3]),a.push([0,3,4]),a.push([0,4,1]);const s=[6e3,6001,6002,6003];t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:s[0],color:[1,0,1],reflectionFactor:0,refractionFactor:.4,receiveLightEnabled:!1,castShadowEnabled:!0}),t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:s[1],color:[1,0,0],reflectionFactor:0,refractionFactor:.4,receiveLightEnabled:!1,castShadowEnabled:!0}),t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:s[2],color:[0,1,0],reflectionFactor:0,refractionFactor:.4,receiveLightEnabled:!1,castShadowEnabled:!0}),t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:s[3],color:[0,0,1],reflectionFactor:0,refractionFactor:.4,receiveLightEnabled:!1,castShadowEnabled:!0}),a.forEach((([e,i,r],a)=>{t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushTriangle({v0:n[e],v1:n[i],v2:n[r],materialAlias:s[a]})}))}{const e=1001;t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:e,color:[1,1,.5],reflectionFactor:0,refractionFactor:.8,castShadowEnabled:!0,receiveLightEnabled:!0}),t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushBox({position:[-9,2,2],orientation:j(q()),boxSize:[.05,.5,1.5],materialAlias:e});const i=1002;t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:i,color:[.5,1,.5],reflectionFactor:0,refractionFactor:.8,castShadowEnabled:!0,receiveLightEnabled:!0}),t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushBox({position:[-9.2,2,2],orientation:j(q()),boxSize:[.05,1.5,.5],materialAlias:i})}{let e=3e3;const i=i=>{var n,r,a,s,o,h,d,c,l,f,u,_;if(void 0!==i.color)return t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:++e,color:i.color,refractionFactor:null!==(n=i.refractionFactor)&&void 0!==n?n:0,reflectionFactor:null!==(r=i.reflectionFactor)&&void 0!==r?r:0,receiveLightEnabled:null===(a=i.receiveLightEnabled)||void 0===a||a,castShadowEnabled:null===(s=i.castShadowEnabled)||void 0===s||s});if(di(i)){const n=t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:++e,color:i.materialA.color,refractionFactor:null!==(o=i.materialA.refractionFactor)&&void 0!==o?o:0,reflectionFactor:null!==(h=i.materialA.reflectionFactor)&&void 0!==h?h:0,receiveLightEnabled:null===(d=i.materialA.receiveLightEnabled)||void 0===d||d,castShadowEnabled:null===(c=i.materialA.castShadowEnabled)||void 0===c||c}),r=t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:++e,color:i.materialB.color,refractionFactor:null!==(l=i.materialB.refractionFactor)&&void 0!==l?l:0,reflectionFactor:null!==(f=i.materialB.reflectionFactor)&&void 0!==f?f:0,receiveLightEnabled:null===(u=i.materialB.receiveLightEnabled)||void 0===u||u,castShadowEnabled:null===(_=i.materialB.castShadowEnabled)||void 0===_||_});return t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushChessboardMaterial({materialAlias:++e,chessboardArgs:i.chessboardArgs,castShadowEnabled:!0,materialAliasA:n,materialAliasB:r})}throw new Error("unknown material...?")};if(ci.forEach(((e,n)=>{const r=e.physicBody.getPosition(),a=e.physicBody.getRotation();t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushBox({position:r,orientation:a,boxSize:e.boxSize,materialAlias:i(e.material)})})),_i){if(!di(_i.material))throw new Error("should be chess material");const e=1,r=.1+.9*e,a=(n=ne(ie(.125*hi)),.5*(1+Math.sin(3.1415926*(n-.5)))),s=[1,1,1];s[0]=re(a,1,1),s[1]=re(a,1,1),s[2]=re(a,1,0),_i.material.materialB.color=s,_i.material.chessboardArgs=[1-(.05+.95*a),1-(.05+.95*a),1-(.05+.95*a)];const o=_i.physicBody.getPosition(),h=_i.physicBody.getRotation();t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushSphere({position:o,orientation:h,radius:_i.radius,materialAlias:i(_i.material)}),t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:668,color:[r*s[0],r*s[1],r*s[2]],reflectionFactor:0,refractionFactor:0,receiveLightEnabled:!1,castShadowEnabled:!1}),t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushSphere({position:o,orientation:h,radius:.9,materialAlias:668}),t.rayTracerRenderer.rayTracerPass.gpuSpotLightsManager.pushSpotLight({position:o,intensity:.1+3.9*e,radius:10})}if(gi){const e=gi.physicBody.getPosition(),n=gi.physicBody.getRotation();t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushSphere({position:e,orientation:n,radius:1.5,materialAlias:i(gi.material)})}t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:888,color:[0,0,1],reflectionFactor:.8,refractionFactor:0,receiveLightEnabled:!0,castShadowEnabled:!0}),t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushSphere({position:[-5,0,-7],orientation:j(q()),radius:5,materialAlias:888});{const e=[[-10,-1,3],[-10,-.5,2.5],[-10,-1,2],[-10,-.5,3.5],[-10,-1,4],[-10,-2,3]],i=4e3;t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:i,color:[1,.5,.5],reflectionFactor:0,refractionFactor:0,receiveLightEnabled:!0,castShadowEnabled:!0}),t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushTriangle({v0:e[0],v1:e[1],v2:e[2],materialAlias:i}),t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushTriangle({v0:e[0],v1:e[4],v2:e[3],materialAlias:i}),t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushTriangle({v0:e[2],v1:e[5],v2:e[4],materialAlias:i});const n=[];n.push([-10,-.5,2]),n.push([-10,0,2.5]),n.push([-10,-.5,3]),n.push([-10,0,3.5]),n.push([-10,-.5,4]);const r=5e3;t.rayTracerRenderer.rayTracerPass.gpuMaterialsManager.pushBasicMaterial({materialAlias:r,color:[1,.5,.5],reflectionFactor:0,castShadowEnabled:!0,receiveLightEnabled:!0,refractionFactor:0});for(const e of n)t.rayTracerRenderer.rayTracerPass.gpuShapesManager.pushBox({position:e,orientation:K(q(),[1,0,0],.25*Math.PI),boxSize:[.05,.25,.25],materialAlias:r})}}var n}}const{GlobalMouseManager:mi,GlobalKeyboardManager:xi,GlobalTouchManager:bi,GlobalVisibilityManager:vi,GlobalPointerLockManager:yi}=v,{WebGLContext:wi}=ze,{FreeFlyController:Si}=ee;class Ti{constructor(e){this._animationFrameHandle=0,this._resolution=9,this._timeRatio=1,this._hudVisible=!0,this._physicDebugModeEnabled=!1,this._showBvhDebugModeEnabled=!1,this._running=0,this._errorGraphicContext=!1,this._lastFrameTime=Date.now(),this._currFrameMsecTime=Date.now(),this._frameProfiler=new ae,this._perfAutoScalingEnabled=!0,this._framesUntilNextCheck=3,this._scene=new pi,this._def=e,this._freeFlyController=new Si({coordinates:["Z","X","Y"],position:[-5,5,10],theta:1.05*Math.PI,phi:.25*-Math.PI,mouseSensibility:6,keyboardSensibility:.55*Math.PI,touchSensibility:8,movingSpeed:16}),xi.activate(),bi.activate(this._def.domElement),vi.activate(),vi.addVisibilityChange((e=>{!1===e?(this._def.logger.log("document visibility changed: hidden"),this.stop()):(this._def.logger.log("document visibility changed: visible"),this.start())})),yi.allowPointerLockedOnClickEvent(this._def.domElement),yi.addOnLockChange((()=>{yi.isPointerLocked(this._def.domElement)?(this._def.logger.log("The pointer lock status is now locked"),mi.activate(this._def.domElement)):(this._def.logger.log("The pointer lock status is now unlocked"),mi.deactivate(this._def.domElement),yi.allowPointerLockedOnClickEvent(this._def.domElement))})),yi.addOnLockError((e=>{this._def.logger.log(`The pointer lock sent an error, event: "${JSON.stringify(e)}"`)})),this._renderer=new oi({width:this._def.width,height:this._def.height}),this._renderer.initialize(),this._physicWorld=new At.PhysicWorld,this._physicWorld.setGravity(0,-10,0);let t=0;t|=At.DebugDrawFlags.DBG_DrawWireframe,t|=At.DebugDrawFlags.DBG_DrawAabb,this._physicWorld.setDebugWireframeFeaturesFlag(t),this._physicWorld.setDebugWireframeCallback(((e,t,i,n,r,a,s,o,h)=>{this._renderer.stackRenderers.pushLine([e,t,i],[n,r,a],[s,o,h])})),this._scene.ensureSceneData(this._physicWorld)}start(){this.isRunning()||(this._running=-1,this._tick())}stop(){this.isRunning()&&(this._running=0,window.cancelAnimationFrame(this._animationFrameHandle))}updateCanvasOnce(){this._running>=0&&(this._running=1),this._tick()}isRunning(){return 0!==this._running&&!this.isCrashed()}isPaused(){return 0===this._running&&!this.isCrashed()}isCrashed(){return this._errorGraphicContext}setTimeRatio(e){this._timeRatio=te(e,0,4)}setHudVisibility(e){this._hudVisible=e,this.isPaused()&&this.updateCanvasOnce()}getHudVisibility(){return this._hudVisible}_tick(){const e=()=>{this.isRunning()&&(this._running>0&&(this._running-=1),0!==this._running&&(this._animationFrameHandle=window.requestAnimationFrame(e)),this._mainLoop())};e()}_mainLoop(){const e=Date.now(),t=e-this._lastFrameTime;this._lastFrameTime=e,this._handlePerformanceAutoScaling(t),this._frameProfiler.pushDelta(t);const i=e-this._currFrameMsecTime;this._currFrameMsecTime=e;const n=Math.min(i,40)/1e3;if(this._freeFlyController.update(n),mi.resetDeltas(),bi.resetDeltas(),this._physicWorld){let e=this._timeRatio;this._running>=0&&(e=0),this._scene.run(n*e,this._renderer,this._physicWorld)}this._renderScene(),this._renderHud(),this._renderer.rayTracerRenderer.renderRayTracingPass(),this._renderer.rayTracerRenderer.rayTracerPass.reset()}_renderHud(){const e=wi.getContext();if(e.viewport(0,0,this._def.width,this._def.height),e.clear(e.DEPTH_BUFFER_BIT),e.enable(e.DEPTH_TEST),e.depthFunc(e.LESS),this._hudVisible){{const e=[27,260],t=[7,35];it([27,165],this._renderer.stackRenderers,this._renderer.textRenderer),nt(e,this._renderer.stackRenderers,this._renderer.textRenderer),rt(this._def.domElement,t,this._renderer.stackRenderers,this._renderer.textRenderer)}at([10,this._def.height-60,0],[100,50],this._frameProfiler,this._renderer.stackRenderers,this._renderer.textRenderer,!0),this._renderer.flushHudWireFrame(),this._renderer.flushHudText()}}_renderScene(){{const e=wi.getContext();e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),e.disable(e.DEPTH_TEST)}this._renderer.rayTracerRenderer.rayTracerPass.lookAt(this._freeFlyController.getPosition(),this._freeFlyController.getTarget(),this._freeFlyController.getUpAxis()),this._renderer.rayTracerRenderer.renderTexturePass(),this._physicDebugModeEnabled&&(this._renderer.stackRenderers.clear(),this._renderer.safeSceneWireFrame((()=>{const e=[0,0,0];this._renderer.stackRenderers.pushLine(e,[100,0,0],[1,0,0]),this._renderer.stackRenderers.pushLine(e,[0,100,0],[0,1,0]),this._renderer.stackRenderers.pushLine(e,[0,0,100],[0,0,1]),this._physicWorld.debugDrawWorld()}))),this._showBvhDebugModeEnabled&&(this._renderer.stackRenderers.clear(),this._renderer.safeSceneWireFrame((()=>{const e=[0,0,0];this._renderer.stackRenderers.pushLine(e,[100,0,0],[1,0,0]),this._renderer.stackRenderers.pushLine(e,[0,100,0],[0,1,0]),this._renderer.stackRenderers.pushLine(e,[0,0,100],[0,0,1]),this._renderer.bvhRenderDebugWireframe()})))}setResolution(e){const t=te(e,0,9);this._resolution=t;const i=1/(10-t);this._renderer.rayTracerRenderer.setResolutionCoef(i),this.isPaused()&&this.updateCanvasOnce()}getResolution(){return this._resolution}setOnResolutionChange(e){this._onResolutionChange=e}setPhysicDebugModeEnabled(e){this._physicDebugModeEnabled=e,this.isPaused()&&this.updateCanvasOnce()}setShowBvhDebugModeEnabled(e){this._showBvhDebugModeEnabled=e,this.isPaused()&&this.updateCanvasOnce()}setAntiAliasing(e){this._renderer.rayTracerRenderer.setAntiAliasing(e),this._def.logger.log("Anti aliasing change: "+(!0===e?"enabled":"disabled")),this.isPaused()&&this.updateCanvasOnce()}logResolution(){const e=this._renderer.rayTracerRenderer,t=e.getResolutionCoef(),i=e.rayTracerPass.getCurrentSize(),n=i[0]*i[1];this._def.logger.log(`resolution changed (1/${Math.ceil(1/t)}) => ${i[0]}x${i[1]} (${n}px)`)}setPerformanceAutoScaling(e){this._framesUntilNextCheck=3,this._perfAutoScalingEnabled=e,this._def.logger.log("Performance auto scaler change: "+(e?"enabled":"disabled"))}_handlePerformanceAutoScaling(e){if(!0!==this._perfAutoScalingEnabled)return;if(e<=20)return void(this._framesUntilNextCheck=3);if(--this._framesUntilNextCheck,this._framesUntilNextCheck>0)return;this._def.logger.log("performance auto scaling: slow framerate, scaling down resolution");const t=this._resolution-1;t>=0&&t<=9&&(this.setResolution(t),this.logResolution(),this._resolution=t,this._onResolutionChange&&this._onResolutionChange()),this._framesUntilNextCheck=3}}let Ei=null,Ri=null;const Ai=e=>{const t=document.querySelector(e);if(!t)throw new Error(`html element "${e}" not found`);return t},Mi=[],Ci=t=>e(void 0,void 0,void 0,(function*(){for(const e of[...Mi].reverse())try{yield e(t)}catch(e){}}));Mi.push((e=>{if(console.log("onError",e),Ri){try{Ri.stop()}catch(e){}Ri=null}})),window.addEventListener("load",(()=>e(void 0,void 0,void 0,(function*(){try{Ei=new dt("loggerOutput"),Ei.log("[SETUP] page loaded");const e=Ai("#rendering-canvas");Mi.push((t=>{o.deactivate(),d.deactivate(e),m.deactivate(e),n.removeAllCallbacks(),g.removeAllCallbacks(),x.removeAllCallbacks(),x.deactivate()}));const t=Ai("#play-button"),i=Ai("#pause-button"),r=Ai("#stop-button"),a=Ai("#toggle-button"),s=Ai("#auto-scaling-enabled"),h=Ai("#resolution"),c=Ai("#anti-aliasing-enabled"),l=Ai("#debug-mode-enabled"),f=Ai("#bvh-debug-mode-enabled"),u=Ai("#error-text");if(Mi.push((n=>{u.style.width="800px",u.style.height="600px",u.innerHTML=n.message,e.style.display="none",u.style.display="block",t.disabled=!0,i.disabled=!0,r.disabled=!0,s.disabled=!0,h.min=h.max=h.value=0,c.disabled=!0,l.disabled=!0,f.disabled=!0,document.title+=" (ERR)"})),!b())throw new Error("missing WebGL2 feature (unsupported)");yield Rt.load({jsUrl:"./dist/wasm/FrankenPhys.0.0.1.js",wasmUrl:"./dist/wasm"}),At.WasmModuleHolder.set(Rt.get()),fe.initialize(e),Ri=new Ti({domElement:e,width:e.width,height:e.height,logger:Ei}),Ri.setResolution(7),Ri.setOnResolutionChange((()=>{Ri&&(h.value=Ri.getResolution())})),t.addEventListener("click",(()=>{Ri&&(Ri.setTimeRatio(1),Ri.start())})),i.addEventListener("click",(()=>{Ri&&(Ri.setTimeRatio(0),Ri.start())})),r.addEventListener("click",(()=>{Ri&&Ri.stop()})),a.addEventListener("click",(()=>{Ri&&Ri.setHudVisibility(!Ri.getHudVisibility())})),s.addEventListener("input",(()=>{Ri&&Ri.setPerformanceAutoScaling(s.checked)})),h.addEventListener("input",(e=>{if(!Ri)return;const t=h.value;Ri.setResolution(t),Ri.logResolution()})),c.addEventListener("click",(()=>{if(!Ri||!Ei)return;const e=!0===c.checked;Ri.setAntiAliasing(e)})),l.addEventListener("click",(()=>{Ri&&Ri.setPhysicDebugModeEnabled(l.checked)})),f.addEventListener("click",(()=>{Ri&&Ri.setShowBvhDebugModeEnabled(f.checked)})),Ei.log("[SETUP] Demo: started"),Ri.start(),Ei.log("[SETUP] Demo: running"),((e,t)=>{if(!x.isSupported())return;let i=-1;x.addVisibilityChange((e=>{e?i>=0&&(clearTimeout(i),i=-1):i=window.setTimeout(t,6e4)})),x.activate()})(0,(()=>{Ci(new Error("\n        <br/>\n        <br/>\n        <br/>\n        The page was inactive for too long<br/>\n        <br/>\n        please reload\n      "))}))}catch(e){console.log("err.message",e.message),Ci(e)}}))),!1);
